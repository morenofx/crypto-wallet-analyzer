<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CryptoFolio v4.7 - Multi-Exchange</title>
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <script>
        const firebaseConfig = {
            apiKey: "AIzaSyDAmtceQc0m-KQC7xGmu0IH1cR4tnI8oCQ",
            authDomain: "moreno-crypto-tools.firebaseapp.com",
            projectId: "moreno-crypto-tools",
            storageBucket: "moreno-crypto-tools.firebasestorage.app",
            messagingSenderId: "875997322481",
            appId: "1:875997322481:web:1a012bec2aff2cb5205d50"
        };
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();
    </script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --bg-primary: #0f0f1a;
            --bg-secondary: #1a1a2e;
            --bg-card: #16213e;
            --text-primary: #ffffff;
            --text-secondary: #a0a0a0;
            --accent: #6c5ce7;
            --accent-light: #a29bfe;
            --green: #00cec9;
            --red: #ff6b6b;
            --border: #2d2d44;
        }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: var(--bg-primary); color: var(--text-primary); min-height: 100vh; }
        .app-container { display: flex; min-height: 100vh; }
        .sidebar { width: 240px; background: var(--bg-secondary); padding: 20px; display: flex; flex-direction: column; border-right: 1px solid var(--border); }
        .logo { display: flex; align-items: center; gap: 12px; margin-bottom: 40px; }
        .logo-icon { width: 40px; height: 40px; background: linear-gradient(135deg, var(--accent), var(--accent-light)); border-radius: 10px; display: flex; align-items: center; justify-content: center; font-size: 20px; }
        .logo-text { font-size: 20px; font-weight: 700; }
        .nav-section { margin-bottom: 30px; }
        .nav-label { font-size: 11px; color: var(--text-secondary); margin-bottom: 12px; text-transform: uppercase; letter-spacing: 1px; }
        .nav-item { display: flex; align-items: center; gap: 12px; padding: 12px 16px; border-radius: 8px; cursor: pointer; transition: all 0.2s; margin-bottom: 4px; }
        .nav-item:hover { background: var(--bg-card); }
        .nav-item.active { background: var(--accent); }
        .nav-item .icon { font-size: 18px; }
        .nav-item .badge { margin-left: auto; background: var(--accent); padding: 2px 8px; border-radius: 10px; font-size: 11px; }
        .nav-item.active .badge { background: rgba(255,255,255,0.2); }
        .sidebar-footer { margin-top: auto; padding-top: 20px; border-top: 1px solid var(--border); }
        .version { font-size: 12px; color: var(--text-secondary); }
        .main-content { flex: 1; padding: 30px; overflow-y: auto; }
        .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 30px; }
        .header h1 { font-size: 28px; font-weight: 600; }
        .header-actions { display: flex; gap: 12px; align-items: center; }
        .btn { padding: 10px 20px; border-radius: 8px; border: none; cursor: pointer; font-size: 14px; font-weight: 500; transition: all 0.2s; }
        .btn-primary { background: var(--accent); color: white; }
        .btn-primary:hover { background: var(--accent-light); }
        .btn-secondary { background: var(--bg-card); color: var(--text-primary); border: 1px solid var(--border); }
        .stats-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px; margin-bottom: 30px; }
        .stat-card { background: var(--bg-card); padding: 24px; border-radius: 16px; border: 1px solid var(--border); }
        .stat-label { font-size: 13px; color: var(--text-secondary); margin-bottom: 8px; }
        .stat-value { font-size: 28px; font-weight: 700; color: var(--green); }
        .stat-change { font-size: 13px; margin-top: 4px; }
        .content-grid { display: grid; grid-template-columns: 2fr 1fr; gap: 20px; }
        .card { background: var(--bg-card); border-radius: 16px; padding: 24px; border: 1px solid var(--border); }
        .card-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
        .card-title { font-size: 18px; font-weight: 600; }
        .holdings-table { width: 100%; border-collapse: collapse; table-layout: fixed; }
        .holdings-table th { text-align: left; padding: 12px 8px; color: var(--text-secondary); font-size: 12px; text-transform: uppercase; border-bottom: 1px solid var(--border); font-weight: 500; letter-spacing: 0.5px; }
        .holdings-table th:nth-child(1) { width: 40%; text-align: left; }
        .holdings-table th:nth-child(2) { width: 20%; text-align: right; }
        .holdings-table th:nth-child(3) { width: 18%; text-align: right; }
        .holdings-table th:nth-child(4) { width: 22%; text-align: right; }
        .holdings-table td { padding: 16px 8px; border-bottom: 1px solid var(--border); vertical-align: middle; }
        .holdings-table td:nth-child(2), .holdings-table td:nth-child(3), .holdings-table td:nth-child(4) { text-align: right; }
        .holdings-table tr:hover { background: rgba(255,255,255,0.02); }
        
        /* Tabella transazioni exchange */
        .tx-table { width: 100%; border-collapse: collapse; table-layout: auto; }
        .tx-table th { padding: 10px 12px; color: var(--text-secondary); font-size: 11px; text-transform: uppercase; border-bottom: 1px solid var(--border); font-weight: 600; letter-spacing: 0.5px; }
        .tx-table td { padding: 12px; border-bottom: 1px solid rgba(255,255,255,0.05); vertical-align: middle; }
        .tx-table tr:hover { background: rgba(255,255,255,0.02); }
        .tx-badge { display: inline-flex; align-items: center; gap: 5px; padding: 5px 10px; border-radius: 6px; font-size: 12px; font-weight: 600; white-space: nowrap; }
        
        .token-cell { display: flex; align-items: center; gap: 12px; }
        .token-icon { width: 40px; height: 40px; border-radius: 50%; background: var(--bg-secondary); display: flex; align-items: center; justify-content: center; font-weight: 600; font-size: 12px; overflow: hidden; flex-shrink: 0; }
        .token-icon img { width: 100%; height: 100%; object-fit: cover; }
        .token-info .symbol { font-weight: 600; font-size: 14px; }
        .token-info .name { font-size: 12px; color: var(--text-secondary); margin-top: 2px; }
        .text-right { text-align: right; }
        .text-mono { font-family: 'SF Mono', Monaco, monospace; font-size: 13px; }
        .text-secondary { color: var(--text-secondary); }
        .wallet-input-section { background: var(--bg-card); padding: 20px; border-radius: 16px; margin-bottom: 20px; border: 1px solid var(--border); }
        .input-row { display: flex; gap: 16px; margin-bottom: 16px; }
        .input-group { flex: 1; }
        .input-group label { display: block; font-size: 12px; color: var(--text-secondary); margin-bottom: 8px; }
        .input-group input { width: 100%; padding: 12px; background: var(--bg-primary); border: 1px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 14px; }
        .input-group input:focus { outline: none; border-color: var(--accent); }
        .chain-selector { display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 16px; }
        .chain-btn { padding: 8px 14px; border-radius: 8px; border: 1px solid var(--border); background: var(--bg-primary); color: var(--text-secondary); cursor: pointer; font-size: 13px; transition: all 0.2s; display: flex; align-items: center; gap: 6px; }
        .chain-btn:hover { border-color: var(--accent); }
        .chain-btn.active { background: var(--accent); color: white; border-color: var(--accent); }
        .chain-dot { width: 8px; height: 8px; border-radius: 50%; }
        .status-log { background: var(--bg-primary); border-radius: 8px; padding: 12px; max-height: 150px; overflow-y: auto; font-family: 'SF Mono', Monaco, monospace; font-size: 12px; }
        .log-line { padding: 4px 0; }
        .log-line.success { color: var(--green); }
        .log-line.error { color: var(--red); }
        .log-line.info { color: var(--text-secondary); }
        .empty-state { text-align: center; padding: 40px; color: var(--text-secondary); }
        .empty-state .icon { font-size: 48px; margin-bottom: 16px; }
        .verify-link { display: inline-flex; align-items: center; gap: 6px; color: var(--accent-light); font-size: 13px; text-decoration: none; }
        .chain-badge { display: inline-block; font-size: 9px; padding: 2px 6px; border-radius: 4px; margin-left: 6px; font-weight: 600; text-transform: uppercase; }
        .blacklist-item { display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg-primary); border-radius: 8px; margin-bottom: 8px; }
        .btn-restore { background: var(--green); color: white; border: none; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 12px; }
        .hide-btn { background: transparent; border: none; color: var(--text-secondary); cursor: pointer; font-size: 10px; padding: 2px 6px; border-radius: 4px; margin-right: 8px; opacity: 0.5; }
        .hide-btn:hover { background: var(--red); color: white; opacity: 1; }
        .api-status { padding: 6px 12px; border-radius: 6px; font-size: 11px; font-weight: 600; }
        .api-status[id$="Status"] { background: var(--red); color: white; }
        .api-on { background: var(--green) !important; color: #000 !important; }
        
        /* Modal Styles */
        .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center; z-index: 1000; opacity: 0; visibility: hidden; transition: all 0.3s ease; }
        .modal-overlay.active { opacity: 1; visibility: visible; }
        .modal-content { background: var(--bg-card); border-radius: 16px; padding: 0; width: 90%; max-width: 480px; border: 1px solid var(--border); transform: scale(0.9); transition: transform 0.3s ease; box-shadow: 0 20px 60px rgba(0,0,0,0.5); }
        .modal-overlay.active .modal-content { transform: scale(1); }
        .modal-header { display: flex; align-items: center; justify-content: space-between; padding: 20px 24px; border-bottom: 1px solid var(--border); background: linear-gradient(135deg, rgba(243,186,47,0.15), rgba(243,186,47,0.05)); border-radius: 16px 16px 0 0; }
        .modal-header h3 { font-size: 18px; font-weight: 600; display: flex; align-items: center; gap: 10px; }
        .modal-close { background: none; border: none; color: var(--text-secondary); font-size: 24px; cursor: pointer; padding: 4px; line-height: 1; transition: color 0.2s; }
        .modal-close:hover { color: var(--red); }
        .modal-body { padding: 24px; }
        .modal-footer { padding: 16px 24px; border-top: 1px solid var(--border); display: flex; justify-content: flex-end; gap: 12px; }
        .form-group { margin-bottom: 16px; }
        .form-label { display: block; font-size: 12px; color: var(--text-secondary); margin-bottom: 6px; font-weight: 500; }
        .form-input { width: 100%; padding: 12px 14px; background: var(--bg-primary); border: 1px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 14px; transition: border-color 0.2s; }
        .form-input:focus { outline: none; border-color: var(--accent); }
        .form-input::placeholder { color: var(--text-secondary); }
        .server-status-box { display: flex; align-items: center; justify-content: space-between; padding: 12px 16px; background: var(--bg-primary); border-radius: 8px; margin-bottom: 20px; }
        .server-status-label { font-size: 13px; color: var(--text-secondary); }
        .server-status-badge { font-size: 11px; font-weight: 600; padding: 4px 10px; border-radius: 20px; }
        .server-off { background: var(--red); color: #fff; }
        .server-on { background: var(--green); color: #000; }
        .api-help-link { display: block; text-align: center; font-size: 12px; color: var(--accent-light); margin-top: 16px; }
        .api-help-link:hover { text-decoration: underline; }
        .progress-container { margin-top: 20px; display: none; }
        .progress-bar-bg { background: var(--bg-primary); border-radius: 6px; height: 8px; overflow: hidden; }
        .progress-bar-fill { background: linear-gradient(90deg, #f3ba2f, #f0b90b); height: 100%; width: 0%; transition: width 0.3s ease; }
        .progress-text { font-size: 12px; color: var(--text-secondary); margin-top: 8px; text-align: center; }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="sidebar">
            <div class="logo"><div class="logo-icon">ğŸ“Š</div><span class="logo-text">CryptoFolio</span></div>
            <div class="nav-section">
                <div class="nav-label">Menu</div>
                <div class="nav-item active" onclick="showView('dashboard')"><span class="icon">ğŸ“ˆ</span><span>Dashboard</span></div>
                <div class="nav-item" onclick="showView('wallets')"><span class="icon">ğŸ‘›</span><span>Wallets</span><span class="badge" id="walletCount">0</span></div>
                <div class="nav-item" onclick="showView('nft')"><span class="icon">ğŸ–¼ï¸</span><span>NFT</span><span class="badge" id="nftCount">0</span></div>
                <div class="nav-item" onclick="showView('exchanges')"><span class="icon">ğŸ¦</span><span>Exchanges</span><span class="badge" id="exchangeCount">0</span></div>
                <div class="nav-item" onclick="showView('reconcile')"><span class="icon">ğŸ”—</span><span>Riconciliazione</span></div>
                <div class="nav-item" onclick="showView('tax')"><span class="icon">ğŸ“‹</span><span>Tax Report</span></div>
                <div class="nav-item" onclick="showView('api')"><span class="icon">ğŸ”Œ</span><span>API Connect</span><span class="badge" id="apiCount">0</span></div>
            </div>
            <div class="nav-section">
                <div class="nav-label">Settings</div>
                <div class="nav-item" onclick="toggleBlacklist()"><span class="icon">ğŸš«</span><span>Token Nascosti</span><span class="badge" id="blacklistCount">0</span></div>
                <div class="nav-item" onclick="forceSyncFirebase()"><span class="icon">â˜ï¸</span><span>Force Sync</span></div>
                <div class="nav-item" onclick="clearWalletResults()"><span class="icon">ğŸ—‘ï¸</span><span>Reset Scan</span></div>
            </div>
            <div class="sidebar-footer">
                <div style="display:flex;align-items:center;gap:8px;margin-bottom:8px;">
                    <span class="sync-dot" id="syncDot" style="width:8px;height:8px;border-radius:50%;background:var(--green);"></span>
                    <span id="syncStatus" style="font-size:11px;color:var(--text-secondary);">Connesso</span>
                </div>
                <div class="version">v4.5 - Multi-Exchange</div>
            </div>
        </div>
        
        <!-- DASHBOARD -->
        <div class="main-content" id="dashboardView">
            <div class="header"><h1>Dashboard</h1><div class="header-actions"><span id="lastUpdate" style="font-size:13px;color:var(--text-secondary);"></span><button class="btn btn-secondary" onclick="scanAllWallets()" style="margin-right:8px;">ğŸ“Š Scan All</button><button class="btn btn-primary" onclick="scanWallet()">ğŸ” Scan</button></div></div>
            
            <div class="wallet-input-section">
                <div class="input-row">
                    <div class="input-group" style="flex:2;">
                        <label>Wallet</label>
                        <div style="display:flex;gap:8px;">
                            <select id="walletSelect" onchange="onWalletSelect()" style="flex:1;padding:12px;background:var(--bg-primary);border:1px solid var(--border);border-radius:8px;color:var(--text-primary);font-size:14px;">
                                <option value="">-- Seleziona o inserisci --</option>
                            </select>
                            <input type="text" id="walletAddress" placeholder="0x... o seleziona sopra" autocomplete="off" style="flex:2;">
                        </div>
                    </div>
                    <div class="input-group"><label>API Key <a href="#" onclick="showView('api');return false;" style="color:var(--accent-light);font-size:11px;margin-left:8px;">â†’ Configura in API Connect</a></label><input type="text" id="apiKey" placeholder="Configura in API Connect..." autocomplete="off" readonly onclick="showView('api')" style="cursor:pointer;"></div>
                </div>
                <label style="display:block;font-size:12px;color:var(--text-secondary);margin-bottom:8px;">Chains</label>
                <div class="chain-selector" id="chainSelector"></div>
                <div class="status-log" id="statusLog"><div class="log-line info">ğŸ‘‹ Configura le API in <strong>API Connect</strong>, seleziona un wallet e clicca "Scan"</div></div>
            </div>
            
            <div class="stats-grid">
                <div class="stat-card"><div class="stat-label">ğŸ’° Portfolio Value</div><div class="stat-value" id="totalEUR">â‚¬0,00</div><div class="stat-change text-secondary" id="totalUSD">$0,00 USD</div></div>
                <div class="stat-card"><div class="stat-label">ğŸª™ Assets</div><div class="stat-value" id="tokenCount">0</div><div class="stat-change text-secondary">tokens</div></div>
                <div class="stat-card"><div class="stat-label">ğŸ‘› Wallets</div><div class="stat-value" id="scannedWallets">0</div><div class="stat-change text-secondary" id="chainNames">-</div></div>
                <div class="stat-card" style="cursor:pointer;" onclick="showView('exchanges')"><div class="stat-label">ğŸ¦ Exchanges</div><div class="stat-value" id="exchangeTotalEUR" style="color:#f3ba2f;">â‚¬0,00</div><div class="stat-change text-secondary" id="exchangeNames">Binance</div></div>
                <div class="stat-card"><div class="stat-label">ğŸ’± EUR/USD</div><div class="stat-value" id="eurUsdRate">0.849</div><div class="stat-change text-secondary">rate</div></div>
            </div>
            
            <div class="content-grid">
                <div class="card"><div class="card-header"><div class="card-title">Holdings</div></div><div id="holdingsContent"><div class="empty-state"><div class="icon">ğŸ‘›</div><h3>Nessun dato</h3></div></div></div>
                <div class="card"><div class="card-header"><div class="card-title">Allocation</div></div><canvas id="allocationChart"></canvas></div>
            </div>
            
            <div class="card" id="blacklistPanel" style="display:none;margin-top:20px;"><div class="card-header"><div class="card-title">ğŸš« Token Nascosti</div><button class="btn btn-secondary" onclick="clearBlacklist()" style="font-size:12px;padding:6px 12px;">ğŸ—‘ï¸ Svuota</button></div><div id="blacklistContent"></div></div>
        </div>
        
        <!-- WALLETS -->
        <div class="main-content" id="walletsView" style="display:none;">
            <div class="header"><h1>ğŸ‘› Gestione Wallets</h1></div>
            
            <div class="card" style="margin-bottom:20px;">
                <div class="card-header"><div class="card-title">â• Aggiungi Wallet</div></div>
                <div class="input-row">
                    <div class="input-group"><label>Nome (es. "Main", "Trading", "Cold")</label><input type="text" id="newWalletName" placeholder="Nome wallet..." autocomplete="off"></div>
                    <div class="input-group" style="flex:2;"><label>Indirizzo (EVM o Solana)</label><input type="text" id="newWalletAddress" placeholder="0x... o indirizzo Solana" autocomplete="off"></div>
                </div>
                <button class="btn btn-primary" onclick="addWallet()" style="margin-top:12px;">ğŸ’¾ Salva Wallet</button>
            </div>
            
            <div class="card">
                <div class="card-header"><div class="card-title">ğŸ“‹ Wallets Salvati</div></div>
                <div id="walletsList"></div>
            </div>
        </div>
        
        <!-- WALLET DETAIL -->
        <div class="main-content" id="walletDetailView" style="display:none;">
            <div class="header">
                <div style="display:flex;align-items:center;gap:16px;">
                    <button class="btn btn-secondary" onclick="showView('wallets')" style="padding:8px 12px;">â† Indietro</button>
                    <h1 id="detailWalletName">Wallet</h1>
                </div>
                <div class="header-actions">
                    <button class="btn btn-primary" onclick="scanDetailWallet()">ğŸ” Scan</button>
                </div>
            </div>
            
            <div class="card" style="margin-bottom:20px;">
                <div style="display:flex;align-items:center;gap:16px;">
                    <div style="width:64px;height:64px;border-radius:16px;background:linear-gradient(135deg,var(--accent),var(--accent-light));display:flex;align-items:center;justify-content:center;font-size:28px;">ğŸ‘›</div>
                    <div style="flex:1;">
                        <div style="font-size:13px;color:var(--text-secondary);">Indirizzo</div>
                        <div id="detailWalletAddress" style="font-family:monospace;font-size:14px;word-break:break-all;"></div>
                        <div id="detailScanDate" style="font-size:12px;color:var(--text-secondary);margin-top:6px;"></div>
                    </div>
                    <button class="btn btn-secondary" onclick="copyDetailAddress()" style="margin-left:auto;padding:8px 12px;">ğŸ“‹ Copia</button>
                </div>
            </div>
            
            <div class="stats-grid" style="grid-template-columns:repeat(4,1fr);">
                <div class="stat-card"><div class="stat-label">ğŸ’° Totale</div><div class="stat-value" id="detailTotal">â‚¬0,00</div></div>
                <div class="stat-card"><div class="stat-label">â›“ï¸ Chains</div><div class="stat-value" id="detailChainCount">0</div></div>
                <div class="stat-card"><div class="stat-label">ğŸª™ Token</div><div class="stat-value" id="detailTokenCount">0</div></div>
                <div class="stat-card"><div class="stat-label">ğŸ“œ Transazioni</div><div class="stat-value" id="detailTxCount">0</div></div>
            </div>
            
            <!-- Tab Selector -->
            <div style="display:flex;gap:8px;margin:20px 0;">
                <button class="btn btn-primary" id="tabTokensBtn" onclick="showWalletTab('tokens')">ğŸª™ Token</button>
                <button class="btn btn-secondary" id="tabTxBtn" onclick="showWalletTab('transactions')">ğŸ“œ Transazioni</button>
            </div>
            
            <div id="detailChainsContent"></div>
            <div id="detailTxContent" style="display:none;"></div>
        </div>
        
        <!-- TAX REPORT -->
        <div class="main-content" id="taxView" style="display:none;">
            <div class="header"><h1>ğŸ“‹ Tax Report - Quadro RW</h1><div class="header-actions"><button class="btn" onclick="clearTaxReport()" style="margin-right:8px;background:var(--bg-secondary);">ğŸ—‘ï¸ Reset</button><button class="btn btn-secondary" onclick="printTaxReport()" style="margin-right:8px;">ğŸ–¨ï¸ Stampa PDF</button><button class="btn btn-primary" onclick="calculateTaxReportAll()">ğŸ§® Calcola Tutti</button></div></div>
            
            <div class="card" style="margin-bottom:20px;">
                <p style="color:var(--text-secondary);font-size:14px;line-height:1.6;">
                    Il <strong>Quadro RW</strong> richiede il valore al <strong>31 dicembre</strong> di ogni anno fiscale. Soglia: <strong>â‚¬15.000</strong>.<br>
                    Calcola il valore aggregato di <strong>wallet + exchange</strong>.
                </p>
                <div id="taxWalletsList" style="margin-top:12px;"></div>
            </div>
            
            <!-- EXCHANGE VALUES -->
            <div class="card" style="margin-bottom:20px;">
                <div class="card-header">
                    <div class="card-title">ğŸ¦ Valori Exchange (31/12)</div>
                    <button class="btn btn-primary" onclick="saveExchangeValues()" style="padding:8px 16px;">ğŸ’¾ Salva</button>
                </div>
                <p style="color:var(--text-secondary);font-size:13px;margin-bottom:16px;">Inserisci il valore totale degli exchange al 31 dicembre di ogni anno (in EUR). Questi valori verranno sommati ai wallet.</p>
                <div style="display:grid;grid-template-columns:repeat(6,1fr);gap:12px;">
                    <div class="input-group">
                        <label>2021</label>
                        <input type="number" id="exchange2021" placeholder="â‚¬" step="0.01" style="text-align:right;">
                    </div>
                    <div class="input-group">
                        <label>2022</label>
                        <input type="number" id="exchange2022" placeholder="â‚¬" step="0.01" style="text-align:right;">
                    </div>
                    <div class="input-group">
                        <label>2023</label>
                        <input type="number" id="exchange2023" placeholder="â‚¬" step="0.01" style="text-align:right;">
                    </div>
                    <div class="input-group">
                        <label>2024</label>
                        <input type="number" id="exchange2024" placeholder="â‚¬" step="0.01" style="text-align:right;">
                    </div>
                    <div class="input-group">
                        <label>2025</label>
                        <input type="number" id="exchange2025" placeholder="â‚¬" step="0.01" style="text-align:right;">
                    </div>
                    <div class="input-group">
                        <label>2026</label>
                        <input type="number" id="exchange2026" placeholder="â‚¬" step="0.01" style="text-align:right;">
                    </div>
                </div>
                <div style="margin-top:12px;font-size:12px;color:var(--text-secondary);">
                    ğŸ’¡ Puoi recuperare questi valori da OKIPO, Binance Tax Report, o i tuoi record personali.
                </div>
            </div>
            
            <div class="card"><div class="card-header"><div class="card-title">ğŸ“Š Totale Portfolio per Anno (31/12)</div></div><div id="taxReportContent"><div class="empty-state"><div class="icon">ğŸ‘†</div><h3>Clicca "Calcola Tutti" per iniziare</h3></div></div></div>
            <div class="card" id="taxDetailCard" style="display:none;margin-top:20px;"><div class="card-header"><div class="card-title">ğŸ“ Dettaglio Token per Wallet</div></div><div id="taxDetailContent"></div></div>
        </div>
        
        <!-- API CONNECT -->
        <div class="main-content" id="apiView" style="display:none;">
            <div class="header"><h1>ğŸ”Œ API Connect</h1></div>
            
            <div class="card" style="margin-bottom:20px;">
                <p style="color:var(--text-secondary);font-size:14px;line-height:1.6;">
                    Configura le API per accedere ai dati blockchain. <strong>Moralis</strong> Ã¨ consigliato per scan veloci, <strong>Etherscan</strong> per il Tax Report storico.
                </p>
            </div>
            
            <!-- MORALIS -->
            <div class="card" style="margin-bottom:20px;">
                <div class="card-header">
                    <div class="card-title" style="display:flex;align-items:center;gap:12px;">
                        <span style="width:40px;height:40px;background:#21BF96;border-radius:10px;display:flex;align-items:center;justify-content:center;font-size:20px;">ğŸŸ¢</span>
                        <div>
                            <div>Moralis</div>
                            <div style="font-size:12px;color:var(--text-secondary);font-weight:normal;">Scan veloce â€¢ Balance diretti â€¢ Multi-chain</div>
                        </div>
                    </div>
                    <span class="api-status" id="moralisStatus">OFF</span>
                </div>
                <div class="input-row" style="margin-top:16px;">
                    <div class="input-group" style="flex:3;">
                        <label>API Keys <span style="font-weight:normal;color:var(--text-secondary);">(1 per riga per cascata)</span> <a href="https://admin.moralis.io/api-keys" target="_blank" style="color:var(--accent);font-size:11px;margin-left:8px;">â†’ Ottieni gratis</a></label>
                        <textarea id="moralisKey" rows="3" placeholder="eyJhbGci... (prima key)&#10;eyJhbGci... (seconda key)&#10;eyJhbGci... (terza key)" autocomplete="off" style="resize:vertical;min-height:60px;"></textarea>
                    </div>
                    <div class="input-group" style="flex:0;align-self:flex-end;">
                        <button class="btn btn-primary" onclick="saveMoralisKey()">ğŸ’¾ Salva</button>
                    </div>
                </div>
                <div style="margin-top:12px;padding:12px;background:var(--bg-primary);border-radius:8px;font-size:12px;">
                    <strong>Chains supportate:</strong> Ethereum, BSC, Polygon, Arbitrum, Optimism, Base, Cronos<br>
                    <strong>Limite free:</strong> 25 req/sec, 10.000/giorno per account<br>
                    <strong>ğŸ’¡ Multi-account:</strong> Inserisci piÃ¹ keys (1 per riga) - quando una raggiunge il limite, passa alla successiva!
                </div>
            </div>
            
            <!-- ETHERSCAN -->
            <div class="card" style="margin-bottom:20px;">
                <div class="card-header">
                    <div class="card-title" style="display:flex;align-items:center;gap:12px;">
                        <span style="width:40px;height:40px;background:#21325B;border-radius:10px;display:flex;align-items:center;justify-content:center;font-size:20px;">ğŸ”µ</span>
                        <div>
                            <div>Etherscan</div>
                            <div style="font-size:12px;color:var(--text-secondary);font-weight:normal;">Tax Report â€¢ Storico transazioni â€¢ Multi-chain V2</div>
                        </div>
                    </div>
                    <span class="api-status" id="etherscanStatus">OFF</span>
                </div>
                <div class="input-row" style="margin-top:16px;">
                    <div class="input-group" style="flex:3;">
                        <label>API Key <a href="https://etherscan.io/myapikey" target="_blank" style="color:var(--accent);font-size:11px;margin-left:8px;">â†’ Ottieni gratis</a></label>
                        <input type="password" id="etherscanKey" placeholder="ABCDEF..." autocomplete="off">
                    </div>
                    <div class="input-group" style="flex:0;align-self:flex-end;">
                        <button class="btn btn-primary" onclick="saveEtherscanKey()">ğŸ’¾ Salva</button>
                    </div>
                </div>
                <div style="margin-top:12px;padding:12px;background:var(--bg-primary);border-radius:8px;font-size:12px;">
                    <strong>Chains supportate:</strong> Ethereum, BSC, Polygon, Arbitrum, Optimism, Base (API V2)<br>
                    <strong>Limite free:</strong> 5 req/sec, 100.000/giorno
                </div>
            </div>
            
            <!-- PULSESCAN -->
            <div class="card" style="margin-bottom:20px;">
                <div class="card-header">
                    <div class="card-title" style="display:flex;align-items:center;gap:12px;">
                        <span style="width:40px;height:40px;background:#00ff00;border-radius:10px;display:flex;align-items:center;justify-content:center;font-size:20px;">ğŸ’š</span>
                        <div>
                            <div>PulseChain</div>
                            <div style="font-size:12px;color:var(--text-secondary);font-weight:normal;">PulseScan API â€¢ Gratuito â€¢ No API key richiesta</div>
                        </div>
                    </div>
                    <span class="api-status" style="background:var(--green);color:#000;">AUTO</span>
                </div>
                <div style="margin-top:12px;padding:12px;background:var(--bg-primary);border-radius:8px;font-size:12px;">
                    <strong>Endpoint:</strong> api.scan.pulsechain.com<br>
                    <strong>Note:</strong> Nessuna configurazione necessaria, funziona automaticamente
                </div>
            </div>
            
            <!-- SOLANA / HELIUS -->
            <div class="card" style="margin-bottom:20px;">
                <div class="card-header">
                    <div class="card-title" style="display:flex;align-items:center;gap:12px;">
                        <span style="width:40px;height:40px;background:#9945ff;border-radius:10px;display:flex;align-items:center;justify-content:center;font-size:20px;">ğŸŸ£</span>
                        <div>
                            <div>Solana (Helius)</div>
                            <div style="font-size:12px;color:var(--text-secondary);font-weight:normal;">API Veloce â€¢ Token SPL â€¢ NFT</div>
                        </div>
                    </div>
                    <span class="api-status" id="heliusStatus">OFF</span>
                </div>
                <div class="input-row" style="margin-top:16px;">
                    <div class="input-group" style="flex:3;">
                        <label>API Key <a href="https://www.helius.dev/" target="_blank" style="color:var(--accent);font-size:11px;margin-left:8px;">â†’ Ottieni gratis</a></label>
                        <input type="password" id="heliusKey" placeholder="xxx-xxx-xxx..." autocomplete="off">
                    </div>
                    <div class="input-group" style="flex:0;align-self:flex-end;">
                        <button class="btn btn-primary" onclick="saveHeliusKey()">ğŸ’¾ Salva</button>
                    </div>
                </div>
                <div style="margin-top:12px;padding:12px;background:var(--bg-primary);border-radius:8px;font-size:12px;">
                    <strong>Endpoint:</strong> api.helius.xyz<br>
                    <strong>Limite free:</strong> 30 req/sec, 500.000/mese
                </div>
            </div>
            
            <!-- BINANCE API STORICO -->
            <!-- API STATUS SUMMARY -->
            <div class="card">
                <div class="card-header"><div class="card-title">ğŸ“Š Riepilogo API</div></div>
                <div id="apiSummary" style="display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:12px;"></div>
            </div>
        </div>
        
        <!-- NFT -->
        <div class="main-content" id="nftView" style="display:none;">
            <div class="header"><h1>ğŸ–¼ï¸ NFT Portfolio</h1><div class="header-actions"><button class="btn btn-primary" onclick="scanAllNFTs()">ğŸ” Scansiona NFT</button></div></div>
            
            <div class="card" style="margin-bottom:20px;">
                <p style="color:var(--text-secondary);font-size:14px;line-height:1.6;">
                    Visualizza i tuoi <strong>NFT</strong> su tutte le chain EVM e Solana.<br>
                    Puoi inserire il <strong>prezzo di acquisto</strong> per calcolare guadagni/perdite.
                </p>
            </div>
            
            <!-- RIEPILOGO NFT -->
            <div class="card" style="margin-bottom:20px;">
                <div class="card-header"><div class="card-title">ğŸ“Š Riepilogo</div></div>
                <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:16px;">
                    <div style="background:var(--bg-primary);padding:16px;border-radius:8px;text-align:center;">
                        <div style="font-size:12px;color:var(--text-secondary);">NFT Totali</div>
                        <div id="nftTotalCount" style="font-size:24px;font-weight:700;color:var(--accent);">0</div>
                    </div>
                    <div style="background:var(--bg-primary);padding:16px;border-radius:8px;text-align:center;">
                        <div style="font-size:12px;color:var(--text-secondary);">Valore Stimato</div>
                        <div id="nftTotalValue" style="font-size:24px;font-weight:700;color:var(--green);">â‚¬0</div>
                    </div>
                    <div style="background:var(--bg-primary);padding:16px;border-radius:8px;text-align:center;">
                        <div style="font-size:12px;color:var(--text-secondary);">Costo Acquisto</div>
                        <div id="nftTotalCost" style="font-size:24px;font-weight:700;color:var(--text-secondary);">â‚¬0</div>
                    </div>
                    <div style="background:var(--bg-primary);padding:16px;border-radius:8px;text-align:center;">
                        <div style="font-size:12px;color:var(--text-secondary);">P/L</div>
                        <div id="nftTotalPL" style="font-size:24px;font-weight:700;">â‚¬0</div>
                    </div>
                </div>
            </div>
            
            <!-- LISTA NFT -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">ğŸ–¼ï¸ I Tuoi NFT</div>
                    <div style="display:flex;gap:8px;">
                        <select id="nftChainFilter" onchange="filterNFTsByChain()" style="background:var(--bg-primary);color:var(--text-primary);border:none;padding:8px 12px;border-radius:6px;">
                            <option value="all">Tutte le chain</option>
                            <option value="eth">Ethereum</option>
                            <option value="polygon">Polygon</option>
                            <option value="bsc">BSC</option>
                            <option value="arbitrum">Arbitrum</option>
                            <option value="base">Base</option>
                            <option value="solana">Solana</option>
                        </select>
                    </div>
                </div>
                <div id="nftGrid" style="display:grid;grid-template-columns:repeat(auto-fill,minmax(280px,1fr));gap:16px;padding:16px 0;">
                    <div style="color:var(--text-secondary);text-align:center;padding:40px;grid-column:1/-1;">
                        Nessun NFT trovato. Clicca "ğŸ” Scansiona NFT" per cercare i tuoi NFT.
                    </div>
                </div>
            </div>
        </div>
        
        <!-- EXCHANGES -->
        <div class="main-content" id="exchangesView" style="display:none;">
            <div class="header"><h1>ğŸ¦ Exchanges</h1><div class="header-actions"><button class="btn btn-secondary" onclick="clearAllExchangeData()" style="margin-right:8px;">ğŸ—‘ï¸ Reset All</button><button class="btn btn-primary" onclick="recalculateAllExchanges()">ğŸ§® Ricalcola</button></div></div>
            
            <!-- TOTALE EXCHANGES -->
            <div class="card" style="margin-bottom:20px;background:linear-gradient(135deg,rgba(243,186,47,0.1),rgba(0,230,118,0.1));">
                <div class="card-header"><div class="card-title">ğŸ“Š Totale Exchange per Anno (31/12)</div></div>
                <div id="exchangeTotalsGrid" style="display:grid;grid-template-columns:repeat(6,1fr);gap:12px;margin-top:12px;">
                    <div style="background:var(--bg-primary);border-radius:8px;padding:16px;text-align:center;">
                        <div style="font-size:12px;color:var(--text-secondary);">2021</div>
                        <div id="exchTotal2021" style="font-size:18px;font-weight:700;color:var(--green);">â‚¬0</div>
                    </div>
                    <div style="background:var(--bg-primary);border-radius:8px;padding:16px;text-align:center;">
                        <div style="font-size:12px;color:var(--text-secondary);">2022</div>
                        <div id="exchTotal2022" style="font-size:18px;font-weight:700;color:var(--green);">â‚¬0</div>
                    </div>
                    <div style="background:var(--bg-primary);border-radius:8px;padding:16px;text-align:center;">
                        <div style="font-size:12px;color:var(--text-secondary);">2023</div>
                        <div id="exchTotal2023" style="font-size:18px;font-weight:700;color:var(--green);">â‚¬0</div>
                    </div>
                    <div style="background:var(--bg-primary);border-radius:8px;padding:16px;text-align:center;">
                        <div style="font-size:12px;color:var(--text-secondary);">2024</div>
                        <div id="exchTotal2024" style="font-size:18px;font-weight:700;color:var(--green);">â‚¬0</div>
                    </div>
                    <div style="background:var(--bg-primary);border-radius:8px;padding:16px;text-align:center;">
                        <div style="font-size:12px;color:var(--text-secondary);">2025</div>
                        <div id="exchTotal2025" style="font-size:18px;font-weight:700;color:var(--green);">â‚¬0</div>
                    </div>
                    <div style="background:var(--bg-primary);border-radius:8px;padding:16px;text-align:center;">
                        <div style="font-size:12px;color:var(--text-secondary);">2026</div>
                        <div id="exchTotal2026" style="font-size:18px;font-weight:700;color:var(--green);">â‚¬0</div>
                    </div>
                </div>
            </div>
            
            <!-- EXCHANGE GRID - Card compatte -->
            <div id="exchangeGrid" style="display:grid;grid-template-columns:repeat(auto-fill,minmax(200px,1fr));gap:16px;"></div>
        </div>
        
        <!-- EXCHANGE DETAIL VIEW -->
        <div class="main-content" id="exchangeDetailView" style="display:none;">
            <div class="header">
                <div style="display:flex;align-items:center;gap:16px;">
                    <button class="btn btn-secondary" onclick="showView('exchanges')" style="padding:8px 12px;">â† Indietro</button>
                    <h1 id="exchDetailName">Exchange</h1>
                </div>
                <div class="header-actions">
                    <button class="btn btn-secondary" onclick="clearCurrentExchangeData()" style="margin-right:8px;">ğŸ—‘ï¸ Reset</button>
                    <button class="btn btn-primary" id="exchDetailScanBtn" onclick="scanCurrentExchange()">ğŸ”„ Aggiorna</button>
                </div>
            </div>
            
            <!-- Info Exchange -->
            <div class="card" style="margin-bottom:20px;">
                <div style="display:flex;align-items:center;gap:16px;">
                    <div id="exchDetailLogo" style="width:64px;height:64px;border-radius:16px;display:flex;align-items:center;justify-content:center;font-size:28px;"></div>
                    <div style="flex:1;">
                        <div id="exchDetailStatus" style="font-size:13px;color:var(--text-secondary);"></div>
                        <div id="exchDetailLastUpdate" style="font-size:12px;color:var(--text-secondary);margin-top:6px;"></div>
                    </div>
                </div>
            </div>
            
            <!-- Totali per Anno -->
            <div class="card" style="margin-bottom:20px;">
                <div class="card-header"><div class="card-title">ğŸ’° Valore al 31/12</div></div>
                <div id="exchDetailYearGrid" style="display:grid;grid-template-columns:repeat(6,1fr);gap:12px;margin-top:12px;"></div>
            </div>
            
            <!-- Azioni -->
            <div class="card" style="margin-bottom:20px;">
                <div class="card-header"><div class="card-title">âš¡ Azioni</div></div>
                <div style="display:flex;flex-wrap:wrap;gap:12px;margin-top:12px;">
                    <!-- Exchange API (dinamico) -->
                    <div id="exchDetailApiSection" style="display:none;">
                        <button id="exchDetailApiBtn" class="btn" onclick="openExchangeApiModal()" style="background:#f3ba2f;color:#000;">
                            ğŸ”— Connetti API
                        </button>
                        <span id="exchDetailServerStatus" style="margin-left:8px;font-size:12px;"></span>
                    </div>
                    
                    <!-- CSV Import -->
                    <div>
                        <input type="file" id="exchDetailFileInput" accept=".csv,.zip" multiple style="display:none;" onchange="handleExchDetailFileSelect(event)">
                        <button class="btn btn-secondary" onclick="document.getElementById('exchDetailFileInput').click()">
                            ğŸ“ Importa CSV/ZIP
                        </button>
                    </div>
                    
                    <!-- Dropzone -->
                    <div id="exchDetailDropzone" 
                         style="flex:1;min-width:200px;border:2px dashed var(--border);border-radius:8px;padding:20px;text-align:center;color:var(--text-secondary);cursor:pointer;"
                         ondrop="handleExchDetailDrop(event)" 
                         ondragover="event.preventDefault();this.style.borderColor='var(--accent)';this.style.background='rgba(108,92,231,0.1)'"
                         ondragleave="this.style.borderColor='var(--border)';this.style.background='transparent'"
                         onclick="document.getElementById('exchDetailFileInput').click()">
                        ğŸ“¥ Trascina CSV o ZIP qui
                    </div>
                </div>
                
                <!-- Progress -->
                <div id="exchDetailProgress" style="display:none;margin-top:16px;">
                    <div style="background:var(--bg-primary);border-radius:4px;height:8px;overflow:hidden;">
                        <div id="exchDetailProgressBar" style="background:var(--accent);height:100%;width:0%;transition:width 0.3s;"></div>
                    </div>
                    <div id="exchDetailProgressText" style="font-size:12px;color:var(--text-secondary);margin-top:8px;text-align:center;"></div>
                </div>
            </div>
            
            <!-- Saldi Reali (per Binance) -->
            <div id="exchDetailBalancesSection" class="card" style="margin-bottom:20px;display:none;">
                <div class="card-header">
                    <div class="card-title">ğŸ’ Saldi Reali</div>
                    <button class="btn btn-secondary" onclick="showAllExchBalances()" style="padding:6px 12px;font-size:12px;">ğŸ‘ï¸ Vedi tutti</button>
                </div>
                <div id="exchDetailBalances" style="display:grid;grid-template-columns:repeat(auto-fill,minmax(150px,1fr));gap:12px;margin-top:12px;"></div>
            </div>
            
            <!-- Transazioni -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">ğŸ“œ Transazioni (<span id="exchDetailTxCount">0</span>)</div>
                    <div style="display:flex;gap:8px;align-items:center;">
                        <select id="exchDetailTxYear" onchange="filterExchDetailTx()" style="padding:6px 10px;background:var(--bg-primary);border:1px solid var(--border);border-radius:6px;color:var(--text-primary);font-size:12px;">
                            <option value="">Tutti gli anni</option>
                            <option value="2021">2021</option>
                            <option value="2022">2022</option>
                            <option value="2023">2023</option>
                            <option value="2024">2024</option>
                            <option value="2025">2025</option>
                            <option value="2026">2026</option>
                        </select>
                        <select id="exchDetailTxType" onchange="filterExchDetailTx()" style="padding:6px 10px;background:var(--bg-primary);border:1px solid var(--border);border-radius:6px;color:var(--text-primary);font-size:12px;">
                            <option value="">Tutti i tipi</option>
                            <option value="buy">ğŸ›’ Buy</option>
                            <option value="sell">ğŸ’° Sell</option>
                            <option value="deposit">ğŸ“¥ Deposit</option>
                            <option value="withdrawal">ğŸ“¤ Withdrawal</option>
                            <option value="trade">ğŸ“Š Trade</option>
                            <option value="convert">ğŸ”„ Convert</option>
                            <option value="staking">ğŸ¥© Staking</option>
                            <option value="interest">ğŸ’° Interest</option>
                        </select>
                        <button class="btn btn-secondary" onclick="exportExchDetailTx()" style="padding:6px 12px;font-size:12px;">ğŸ“¥ CSV</button>
                    </div>
                </div>
                <div style="overflow-x:auto;margin-top:12px;">
                    <table class="tx-table">
                        <thead>
                            <tr>
                                <th style="text-align:left;">Data</th>
                                <th style="text-align:left;">Tipo</th>
                                <th style="text-align:center;">Coin</th>
                                <th style="text-align:right;">Importo</th>
                                <th style="text-align:right;">Valore â‚¬</th>
                            </tr>
                        </thead>
                        <tbody id="exchDetailTxTable">
                            <tr><td colspan="5" style="text-align:center;padding:40px;color:var(--text-secondary);">
                                Importa transazioni con CSV o API
                            </td></tr>
                        </tbody>
                    </table>
                </div>
                <div id="exchDetailTxPagination" style="display:flex;justify-content:center;gap:8px;margin-top:16px;"></div>
            </div>
        </div>
        
        <!-- RICONCILIAZIONE VIEW -->
        <div class="main-content" id="reconcileView" style="display:none;">
            <div class="header">
                <h1>ğŸ”— Riconciliazione Exchange â†” Wallet</h1>
            </div>
        
        <div class="card" style="margin-bottom:20px;">
            <p style="color:var(--text-secondary);font-size:14px;line-height:1.6;margin-bottom:16px;">
                Questo strumento <strong>collega le transazioni</strong> tra Exchange e Wallet per evitare doppi conteggi.<br>
                <strong>Esempio:</strong> Un prelievo da Binance di 0.5 ETH viene collegato al deposito di 0.5 ETH sul tuo wallet.
            </p>
            <p style="color:var(--accent);font-size:13px;margin-bottom:16px;">
                ğŸ’¡ <strong>I CSV caricati nella sezione "Exchanges" vengono letti automaticamente!</strong> Non serve ricaricarli qui.
            </p>
            
            <div style="display:flex;gap:12px;flex-wrap:wrap;">
                <button class="btn btn-primary" onclick="loadReconciliationData()">ğŸ“Š Carica Dati (Exchange + Wallet)</button>
                <button class="btn btn-secondary" onclick="runReconciliation()">ğŸ”— Esegui Riconciliazione</button>
                <button class="btn btn-secondary" onclick="exportReconciliationReport()">ğŸ“¥ Esporta Report</button>
                <button class="btn btn-secondary" onclick="resetReconciliationData()" style="background:var(--red);">ğŸ—‘ï¸ Reset</button>
            </div>
        </div>
        
        <!-- RIEPILOGO -->
        <div class="card" style="margin-bottom:20px;">
            <div class="card-header"><div class="card-title">ğŸ“Š Riepilogo</div></div>
            <div id="reconcileSummary" style="display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:16px;">
                <div style="background:var(--bg-primary);padding:16px;border-radius:8px;text-align:center;">
                    <div style="font-size:12px;color:var(--text-secondary);">Transazioni Exchange</div>
                    <div id="reconcileExchCount" style="font-size:24px;font-weight:700;color:#f3ba2f;">0</div>
                </div>
                <div style="background:var(--bg-primary);padding:16px;border-radius:8px;text-align:center;">
                    <div style="font-size:12px;color:var(--text-secondary);">Transazioni Wallet</div>
                    <div id="reconcileWalletCount" style="font-size:24px;font-weight:700;color:var(--accent);">0</div>
                </div>
                <div style="background:var(--bg-primary);padding:16px;border-radius:8px;text-align:center;">
                    <div style="font-size:12px;color:var(--text-secondary);">Match Trovati</div>
                    <div id="reconcileMatchCount" style="font-size:24px;font-weight:700;color:var(--green);">0</div>
                </div>
                <div style="background:var(--bg-primary);padding:16px;border-radius:8px;text-align:center;">
                    <div style="font-size:12px;color:var(--text-secondary);">Non Riconciliati</div>
                    <div id="reconcileUnmatchedCount" style="font-size:24px;font-weight:700;color:var(--red);">0</div>
                </div>
            </div>
        </div>
        
        <!-- FILTRI PER ANNO -->
        <div class="card" style="margin-bottom:20px;">
            <div class="card-header"><div class="card-title">ğŸ“… Filtra per Anno</div></div>
            <div style="display:flex;gap:8px;flex-wrap:wrap;">
                <button class="btn btn-secondary reconcile-year-btn active" data-year="all" onclick="filterReconcileYear('all')">Tutti</button>
                <button class="btn btn-secondary reconcile-year-btn" data-year="2021" onclick="filterReconcileYear('2021')">2021</button>
                <button class="btn btn-secondary reconcile-year-btn" data-year="2022" onclick="filterReconcileYear('2022')">2022</button>
                <button class="btn btn-secondary reconcile-year-btn" data-year="2023" onclick="filterReconcileYear('2023')">2023</button>
                <button class="btn btn-secondary reconcile-year-btn" data-year="2024" onclick="filterReconcileYear('2024')">2024</button>
                <button class="btn btn-secondary reconcile-year-btn" data-year="2025" onclick="filterReconcileYear('2025')">2025</button>
            </div>
        </div>
        
        <!-- MATCH TROVATI -->
        <div class="card" style="margin-bottom:20px;">
            <div class="card-header">
                <div class="card-title">âœ… Match Trovati</div>
                <span id="matchCountBadge" style="background:var(--green);color:#000;padding:4px 12px;border-radius:12px;font-size:12px;font-weight:600;">0</span>
            </div>
            <div id="reconcileMatches" style="max-height:400px;overflow-y:auto;">
                <div style="color:var(--text-secondary);text-align:center;padding:40px;">Clicca "Carica Dati" per iniziare</div>
            </div>
        </div>
        
        <!-- NON RICONCILIATI -->
        <div class="card">
            <div class="card-header">
                <div class="card-title">âš ï¸ Transazioni Non Riconciliate</div>
                <span id="unmatchedCountBadge" style="background:var(--red);color:#fff;padding:4px 12px;border-radius:12px;font-size:12px;font-weight:600;">0</span>
            </div>
            <div style="display:grid;grid-template-columns:1fr 1fr;gap:16px;">
                <div>
                    <h4 style="margin-bottom:12px;color:#f3ba2f;">ğŸ¦ Exchange (senza match wallet)</h4>
                    <div id="unmatchedExchange" style="max-height:300px;overflow-y:auto;font-size:12px;">
                        <div style="color:var(--text-secondary);text-align:center;padding:20px;">-</div>
                    </div>
                </div>
                <div>
                    <h4 style="margin-bottom:12px;color:var(--accent);">ğŸ‘› Wallet (senza match exchange)</h4>
                    <div id="unmatchedWallet" style="max-height:300px;overflow-y:auto;font-size:12px;">
                        <div style="color:var(--text-secondary);text-align:center;padding:20px;">-</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    </div>
    
    <!-- Hidden elements per evitare errori JS -->
    <div style="display:none;">
        <input id="binanceApiKey"><input id="binanceSecretKey">
        <span id="binanceServerStatus"></span><span id="binanceSyncStatus"></span>
        <span id="binanceSpotTotal"></span><span id="binanceEarnTotal"></span>
        <span id="binanceStakingTotal"></span><span id="binanceTotalValue"></span>
        <span id="binanceLastUpdate"></span><div id="binanceBalances"></div>
        <div id="binanceTokensList"></div>
    </div>

    <script>
        // ==================== CONFIG ====================
        let EUR_USD = 0.849;
        let allocationChart = null;
        let lastScanResults = [];
        let walletResults = {}; // { walletAddress: { name: 'Main', results: [...], scannedAt: timestamp } }
        let walletTransactions = {}; // { walletAddress: { nativeTx: [], tokenTx: [], lastDownload: timestamp } }
        
        const CHAINS = {
            eth: { id: 1, name: 'Ethereum', symbol: 'ETH', explorer: 'etherscan.io', color: '#627eea', dex: 'ethereum', api: 'etherscan' },
            bsc: { id: 56, name: 'BSC', symbol: 'BNB', explorer: 'bscscan.com', color: '#f3ba2f', dex: 'bsc', api: 'etherscan' },
            polygon: { id: 137, name: 'Polygon', symbol: 'MATIC', explorer: 'polygonscan.com', color: '#8247e5', dex: 'polygon', api: 'etherscan' },
            arbitrum: { id: 42161, name: 'Arbitrum', symbol: 'ETH', explorer: 'arbiscan.io', color: '#28a0f0', dex: 'arbitrum', api: 'etherscan' },
            optimism: { id: 10, name: 'Optimism', symbol: 'ETH', explorer: 'optimistic.etherscan.io', color: '#ff0420', dex: 'optimism', api: 'etherscan' },
            base: { id: 8453, name: 'Base', symbol: 'ETH', explorer: 'basescan.org', color: '#0052ff', dex: 'base', api: 'etherscan' },
            cronos: { id: 25, name: 'Cronos', symbol: 'CRO', explorer: 'cronoscan.com', color: '#002D74', dex: 'cronos', api: 'etherscan' },
            pulse: { id: 369, name: 'PulseChain', symbol: 'PLS', explorer: 'scan.pulsechain.com', color: '#00ff00', dex: 'pulsechain', api: 'pulsescan' },
            solana: { id: 0, name: 'Solana', symbol: 'SOL', explorer: 'solscan.io', color: '#9945ff', dex: 'solana', api: 'solana' },
        };
        
        const NATIVE_PRICES = { ETH: 0, BNB: 0, MATIC: 0, PLS: 0, SOL: 0, CRO: 0 };
        
        const TOKEN_ICONS = {
            'ETH': 'https://assets.coingecko.com/coins/images/279/small/ethereum.png',
            'BNB': 'https://assets.coingecko.com/coins/images/825/small/bnb-icon2_2x.png',
            'MATIC': 'https://assets.coingecko.com/coins/images/4713/small/matic-token-icon.png',
            'SHIB': 'https://assets.coingecko.com/coins/images/11939/small/shiba.png',
            'BONE': 'https://assets.coingecko.com/coins/images/16916/small/bone_icon.png',
            'USDT': 'https://assets.coingecko.com/coins/images/325/small/tether.png',
            'USDC': 'https://assets.coingecko.com/coins/images/6319/small/usdc.png',
            'PLS': 'https://tokens.app.pulsex.com/images/tokens/0xA1077a294dDE1B09bB078844df40758a5D0f9a27.png',
            'SOL': 'https://assets.coingecko.com/coins/images/4128/small/solana.png',
            'CRO': 'https://assets.coingecko.com/coins/images/7310/small/cro_token_logo.png',
            'HEX': 'https://tokens.app.pulsex.com/images/tokens/0x2b591e99afE9f32eAA6214f7B7629768c40Eeb39.png',
            'PLSX': 'https://tokens.app.pulsex.com/images/tokens/0x95B303987A60C71504D99Aa1b13B4DA07b0790ab.png',
            'INC': 'https://tokens.app.pulsex.com/images/tokens/0x2fa878Ab3F87CC1C9737Fc071108F904c0B0C95d.png',
            'DAI': 'https://assets.coingecko.com/coins/images/9956/small/dai-multi-collateral-mcd.png',
            'WETH': 'https://assets.coingecko.com/coins/images/2518/small/weth.png',
        };
        
        const HISTORICAL_PRICES = {
            'ethereum': { 2020: 737, 2021: 3769, 2022: 1196, 2023: 2282, 2024: 3337, 2025: 2950, 2026: 3200 },
            'shiba-inu': { 2020: 0, 2021: 0.0000338, 2022: 0.0000081, 2023: 0.0000091, 2024: 0.0000218, 2025: 0.000008, 2026: 0.00001 },
            'bone-shibaswap': { 2020: 0, 2021: 1.71, 2022: 0.93, 2023: 0.47, 2024: 0.42, 2025: 0.08, 2026: 0.10 },
            'binancecoin': { 2020: 37, 2021: 526, 2022: 244, 2023: 311, 2024: 707, 2025: 680, 2026: 700 },
            'matic-network': { 2020: 0.02, 2021: 2.47, 2022: 0.75, 2023: 0.99, 2024: 0.46, 2025: 0.35, 2026: 0.40 },
            'pulsechain': { 2020: 0, 2021: 0, 2022: 0, 2023: 0.00005, 2024: 0.00003, 2025: 0.000014, 2026: 0.00002 },
            'hex': { 2020: 0.001, 2021: 0.15, 2022: 0.04, 2023: 0.006, 2024: 0.004, 2025: 0.003, 2026: 0.004 },
            'pulsex': { 2020: 0, 2021: 0, 2022: 0, 2023: 0.0001, 2024: 0.00005, 2025: 0.00001, 2026: 0.00002 },
            'tether': { 2020: 1, 2021: 1, 2022: 1, 2023: 1, 2024: 1, 2025: 1, 2026: 1 },
            'usd-coin': { 2020: 1, 2021: 1, 2022: 1, 2023: 1, 2024: 1, 2025: 1, 2026: 1 },
            'solana': { 2020: 1.5, 2021: 170, 2022: 9.5, 2023: 100, 2024: 190, 2025: 150, 2026: 180 },
            'bitcoin': { 2020: 29000, 2021: 47700, 2022: 16500, 2023: 42300, 2024: 93400, 2025: 100000, 2026: 105000 },
            'ripple': { 2020: 0.22, 2021: 0.83, 2022: 0.35, 2023: 0.62, 2024: 2.08, 2025: 2.30, 2026: 2.50 },
            'cardano': { 2020: 0.18, 2021: 1.35, 2022: 0.25, 2023: 0.59, 2024: 0.88, 2025: 0.90, 2026: 1.00 },
            'dogecoin': { 2020: 0.005, 2021: 0.17, 2022: 0.07, 2023: 0.09, 2024: 0.32, 2025: 0.35, 2026: 0.40 },
            'polkadot': { 2020: 9.5, 2021: 27.8, 2022: 4.3, 2023: 7.9, 2024: 6.9, 2025: 7.0, 2026: 8.0 },
            'chainlink': { 2020: 11.5, 2021: 19.3, 2022: 5.7, 2023: 15.1, 2024: 14.8, 2025: 15.0, 2026: 16.0 },
            'avalanche-2': { 2020: 3.5, 2021: 109, 2022: 11.3, 2023: 40.5, 2024: 38.6, 2025: 40.0, 2026: 45.0 },
            // Aggiunti per Crypto.com e Cosmos
            'cosmos': { 2020: 5.0, 2021: 44, 2022: 9.3, 2023: 10.5, 2024: 6.7, 2025: 7.0, 2026: 8.0 },
            'crypto-com-chain': { 2020: 0.06, 2021: 0.60, 2022: 0.057, 2023: 0.073, 2024: 0.12, 2025: 0.10, 2026: 0.12 },
            'terra-luna': { 2020: 0.64, 2021: 93, 2022: 0.00017, 2023: 0.00015, 2024: 0.00008, 2025: 0.00004, 2026: 0.00004 },
            'osmosis': { 2020: 0, 2021: 10.5, 2022: 0.8, 2023: 0.5, 2024: 0.4, 2025: 0.35, 2026: 0.40 },
            'litecoin': { 2020: 125, 2021: 148, 2022: 70, 2023: 73, 2024: 103, 2025: 100, 2026: 110 },
            'uniswap': { 2020: 3.5, 2021: 17.5, 2022: 5.2, 2023: 6.3, 2024: 13.5, 2025: 14.0, 2026: 15.0 },
            'aave': { 2020: 89, 2021: 264, 2022: 51, 2023: 99, 2024: 330, 2025: 350, 2026: 370 },
        };
        const YEAR_END_PRICES = HISTORICAL_PRICES; // Alias
        
        const SYMBOL_TO_CG = { 
            'ETH': 'ethereum', 'BNB': 'binancecoin', 'MATIC': 'matic-network', 
            'SHIB': 'shiba-inu', 'BONE': 'bone-shibaswap', 
            'USDT': 'tether', 'USDC': 'usd-coin',
            'PLS': 'pulsechain', 'HEX': 'hex', 'PLSX': 'pulsex',
            'SOL': 'solana', 'BTC': 'bitcoin', 'XRP': 'ripple',
            'ADA': 'cardano', 'DOGE': 'dogecoin', 'DOT': 'polkadot',
            'LINK': 'chainlink', 'AVAX': 'avalanche-2',
            'BUSD': 'tether', 'FDUSD': 'tether', 'DAI': 'tether',
            // Aggiunti
            'ATOM': 'cosmos', 'CRO': 'crypto-com-chain', 'LUNC': 'terra-luna', 'LUNA': 'terra-luna',
            'OSMO': 'osmosis', 'LTC': 'litecoin', 'UNI': 'uniswap', 'AAVE': 'aave',
            'EUR': 'eur', 'USD': 'usd',
        };
        
        let tokenBlacklist = JSON.parse(localStorage.getItem('cryptofolio_blacklist') || '[]');
        let blacklistNames = JSON.parse(localStorage.getItem('cryptofolio_blacklist_names') || '{}');
        let selectedChains = JSON.parse(localStorage.getItem('cryptofolio_chains') || '["eth","bsc"]');
        let savedWallets = JSON.parse(localStorage.getItem('cryptofolio_wallets') || '[]');
        let apiKeys = JSON.parse(localStorage.getItem('cryptofolio_apikeys') || '{}');
        let taxReportData = null; // Cached tax report results
        let saveTimeout = null;
        
        // Binance
        const BINANCE_SERVER_URL = 'http://localhost:3457';
        let binanceData = { balances: { spot: [], earn: [], staking: [] }, totals: { spot: 0, earn: 0, staking: 0 }, lastUpdate: null };
        
        // Exchange values per Tax Report (31/12 di ogni anno)
        let exchangeValues = { 2021: 0, 2022: 0, 2023: 0, 2024: 0, 2025: 0, 2026: 0 };
        
        // Multi-API Moralis (cascata)
        let moralisKeys = []; // Array di API keys
        let currentMoralisKeyIndex = 0;
        let moralisKeyFailures = {}; // Traccia fallimenti per key
        
        // NFT data
        let nftData = []; // Array di NFT: { tokenId, name, collection, image, chain, contract, floorPrice, purchasePrice, wallet }
        let nftPurchasePrices = {}; // { contract_tokenId: purchasePrice } - prezzi di acquisto manuali
        
        // Exchange data from CSV imports
        let exchangeData = {}; // { binance: { transactions: [], balances: {2021: {BTC: 0.5, ...}}, totals: {2021: 1234, ...} }, ... }
        
        // Lista exchange supportati
        const EXCHANGE_LIST = [
            { id: 'binance', name: 'Binance', color: '#f3ba2f', icon: 'B', logo: 'https://assets.coingecko.com/markets/images/52/small/binance.jpg', hasApi: true },
            { id: 'bitget', name: 'Bitget', color: '#00f0ff', icon: 'Bg', logo: 'https://assets.coingecko.com/markets/images/540/small/bitget.jpg', hasApi: true },
            { id: 'bitpanda', name: 'Bitpanda', color: '#08b289', icon: 'Bp', logo: 'https://assets.coingecko.com/markets/images/237/small/bitpanda.jpg', hasApi: true },
            { id: 'bybit', name: 'Bybit', color: '#f7a600', icon: 'By', logo: 'https://assets.coingecko.com/markets/images/698/small/bybit_spot.png' },
            { id: 'bybit_eu', name: 'Bybit EU', color: '#f7a600', icon: 'BE', logo: 'https://assets.coingecko.com/markets/images/698/small/bybit_spot.png' },
            { id: 'cake', name: 'Cake DeFi', color: '#00d395', icon: 'ğŸ°', logo: null },
            { id: 'coinbase', name: 'Coinbase', color: '#0052ff', icon: 'Cb', logo: 'https://assets.coingecko.com/markets/images/23/small/Coinbase_Coin_Primary.png' },
            { id: 'cosmos', name: 'Cosmos', color: '#2e3148', icon: 'âš›ï¸', logo: 'https://assets.coingecko.com/coins/images/1481/small/cosmos_hub.png' },
            { id: 'cryptocom_app', name: 'Crypto.com App', color: '#002d74', icon: 'Ca', logo: 'https://assets.coingecko.com/markets/images/589/small/crypto_com.jpg' },
            { id: 'cryptocom_exchange', name: 'Crypto.com Exchange', color: '#002d74', icon: 'Ce', logo: 'https://assets.coingecko.com/markets/images/589/small/crypto_com.jpg' },
            { id: 'gateio', name: 'Gate.io', color: '#17e6a1', icon: 'G', logo: 'https://assets.coingecko.com/markets/images/60/small/gate_io.jpg' },
            { id: 'kraken', name: 'Kraken', color: '#5741d9', icon: 'Kr', logo: 'https://assets.coingecko.com/markets/images/29/small/kraken.jpg' },
            { id: 'kucoin', name: 'KuCoin', color: '#23af91', icon: 'Ku', logo: 'https://assets.coingecko.com/markets/images/61/small/kucoin.jpg' },
            { id: 'manta', name: 'Manta Pacific', color: '#1fc7d4', icon: 'ğŸ™', logo: null },
            { id: 'mexc', name: 'MEXC', color: '#00b897', icon: 'Mx', logo: 'https://assets.coingecko.com/markets/images/409/small/MEXC_logo_square.jpeg' },
            { id: 'nexo', name: 'Nexo', color: '#1a4bff', icon: 'Nx', logo: 'https://assets.coingecko.com/coins/images/3695/small/nexo.png' },
            { id: 'okx', name: 'OKX', color: '#000000', icon: 'OK', logo: 'https://assets.coingecko.com/markets/images/96/small/WeChat_Image_20220117220452.png' },
            { id: 'osmo', name: 'Osmosis', color: '#5e12a0', icon: 'ğŸ§ª', logo: 'https://assets.coingecko.com/coins/images/16724/small/osmo.png' },
            { id: 'pionex', name: 'Pionex', color: '#c8a02c', icon: 'Px', logo: 'https://assets.coingecko.com/markets/images/532/small/pionex.png' },
            { id: 'pulsechain', name: 'PulseChain', color: '#00ff00', icon: 'ğŸ’š', logo: null },
            { id: 'revolut', name: 'Revolut', color: '#0666eb', icon: 'Rv', logo: null },
            { id: 'terra', name: 'Terra-LUNC', color: '#5493f7', icon: 'ğŸŒ™', logo: 'https://assets.coingecko.com/coins/images/8284/small/01_LussLogo_color.png' },
            { id: 'whitebit', name: 'WhiteBit', color: '#02c3bd', icon: 'Wb', logo: 'https://assets.coingecko.com/markets/images/418/small/logo_wb_small.png' },
            { id: 'youholders', name: 'YouHodler', color: '#6c5ce7', icon: 'Yh', logo: null },
            { id: 'youngplatform', name: 'Young Platform', color: '#ff6b35', icon: 'Yp', logo: 'https://assets.coingecko.com/markets/images/770/small/LOGO.jpg' },
        ];
        
        // Moralis chain mapping
        const MORALIS_CHAINS = {
            eth: '0x1',
            bsc: '0x38',
            polygon: '0x89',
            arbitrum: '0xa4b1',
            optimism: '0xa',
            base: '0x2105',
            cronos: '0x19'
        };
        
        // ==================== FIREBASE ====================
        function updateSyncStatus(status, color) {
            document.getElementById('syncStatus').textContent = status;
            document.getElementById('syncDot').style.background = color || 'var(--green)';
        }
        
        function saveToFirebase() {
            if (saveTimeout) clearTimeout(saveTimeout);
            saveTimeout = setTimeout(async () => {
                try {
                    updateSyncStatus('Salvataggio...', 'var(--accent)');
                    await db.collection('cryptofolio').doc('settings').set({
                        wallets: savedWallets,
                        blacklist: tokenBlacklist,
                        blacklistNames: blacklistNames,
                        selectedChains: selectedChains,
                        apiKeys: apiKeys,
                        walletResults: walletResults,
                        taxReportData: taxReportData,
                        exchangeValues: exchangeValues,
                        lastUpdate: new Date().toISOString()
                    });
                    updateSyncStatus('Salvato âœ“', 'var(--green)');
                    console.log('âœ… Firebase saved');
                } catch (e) {
                    updateSyncStatus('Errore sync', 'var(--red)');
                    console.error('Firebase save error:', e);
                }
            }, 1500);
        }
        
        async function loadFromFirebase() {
            try {
                updateSyncStatus('Caricamento...', 'var(--accent)');
                const doc = await db.collection('cryptofolio').doc('settings').get();
                
                if (doc.exists) {
                    const data = doc.data();
                    savedWallets = data.wallets || [];
                    tokenBlacklist = data.blacklist || [];
                    blacklistNames = data.blacklistNames || {};
                    selectedChains = data.selectedChains || ['eth', 'bsc'];
                    // Merge apiKeys: mantiene chiavi locali + aggiunge cloud
                    const cloudApiKeys = data.apiKeys || {};
                    apiKeys = { ...apiKeys, ...cloudApiKeys };
                    walletResults = data.walletResults || {};
                    taxReportData = data.taxReportData || null;
                    exchangeValues = data.exchangeValues || { 2021: 0, 2022: 0, 2023: 0, 2024: 0, 2025: 0, 2026: 0 };
                    
                    // Sync to localStorage
                    localStorage.setItem('cryptofolio_wallets', JSON.stringify(savedWallets));
                    localStorage.setItem('cryptofolio_blacklist', JSON.stringify(tokenBlacklist));
                    localStorage.setItem('cryptofolio_blacklist_names', JSON.stringify(blacklistNames));
                    localStorage.setItem('cryptofolio_chains', JSON.stringify(selectedChains));
                    localStorage.setItem('cryptofolio_apikeys', JSON.stringify(apiKeys));
                    
                    // Backward compatibility: load old apiKey into new structure
                    if (data.apiKey && !apiKeys.etherscan) {
                        apiKeys.etherscan = data.apiKey;
                        localStorage.setItem('cryptofolio_apikeys', JSON.stringify(apiKeys));
                    }
                    
                    // Update UI fields
                    if (apiKeys.etherscan) {
                        document.getElementById('apiKey').value = apiKeys.etherscan;
                    }
                    
                    console.log('âœ… Firebase loaded:', savedWallets.length, 'wallets,', Object.keys(walletResults).length, 'scan results', taxReportData ? ', tax report cached' : '');
                }
                
                updateSyncStatus('Connesso âœ“', 'var(--green)');
            } catch (e) {
                updateSyncStatus('Offline', 'var(--red)');
                console.error('Firebase load error:', e);
            }
        }
        
        async function forceSyncFirebase() {
            if (saveTimeout) clearTimeout(saveTimeout);
            try {
                updateSyncStatus('Sync...', 'var(--accent)');
                await db.collection('cryptofolio').doc('settings').set({
                    wallets: savedWallets,
                    blacklist: tokenBlacklist,
                    blacklistNames: blacklistNames,
                    selectedChains: selectedChains,
                    apiKeys: apiKeys,
                    walletResults: walletResults,
                    taxReportData: taxReportData,
                    lastUpdate: new Date().toISOString()
                });
                updateSyncStatus('Salvato âœ“', 'var(--green)');
                alert('âœ… Dati sincronizzati con Firebase!');
            } catch (e) {
                updateSyncStatus('Errore', 'var(--red)');
                alert('âŒ Errore sync: ' + e.message);
            }
        }
        
        // ==================== UTILS ====================
        function log(msg, type = '') { 
            const el = document.getElementById('statusLog'); 
            el.innerHTML += `<div class="log-line ${type}">[${new Date().toLocaleTimeString('it-IT')}] ${msg}</div>`; 
            el.scrollTop = el.scrollHeight; 
        }
        function formatNum(n, d = 2) { 
            if (n >= 1e9) return (n/1e9).toFixed(2)+'B'; 
            if (n >= 1e6) return (n/1e6).toFixed(2)+'M'; 
            if (n < 0.0001 && n > 0) return n.toExponential(2); 
            return n.toLocaleString('en-US', {minimumFractionDigits: d, maximumFractionDigits: d}); 
        }
        function formatEUR(n) { 
            if (n === null || n === undefined || isNaN(n)) return '0,00';
            return n.toLocaleString('it-IT', {minimumFractionDigits: 2, maximumFractionDigits: 2}); 
        }
        function isSpam(name, sym) { 
            const n = (name||'').toLowerCase(), s = (sym||'').toLowerCase(); 
            const spam = ['visit', 'claim', 'reward', '.com', '.org', '.io', '.xyz', 'airdrop', 'bonus', 'free', 'gift', 'http', '$', '#']; 
            for (const p of spam) if (n.includes(p) || s.includes(p)) return true; 
            return (name||'').length > 40; 
        }
        function isBlacklisted(c) { return tokenBlacklist.includes(c.toLowerCase()); }
        function hideToken(c, s) { 
            const lc = c.toLowerCase(); 
            if (!tokenBlacklist.includes(lc)) { 
                tokenBlacklist.push(lc); 
                blacklistNames[lc] = s; 
                localStorage.setItem('cryptofolio_blacklist', JSON.stringify(tokenBlacklist)); 
                localStorage.setItem('cryptofolio_blacklist_names', JSON.stringify(blacklistNames)); 
            }
            updateBlacklist(); 
            displayResults(lastScanResults);
            // Aggiorna anche wallet detail se aperto
            if (currentDetailWallet) displayWalletDetail();
            saveToFirebase();
        }
        function restoreToken(c) { 
            tokenBlacklist = tokenBlacklist.filter(x => x !== c.toLowerCase()); 
            delete blacklistNames[c.toLowerCase()]; 
            localStorage.setItem('cryptofolio_blacklist', JSON.stringify(tokenBlacklist)); 
            localStorage.setItem('cryptofolio_blacklist_names', JSON.stringify(blacklistNames)); 
            updateBlacklist(); 
            displayResults(lastScanResults);
            // Aggiorna anche wallet detail se aperto
            if (currentDetailWallet) displayWalletDetail();
            saveToFirebase();
        }
        function clearBlacklist() { 
            tokenBlacklist = []; blacklistNames = {}; 
            localStorage.removeItem('cryptofolio_blacklist'); 
            localStorage.removeItem('cryptofolio_blacklist_names'); 
            updateBlacklist(); 
            displayResults(lastScanResults);
            saveToFirebase();
        }
        function toggleBlacklist() { 
            const p = document.getElementById('blacklistPanel'); 
            p.style.display = p.style.display === 'none' ? 'block' : 'none'; 
        }
        function updateBlacklist() { 
            document.getElementById('blacklistCount').textContent = tokenBlacklist.length; 
            const c = document.getElementById('blacklistContent'); 
            if (tokenBlacklist.length === 0) { c.innerHTML = '<p style="color:var(--text-secondary);">Nessun token nascosto</p>'; return; } 
            let h = ''; 
            for (const x of tokenBlacklist) { 
                h += `<div class="blacklist-item"><span>${blacklistNames[x]||x.slice(0,10)}</span><button class="btn-restore" onclick="restoreToken('${x}')">â†©ï¸</button></div>`; 
            } 
            c.innerHTML = h; 
        }
        
        // ==================== UI ====================
        let currentDetailWallet = null;
        
        function showView(view) {
            document.getElementById('dashboardView').style.display = view === 'dashboard' ? 'block' : 'none';
            document.getElementById('walletsView').style.display = view === 'wallets' ? 'block' : 'none';
            document.getElementById('walletDetailView').style.display = view === 'walletDetail' ? 'block' : 'none';
            document.getElementById('nftView').style.display = view === 'nft' ? 'block' : 'none';
            document.getElementById('exchangesView').style.display = view === 'exchanges' ? 'block' : 'none';
            document.getElementById('exchangeDetailView').style.display = view === 'exchangeDetail' ? 'block' : 'none';
            document.getElementById('reconcileView').style.display = view === 'reconcile' ? 'block' : 'none';
            document.getElementById('taxView').style.display = view === 'tax' ? 'block' : 'none';
            document.getElementById('apiView').style.display = view === 'api' ? 'block' : 'none';
            document.querySelectorAll('.nav-item').forEach((e, i) => {
                e.classList.toggle('active', 
                    (view === 'dashboard' && i === 0) || 
                    (view === 'wallets' && i === 1) || 
                    (view === 'walletDetail' && i === 1) || 
                    (view === 'nft' && i === 2) ||
                    (view === 'exchanges' && i === 3) ||
                    (view === 'exchangeDetail' && i === 3) ||
                    (view === 'reconcile' && i === 4) ||
                    (view === 'tax' && i === 5) ||
                    (view === 'api' && i === 6)
                );
            });
            
            // Aggiorna dropdown tax e mostra dati salvati
            if (view === 'tax') {
                updateTaxWalletsList();
                loadExchangeValuesUI();
                if (taxReportData) {
                    renderTaxReport(taxReportData);
                }
            }
            
            // Carica dati riconciliazione da localStorage
            if (view === 'reconcile') {
                // Carica sempre da localStorage se non ci sono dati in memoria
                const hasData = reconcileData.exchangeTx.length > 0 || reconcileData.walletTx.length > 0 || reconcileData.matches.length > 0;
                if (!hasData) {
                    if (loadReconcileFromLocalStorage()) {
                        updateReconcileSummary();
                        renderReconcileData();
                    }
                } else {
                    // Aggiorna la UI con i dati esistenti
                    updateReconcileSummary();
                    renderReconcileData();
                }
            }
            
            // Aggiorna status API quando si apre
            if (view === 'api') {
                updateApiStatus();
            }
            
            // Inizializza griglia exchange quando si apre
            if (view === 'exchanges') {
                initExchangeGrid();
                updateExchangeTotals();
            }
        }
        
        function renderTaxReport(data) {
            if (!data || !data.grandTotals || !data.walletDetails) {
                console.error('Invalid tax report data');
                return;
            }
            
            const container = document.getElementById('taxReportContent');
            const detailCard = document.getElementById('taxDetailCard');
            const detailContent = document.getElementById('taxDetailContent');
            const years = [2021, 2022, 2023, 2024, 2025, 2026];
            
            // Calcola totali includendo exchange
            const combinedTotals = {};
            let hasExchange = false;
            for (const y of years) {
                const walletEur = data.grandTotals[y]?.eur || 0;
                const walletUsd = data.grandTotals[y]?.usd || 0;
                const exchEur = exchangeValues[y] || 0;
                const exchUsd = exchEur / EUR_USD;
                if (exchEur > 0) hasExchange = true;
                combinedTotals[y] = {
                    eur: walletEur + exchEur,
                    usd: walletUsd + exchUsd,
                    walletEur: walletEur,
                    exchangeEur: exchEur
                };
            }
            
            // Render summary cards
            let html = '<div style="display:grid;gap:12px;">';
            
            for (const y of years) {
                const t = combinedTotals[y];
                const above = (t.eur || 0) >= 15000;
                const bgColor = above ? 'rgba(255,82,82,0.1)' : 'var(--bg-primary)';
                const borderColor = above ? 'var(--red)' : 'var(--border)';
                
                html += '<div style="background:' + bgColor + ';border:1px solid ' + borderColor + ';border-radius:12px;padding:16px;display:grid;grid-template-columns:80px 1fr 1fr 1fr 120px;align-items:center;gap:16px;">';
                html += '<div style="text-align:center;"><div style="font-size:28px;font-weight:700;color:var(--text-primary);">' + y + '</div></div>';
                html += '<div style="text-align:center;"><div style="font-size:11px;color:var(--text-secondary);margin-bottom:4px;">ğŸ‘› WALLET</div>';
                html += '<div style="font-size:16px;font-weight:600;color:var(--green);">â‚¬' + formatEUR(t.walletEur || 0) + '</div></div>';
                html += '<div style="text-align:center;"><div style="font-size:11px;color:var(--text-secondary);margin-bottom:4px;">ğŸ¦ EXCHANGE</div>';
                html += '<div style="font-size:16px;font-weight:600;color:#f3ba2f;">â‚¬' + formatEUR(t.exchangeEur || 0) + '</div></div>';
                html += '<div style="text-align:center;"><div style="font-size:11px;color:var(--text-secondary);margin-bottom:4px;">ğŸ’° TOTALE</div>';
                html += '<div style="font-size:22px;font-weight:700;color:var(--green);">â‚¬' + formatEUR(t.eur || 0) + '</div></div>';
                html += '<div style="text-align:center;"><div style="font-size:11px;color:var(--text-secondary);margin-bottom:4px;">QUADRO RW</div>';
                if (above) {
                    html += '<div style="font-size:14px;font-weight:700;color:var(--red);background:rgba(255,82,82,0.2);padding:6px 12px;border-radius:8px;">âš ï¸ OBBLIGO</div>';
                } else {
                    html += '<div style="font-size:14px;font-weight:600;color:var(--green);background:rgba(0,230,118,0.1);padding:6px 12px;border-radius:8px;">âœ“ NO</div>';
                }
                html += '</div></div>';
            }
            html += '</div>';
            
            // Footer info
            html += '<div style="margin-top:20px;padding:16px;background:var(--bg-primary);border-radius:12px;">';
            html += '<div style="display:flex;flex-wrap:wrap;gap:16px;justify-content:center;align-items:center;font-size:13px;">';
            html += '<span>ğŸ“Š <strong>' + (data.walletCount || 0) + '</strong> wallet</span>';
            if (hasExchange) html += '<span style="color:var(--border);">|</span><span>ğŸ¦ <strong>Exchange inclusi</strong></span>';
            html += '<span style="color:var(--border);">|</span>';
            html += '<span>â›“ï¸ ' + (data.chainNames || 'N/A') + '</span>';
            html += '<span style="color:var(--border);">|</span>';
            html += '<span>âš ï¸ Soglia RW: <strong>â‚¬15.000</strong></span>';
            html += '<span style="color:var(--border);">|</span>';
            html += '<span style="color:var(--text-secondary);">ğŸ“… ' + new Date(data.calculatedAt || Date.now()).toLocaleString('it-IT') + '</span>';
            html += '</div>';
            
            // Transazioni per anno (se disponibili)
            const txByYear = countTransactionsByYear();
            const hasTx = Object.values(txByYear).some(v => v > 0);
            if (hasTx) {
                html += '<div style="margin-top:12px;padding-top:12px;border-top:1px solid var(--border);display:flex;flex-wrap:wrap;gap:12px;justify-content:center;align-items:center;font-size:12px;">';
                html += '<span style="color:var(--text-secondary);">ğŸ“œ Transazioni:</span>';
                for (const y of years) {
                    if (txByYear[y] > 0) {
                        html += '<span style="background:var(--bg-secondary);padding:4px 8px;border-radius:4px;"><strong>' + y + '</strong>: ' + txByYear[y] + '</span>';
                    }
                }
                html += '</div>';
            }
            html += '</div>';
            
            container.innerHTML = html;
            
            // Render detail per wallet
            let dh = '';
            for (const wd of (data.walletDetails || [])) {
                if (!wd) continue;
                dh += '<div style="margin-bottom:24px;padding:20px;background:var(--bg-primary);border-radius:12px;">';
                dh += '<h3 style="margin-bottom:16px;display:flex;align-items:center;gap:10px;font-size:16px;">ğŸ‘› ' + (wd.walletName || 'Wallet') + ' <span style="font-size:12px;color:var(--text-secondary);font-weight:normal;">' + (wd.walletAddress || '') + '</span></h3>';
                dh += '<table style="width:100%;border-collapse:collapse;font-size:13px;"><thead><tr style="border-bottom:2px solid var(--border);"><th style="text-align:left;padding:12px 8px;color:var(--text-secondary);font-weight:500;">TOKEN</th>';
                for (const y of years) dh += '<th style="text-align:center;padding:12px 8px;color:var(--text-secondary);font-weight:500;">' + y + '</th>';
                dh += '</tr></thead><tbody>';
                
                // Token rows
                for (const row of (wd.rows || [])) {
                    if (!row) continue;
                    dh += '<tr style="border-bottom:1px solid var(--border);"><td style="padding:12px 8px;"><strong>' + (row.tokenKey || '?') + '</strong></td>';
                    for (const y of years) {
                        const cell = row.cells ? row.cells[y] : null;
                        if (cell && cell.hasValue) {
                            dh += '<td style="text-align:center;padding:12px 8px;"><span style="color:var(--green);font-weight:600;">â‚¬' + formatEUR(cell.eur || 0) + '</span><br><span style="font-size:10px;color:var(--text-secondary);">' + formatNum(cell.balance || 0, 2) + '</span></td>';
                        } else if (cell && cell.balance > 0) {
                            dh += '<td style="text-align:center;padding:12px 8px;"><span style="color:var(--text-secondary);">' + formatNum(cell.balance || 0, 2) + '</span><br><span style="font-size:10px;color:var(--red);">no price</span></td>';
                        } else {
                            dh += '<td style="text-align:center;padding:12px 8px;color:var(--text-secondary);">-</td>';
                        }
                    }
                    dh += '</tr>';
                }
                
                // Wallet total row
                dh += '<tr style="background:var(--bg-secondary);border-radius:8px;"><td style="padding:14px 8px;font-weight:700;">TOTALE</td>';
                for (const y of years) {
                    const tot = wd.totals ? wd.totals[y] : null;
                    dh += '<td style="text-align:center;padding:14px 8px;font-weight:700;font-size:15px;color:var(--green);">â‚¬' + formatEUR(tot ? (tot.eur || 0) : 0) + '</td>';
                }
                dh += '</tr>';
                
                dh += '</tbody></table></div>';
            }
            
            detailContent.innerHTML = dh;
            detailCard.style.display = 'block';
        }
        
        function printTaxReport() {
            if (!taxReportData || !taxReportData.grandTotals || !taxReportData.walletDetails) {
                alert('Nessun report da stampare. Calcola prima il Tax Report.');
                return;
            }
            
            const years = [2021, 2022, 2023, 2024];
            const data = taxReportData;
            const dateStr = new Date().toLocaleString('it-IT');
            
            // Calcola totali combinati
            const combinedTotals = {};
            let hasExchange = false;
            for (const y of years) {
                const walletEur = data.grandTotals[y]?.eur || 0;
                const walletUsd = data.grandTotals[y]?.usd || 0;
                const exchEur = exchangeValues[y] || 0;
                const exchUsd = exchEur / EUR_USD;
                if (exchEur > 0) hasExchange = true;
                combinedTotals[y] = { eur: walletEur + exchEur, usd: walletUsd + exchUsd, walletEur, exchangeEur: exchEur };
            }
            
            // Build HTML string safely
            let html = '<!DOCTYPE html><html><head><meta charset="UTF-8"><title>Tax Report - Quadro RW</title>';
            html += '<style>';
            html += '* { margin: 0; padding: 0; box-sizing: border-box; }';
            html += 'body { font-family: Arial, sans-serif; padding: 40px; color: #1a1a2e; background: #fff; }';
            html += '.header { text-align: center; margin-bottom: 30px; border-bottom: 2px solid #1a1a2e; padding-bottom: 20px; }';
            html += '.header h1 { font-size: 24px; margin-bottom: 8px; }';
            html += '.header p { color: #666; font-size: 12px; }';
            html += '.summary h2 { font-size: 16px; margin-bottom: 15px; background: #f5f5f5; padding: 10px; }';
            html += 'table { width: 100%; border-collapse: collapse; margin-bottom: 20px; font-size: 12px; }';
            html += 'th { background: #1a1a2e; color: white; padding: 12px 8px; text-align: center; }';
            html += 'td { padding: 10px 8px; border-bottom: 1px solid #ddd; text-align: center; }';
            html += '.value-eur { font-weight: 700; color: #00c853; font-size: 14px; }';
            html += '.value-exchange { font-weight: 600; color: #f3ba2f; }';
            html += '.obbligo { background: #ffebee; }';
            html += '.obbligo-badge { background: #f44336; color: white; padding: 4px 8px; border-radius: 4px; font-size: 10px; }';
            html += '.no-badge { background: #e8f5e9; color: #2e7d32; padding: 4px 8px; border-radius: 4px; font-size: 10px; }';
            html += '.wallet-section { margin-bottom: 25px; page-break-inside: avoid; }';
            html += '.wallet-header { background: #f5f5f5; padding: 10px; margin-bottom: 10px; }';
            html += '.total-row { background: #e3f2fd; font-weight: 700; }';
            html += '.footer { margin-top: 30px; padding-top: 20px; border-top: 1px solid #ddd; font-size: 10px; color: #666; text-align: center; }';
            html += '.info-box { background: #fff3e0; border: 1px solid #ff9800; padding: 12px; margin-bottom: 20px; font-size: 11px; }';
            html += '</style></head><body>';
            
            // Header
            html += '<div class="header">';
            html += '<h1>TAX REPORT - QUADRO RW</h1>';
            html += '<p>Generato il ' + dateStr + ' | CryptoFolio</p>';
            html += '</div>';
            
            // Info box
            html += '<div class="info-box">';
            html += '<strong>NOTA:</strong> Valore criptovalute al 31/12. Soglia Quadro RW: 15.000 EUR. Consultare commercialista.';
            html += '</div>';
            
            // Summary table con colonne separate
            html += '<div class="summary"><h2>RIEPILOGO ANNUALE</h2>';
            html += '<table><thead><tr><th>ANNO</th><th>WALLET</th><th>EXCHANGE</th><th>TOTALE EUR</th><th>QUADRO RW</th></tr></thead><tbody>';
            
            for (const y of years) {
                const t = combinedTotals[y];
                const above = (t.eur || 0) >= 15000;
                html += '<tr class="' + (above ? 'obbligo' : '') + '">';
                html += '<td><strong>' + y + '</strong></td>';
                html += '<td class="value-eur">EUR ' + formatEUR(t.walletEur || 0) + '</td>';
                html += '<td class="value-exchange">EUR ' + formatEUR(t.exchangeEur || 0) + '</td>';
                html += '<td class="value-eur" style="font-size:16px;">EUR ' + formatEUR(t.eur || 0) + '</td>';
                html += '<td>' + (above ? '<span class="obbligo-badge">SI - OBBLIGO</span>' : '<span class="no-badge">NO</span>') + '</td>';
                html += '</tr>';
            }
            
            html += '</tbody></table>';
            html += '<p style="font-size:11px;color:#666;">Aggregato da ' + (data.walletCount || 0) + ' wallet' + (hasExchange ? ' + Exchange' : '') + ' | Chain: ' + (data.chainNames || 'N/A') + '</p>';
            html += '</div>';
            
            // Wallet details
            html += '<h2 style="font-size:16px;margin:20px 0 15px;background:#f5f5f5;padding:10px;">DETTAGLIO PER WALLET</h2>';
            
            for (const wd of (data.walletDetails || [])) {
                if (!wd) continue;
                html += '<div class="wallet-section">';
                html += '<div class="wallet-header"><strong>' + (wd.walletName || 'Wallet') + '</strong> - ' + (wd.walletAddress || '') + '</div>';
                html += '<table><thead><tr><th style="text-align:left;">TOKEN</th>';
                for (const y of years) {
                    html += '<th>' + y + '</th>';
                }
                html += '</tr></thead><tbody>';
                
                for (const row of (wd.rows || [])) {
                    if (!row) continue;
                    html += '<tr><td style="text-align:left;"><strong>' + (row.tokenKey || '?') + '</strong></td>';
                    for (const y of years) {
                        const cell = row.cells ? row.cells[y] : null;
                        if (cell && cell.hasValue) {
                            html += '<td class="value-eur">EUR ' + formatEUR(cell.eur || 0) + '<br><small style="color:#666;">' + formatNum(cell.balance || 0, 2) + '</small></td>';
                        } else if (cell && cell.balance > 0) {
                            html += '<td><small>' + formatNum(cell.balance || 0, 2) + '</small></td>';
                        } else {
                            html += '<td>-</td>';
                        }
                    }
                    html += '</tr>';
                }
                
                html += '<tr class="total-row"><td style="text-align:left;"><strong>TOTALE</strong></td>';
                for (const y of years) {
                    const tot = wd.totals ? wd.totals[y] : null;
                    html += '<td class="value-eur">EUR ' + formatEUR(tot ? (tot.eur || 0) : 0) + '</td>';
                }
                html += '</tr></tbody></table></div>';
            }
            
            // Footer
            html += '<div class="footer">';
            html += '<p>Documento generato da CryptoFolio | Solo uso informativo</p>';
            html += '</div>';
            
            html += '</body></html>';
            
            // Open print window
            const printWindow = window.open('', '_blank');
            if (printWindow) {
                printWindow.document.write(html);
                printWindow.document.close();
                printWindow.onload = function() { printWindow.print(); };
            } else {
                alert('Popup bloccato! Abilita i popup per stampare.');
            }
        }
        
        function clearTaxReport() {
            if (!confirm('Vuoi cancellare il Tax Report salvato?')) return;
            taxReportData = null;
            document.getElementById('taxReportContent').innerHTML = '<div class="empty-state"><div class="icon">ğŸ‘†</div><h3>Clicca "Calcola Tutti" per iniziare</h3></div>';
            document.getElementById('taxDetailCard').style.display = 'none';
            saveToFirebase();
            alert('Tax Report resettato!');
        }
        
        function saveExchangeValues() {
            const years = [2021, 2022, 2023, 2024, 2025, 2026];
            for (const y of years) {
                const val = parseFloat(document.getElementById('exchange' + y).value) || 0;
                exchangeValues[y] = val;
            }
            saveToFirebase();
            alert('âœ… Valori Exchange salvati!');
            
            // Ricalcola se c'Ã¨ giÃ  un report
            if (taxReportData) {
                renderTaxReport(taxReportData);
            }
        }
        
        function loadExchangeValuesUI() {
            const years = [2021, 2022, 2023, 2024, 2025, 2026];
            for (const y of years) {
                const input = document.getElementById('exchange' + y);
                if (input && exchangeValues[y]) {
                    // Formatta con max 2 decimali
                    input.value = parseFloat(exchangeValues[y]).toFixed(2);
                }
            }
        }
        
        function updateTaxWalletsList() {
            const container = document.getElementById('taxWalletsList');
            if (!container) return;
            
            if (savedWallets.length === 0) {
                container.innerHTML = '<p style="color:var(--red);">âš ï¸ Nessun wallet salvato. Vai su <strong>Wallets</strong> per aggiungerne.</p>';
                document.getElementById('taxReportContent').innerHTML = '<div class="empty-state"><div class="icon">ğŸ‘›</div><h3>Aggiungi wallet prima</h3></div>';
                return;
            }
            
            let html = '<div style="display:flex;flex-wrap:wrap;gap:8px;">';
            savedWallets.forEach(w => {
                const shortAddr = w.address.slice(0, 6) + '...' + w.address.slice(-4);
                html += `<span style="background:var(--bg-primary);padding:6px 12px;border-radius:8px;font-size:13px;">ğŸ‘› ${w.name} <span style="color:var(--text-secondary);">(${shortAddr})</span></span>`;
            });
            html += '</div>';
            container.innerHTML = html;
        }
        
        // ==================== API MANAGEMENT ====================
        function saveMoralisKey() {
            const key = document.getElementById('moralisKey').value.trim();
            if (!key) {
                alert('Inserisci una API key valida');
                return;
            }
            
            // Supporta multiple keys separate da virgola o a capo
            const keys = key.split(/[,\n]/).map(k => k.trim()).filter(k => k.length > 10);
            
            if (keys.length === 0) {
                alert('Inserisci almeno una API key valida');
                return;
            }
            
            // Salva array di keys
            moralisKeys = keys;
            currentMoralisKeyIndex = 0;
            moralisKeyFailures = {};
            
            // Mantieni compatibilitÃ  con vecchio sistema
            apiKeys.moralis = keys[0];
            apiKeys.moralisKeys = keys;
            
            localStorage.setItem('cryptofolio_apikeys', JSON.stringify(apiKeys));
            localStorage.setItem('cryptofolio_moralis_keys', JSON.stringify(keys));
            saveToFirebase();
            updateApiStatus();
            
            if (keys.length > 1) {
                alert(`âœ… ${keys.length} Moralis API keys salvate!\n\nLe chiavi verranno usate in cascata quando una raggiunge il limite.`);
            } else {
                alert('âœ… Moralis API key salvata!');
            }
        }
        
        // Funzione per ottenere la key Moralis corrente
        function getMoralisKey() {
            if (moralisKeys.length === 0) {
                // Carica da localStorage se non ancora caricato
                loadMoralisKeys();
            }
            
            if (moralisKeys.length === 0) {
                return apiKeys.moralis || null;
            }
            
            return moralisKeys[currentMoralisKeyIndex] || moralisKeys[0];
        }
        
        // Carica le keys Moralis
        function loadMoralisKeys() {
            try {
                const saved = localStorage.getItem('cryptofolio_moralis_keys');
                if (saved) {
                    moralisKeys = JSON.parse(saved);
                    console.log(`ğŸ”‘ Caricate ${moralisKeys.length} Moralis API keys`);
                } else if (apiKeys.moralis) {
                    moralisKeys = [apiKeys.moralis];
                }
            } catch (e) {
                if (apiKeys.moralis) {
                    moralisKeys = [apiKeys.moralis];
                }
            }
        }
        
        // Ruota alla prossima key quando una fallisce
        function rotateMoralisKey(reason = '') {
            if (moralisKeys.length <= 1) return false;
            
            const oldIndex = currentMoralisKeyIndex;
            const oldKey = moralisKeys[oldIndex];
            
            // Segna questa key come fallita
            moralisKeyFailures[oldKey] = (moralisKeyFailures[oldKey] || 0) + 1;
            
            // Passa alla prossima
            currentMoralisKeyIndex = (currentMoralisKeyIndex + 1) % moralisKeys.length;
            
            // Se abbiamo provato tutte le keys, resetta i contatori
            if (currentMoralisKeyIndex === 0) {
                console.warn('âš ï¸ Tutte le Moralis API keys hanno raggiunto il limite!');
                return false;
            }
            
            console.log(`ğŸ”„ Moralis API key rotata: ${oldIndex + 1} â†’ ${currentMoralisKeyIndex + 1} (${reason})`);
            return true;
        }
        
        function saveEtherscanKey() {
            const key = document.getElementById('etherscanKey').value.trim();
            if (!key) {
                alert('Inserisci una API key valida');
                return;
            }
            apiKeys.etherscan = key;
            // Also update the old apiKey field for backward compatibility
            document.getElementById('apiKey').value = key;
            localStorage.setItem('cryptofolio_apikeys', JSON.stringify(apiKeys));
            saveToFirebase();
            updateApiStatus();
            alert('âœ… Etherscan API key salvata!');
        }
        
        function saveHeliusKey() {
            const key = document.getElementById('heliusKey').value.trim();
            if (!key) {
                alert('Inserisci una API key valida');
                return;
            }
            apiKeys.helius = key;
            localStorage.setItem('cryptofolio_apikeys', JSON.stringify(apiKeys));
            saveToFirebase();
            updateApiStatus();
            alert('âœ… Helius API key salvata! Solana scan migliorato.');
        }
        
        function updateApiStatus() {
            // Update status badges
            const moralisStatus = document.getElementById('moralisStatus');
            const etherscanStatus = document.getElementById('etherscanStatus');
            
            if (moralisStatus) {
                if (apiKeys.moralis) {
                    moralisStatus.textContent = 'ON';
                    moralisStatus.classList.add('api-on');
                } else {
                    moralisStatus.textContent = 'OFF';
                    moralisStatus.classList.remove('api-on');
                }
            }
            
            if (etherscanStatus) {
                if (apiKeys.etherscan) {
                    etherscanStatus.textContent = 'ON';
                    etherscanStatus.classList.add('api-on');
                } else {
                    etherscanStatus.textContent = 'OFF';
                    etherscanStatus.classList.remove('api-on');
                }
            }
            
            const heliusStatus = document.getElementById('heliusStatus');
            if (heliusStatus) {
                if (apiKeys.helius) {
                    heliusStatus.textContent = 'ON';
                    heliusStatus.classList.add('api-on');
                } else {
                    heliusStatus.textContent = 'OFF';
                    heliusStatus.classList.remove('api-on');
                }
            }
            
            // Fill input fields
            if (document.getElementById('moralisKey')) {
                // Mostra tutte le keys separate da newline
                loadMoralisKeys();
                if (moralisKeys.length > 0) {
                    document.getElementById('moralisKey').value = moralisKeys.join('\n');
                } else if (apiKeys.moralis) {
                    document.getElementById('moralisKey').value = apiKeys.moralis;
                }
            }
            if (document.getElementById('etherscanKey') && apiKeys.etherscan) {
                document.getElementById('etherscanKey').value = apiKeys.etherscan;
            }
            if (document.getElementById('heliusKey') && apiKeys.helius) {
                document.getElementById('heliusKey').value = apiKeys.helius;
            }
            
            // Update API count badge
            updateApiCount();
            
            // Update summary
            const summary = document.getElementById('apiSummary');
            if (summary) {
                let html = '';
                
                // Moralis
                const moralisCount = moralisKeys.length || (apiKeys.moralis ? 1 : 0);
                const moralisStatus = moralisCount > 1 ? `âœ“ ${moralisCount} keys` : (moralisCount === 1 ? 'âœ“ Configurato' : 'âœ— Non configurato');
                html += `<div style="padding:16px;background:var(--bg-primary);border-radius:10px;text-align:center;">
                    <div style="font-size:24px;margin-bottom:8px;">ğŸŸ¢</div>
                    <div style="font-weight:600;">Moralis</div>
                    <div style="font-size:12px;color:${moralisCount > 0 ? 'var(--green)' : 'var(--red)'};">${moralisStatus}</div>
                </div>`;
                
                // Etherscan
                html += `<div style="padding:16px;background:var(--bg-primary);border-radius:10px;text-align:center;">
                    <div style="font-size:24px;margin-bottom:8px;">ğŸ”µ</div>
                    <div style="font-weight:600;">Etherscan</div>
                    <div style="font-size:12px;color:${apiKeys.etherscan ? 'var(--green)' : 'var(--red)'};">${apiKeys.etherscan ? 'âœ“ Configurato' : 'âœ— Non configurato'}</div>
                </div>`;
                
                // PulseChain
                html += `<div style="padding:16px;background:var(--bg-primary);border-radius:10px;text-align:center;">
                    <div style="font-size:24px;margin-bottom:8px;">ğŸ’š</div>
                    <div style="font-weight:600;">PulseChain</div>
                    <div style="font-size:12px;color:var(--green);">âœ“ Auto</div>
                </div>`;
                
                // Solana / Helius
                html += `<div style="padding:16px;background:var(--bg-primary);border-radius:10px;text-align:center;">
                    <div style="font-size:24px;margin-bottom:8px;">ğŸŸ£</div>
                    <div style="font-weight:600;">Solana</div>
                    <div style="font-size:12px;color:${apiKeys.helius ? 'var(--green)' : 'var(--red)'};">${apiKeys.helius ? 'âœ“ Helius' : 'âœ— Configura Helius'}</div>
                </div>`;
                
                summary.innerHTML = html;
            }
        }
        
        function updateApiCount() {
            let count = 1; // PulseChain sempre attiva
            if (apiKeys.moralis) count++;
            if (apiKeys.etherscan) count++;
            if (apiKeys.helius) count++;
            document.getElementById('apiCount').textContent = count;
        }
        
        // ==================== HELIUS API (SOLANA) ====================
        async function fetchWithHelius(addr) {
            if (!apiKeys.helius) return null;
            
            try {
                console.log('Fetching Solana data with Helius for', addr);
                
                // Helius balances endpoint - restituisce SOL + tutti i token SPL
                const url = `https://api.helius.xyz/v0/addresses/${addr}/balances?api-key=${apiKeys.helius}`;
                const response = await fetch(url);
                
                if (!response.ok) {
                    console.error('Helius API error:', response.status);
                    return null;
                }
                
                const data = await response.json();
                console.log('Helius response:', data);
                
                const results = [];
                
                // Native SOL balance
                if (data.nativeBalance) {
                    const solBalance = data.nativeBalance / 1e9; // lamports to SOL
                    const solPrice = NATIVE_PRICES.SOL || 150;
                    
                    if (solBalance > 0.0001) {
                        results.push({
                            symbol: 'SOL',
                            name: 'Solana',
                            balance: solBalance,
                            price: solPrice,
                            valueUSD: solBalance * solPrice,
                            contract: 'native-solana',
                            logo: TOKEN_ICONS['SOL'],
                            chain: 'solana'
                        });
                        console.log('SOL balance:', solBalance, 'USD:', solBalance * solPrice);
                    }
                }
                
                // Token balances
                if (data.tokens && data.tokens.length > 0) {
                    for (const token of data.tokens) {
                        if (!token.amount || token.amount <= 0) continue;
                        
                        const decimals = token.decimals || 0;
                        const balance = token.amount / Math.pow(10, decimals);
                        
                        if (balance <= 0) continue;
                        
                        // Try to get price from DexScreener
                        let price = 0;
                        let logo = null;
                        let symbol = token.symbol || 'SPL';
                        let name = token.name || 'Solana Token';
                        
                        const pd = await fetchTokenPrice(token.mint, 'solana');
                        if (pd) {
                            price = pd.price;
                            if (pd.logo) logo = pd.logo;
                            if (pd.symbol) symbol = pd.symbol;
                            if (pd.name) name = pd.name;
                        }
                        
                        // Skip dust (< $0.01)
                        const valueUSD = balance * price;
                        if (valueUSD < 0.01 && price > 0) continue;
                        
                        results.push({
                            symbol: symbol,
                            name: name,
                            balance: balance,
                            price: price,
                            valueUSD: valueUSD,
                            contract: token.mint,
                            logo: logo,
                            chain: 'solana'
                        });
                    }
                }
                
                console.log('Helius found', results.length, 'assets');
                return results;
                
            } catch (e) {
                console.error('Helius fetch error:', e);
                return null;
            }
        }
        
        // ==================== MORALIS API ====================
        async function fetchWithMoralis(addr, chainKey, retryCount = 0) {
            const moralisKey = getMoralisKey();
            if (!moralisKey || !MORALIS_CHAINS[chainKey]) return null;
            
            try {
                const chain = MORALIS_CHAINS[chainKey];
                
                // Get native balance
                const nativeRes = await fetch(`https://deep-index.moralis.io/api/v2.2/${addr}/balance?chain=${chain}`, {
                    headers: { 'X-API-Key': moralisKey }
                });
                
                // Controlla rate limit
                if (nativeRes.status === 429 || nativeRes.status === 400) {
                    console.warn(`âš ï¸ Moralis rate limit (key ${currentMoralisKeyIndex + 1})`);
                    if (rotateMoralisKey('rate limit') && retryCount < moralisKeys.length) {
                        return fetchWithMoralis(addr, chainKey, retryCount + 1);
                    }
                    return null;
                }
                
                const nativeData = await nativeRes.json();
                
                // Get token balances
                const tokenRes = await fetch(`https://deep-index.moralis.io/api/v2.2/${addr}/erc20?chain=${chain}`, {
                    headers: { 'X-API-Key': moralisKey }
                });
                
                // Controlla rate limit
                if (tokenRes.status === 429 || tokenRes.status === 400) {
                    console.warn(`âš ï¸ Moralis rate limit (key ${currentMoralisKeyIndex + 1})`);
                    if (rotateMoralisKey('rate limit') && retryCount < moralisKeys.length) {
                        return fetchWithMoralis(addr, chainKey, retryCount + 1);
                    }
                    return null;
                }
                
                const tokenData = await tokenRes.json();
                
                return {
                    nativeBalance: nativeData.balance || '0',
                    tokens: tokenData || []
                };
            } catch (e) {
                console.error('Moralis error:', e);
                // Prova a ruotare la key anche per errori di rete
                if (rotateMoralisKey('network error') && retryCount < moralisKeys.length) {
                    return fetchWithMoralis(addr, chainKey, retryCount + 1);
                }
                return null;
            }
        }
        
        async function scanWithMoralis(addr, chainKey) {
            const chainInfo = CHAINS[chainKey];
            const moralisData = await fetchWithMoralis(addr, chainKey);
            
            if (!moralisData) return [];
            
            const results = [];
            
            // Native balance
            const nativeBal = moralisData.nativeBalance ? Number(BigInt(moralisData.nativeBalance)) / 1e18 : 0;
            let nativePrice = NATIVE_PRICES[chainInfo.symbol] || NATIVE_PRICES.ETH;
            
            // FIX: Forza prezzo corretto per CRO (evita bug Moralis/DexScreener)
            if (chainInfo.symbol === 'CRO' && (nativePrice > 1 || nativePrice === 0)) {
                nativePrice = NATIVE_PRICES.CRO || 0.09;
            }
            
            if (nativeBal > 0.0001) {
                results.push({
                    symbol: chainInfo.symbol,
                    name: `${chainInfo.symbol} (${chainInfo.name})`,
                    balance: nativeBal,
                    price: nativePrice,
                    valueUSD: nativeBal * nativePrice,
                    contract: `native-${chainKey}`,
                    logo: TOKEN_ICONS[chainInfo.symbol],
                    chain: chainKey
                });
            }
            
            // Token balances - check if tokens exists and is array
            if (moralisData.tokens && Array.isArray(moralisData.tokens)) {
                for (const token of moralisData.tokens) {
                    if (isBlacklisted(token.token_address) || isSpam(token.name, token.symbol)) continue;
                    
                    const bal = Number(BigInt(token.balance)) / Math.pow(10, token.decimals || 18);
                    if (bal <= 0) continue;
                    
                    let price = 0, logo = TOKEN_ICONS[token.symbol?.toUpperCase()] || token.logo || null;
                    
                    // Get price from DexScreener
                    const pd = await fetchTokenPrice(token.token_address, chainInfo.dex);
                    if (pd) { price = pd.price; if (pd.logo) logo = pd.logo; }
                    
                    // FIX: Forza prezzo corretto per WCRO e token CRO-like su Cronos
                    const sym = (token.symbol || '').toUpperCase();
                    if ((sym === 'WCRO' || sym === 'CRO') && (price > 1 || price === 0)) {
                        price = NATIVE_PRICES.CRO || 0.09;
                    }
                    
                    results.push({
                        symbol: token.symbol,
                        name: token.name,
                        balance: bal,
                        price,
                        valueUSD: bal * price,
                        contract: token.token_address.toLowerCase(),
                        logo,
                        chain: chainKey
                    });
                }
            }
            
            return results;
        }
        
        // ==================== WALLET TRANSACTIONS (MORALIS + ETHERSCAN FALLBACK) ====================
        
        // Etherscan-compatible API endpoints (include PulseScan)
        const ETHERSCAN_TX_APIS = {
            eth: 'https://api.etherscan.io/api',
            bsc: 'https://api.bscscan.com/api',
            polygon: 'https://api.polygonscan.com/api',
            arbitrum: 'https://api.arbiscan.io/api',
            base: 'https://api.basescan.org/api',
            pulse: 'https://api.scan.pulsechain.com/api'  // PulseScan - no API key needed!
        };
        
        // Scarica transazioni via Etherscan/PulseScan (fallback)
        async function fetchTxEtherscan(addr, chainKey, type = 'native') {
            const apiUrl = ETHERSCAN_TX_APIS[chainKey];
            if (!apiUrl) return [];
            
            // PulseScan non richiede API key
            const needsKey = chainKey !== 'pulse';
            const etherscanKey = apiKeys.etherscan;
            if (needsKey && !etherscanKey) return [];
            
            try {
                const action = type === 'native' ? 'txlist' : 'tokentx';
                let url = `${apiUrl}?module=account&action=${action}&address=${addr}&startblock=0&endblock=99999999&sort=desc`;
                if (needsKey) url += `&apikey=${etherscanKey}`;
                
                console.log(`ğŸ“¡ ${chainKey === 'pulse' ? 'PulseScan' : 'Etherscan'} ${type} tx: ${chainKey}`);
                const res = await fetch(url);
                const data = await res.json();
                
                if (data.status === '1' && Array.isArray(data.result)) {
                    console.log(`âœ… Got ${data.result.length} ${type} tx from ${chainKey}`);
                    return data.result;
                }
                return [];
            } catch (e) {
                console.error(`Scanner error (${chainKey}):`, e);
                return [];
            }
        }
        
        // Scarica transazioni native (ETH, BNB transfers) - Moralis con Etherscan/PulseScan fallback
        async function fetchNativeTxMoralis(addr, chainKey, cursor = null, retryCount = 0) {
            if (moralisKeys.length === 0) loadMoralisKeys();
            
            const moralisKey = getMoralisKey();
            const chain = MORALIS_CHAINS[chainKey];
            
            // PulseChain: usa direttamente PulseScan (non supportato da Moralis)
            if (chainKey === 'pulse') {
                console.log(`ğŸ“¡ PulseScan native tx: pulse`);
                const results = await fetchTxEtherscan(addr, 'pulse', 'native');
                return { result: results, cursor: null, source: 'pulsescan' };
            }
            
            // Se non c'Ã¨ Moralis o chain non supportata, prova Etherscan
            if (!moralisKey || !chain) {
                if (ETHERSCAN_TX_APIS[chainKey]) {
                    console.log(`ğŸ“¡ Etherscan fallback native tx: ${chainKey}`);
                    const results = await fetchTxEtherscan(addr, chainKey, 'native');
                    return { result: results, cursor: null, source: 'etherscan' };
                }
                return { result: [], cursor: null };
            }
            
            try {
                let url = `https://deep-index.moralis.io/api/v2.2/${addr}?chain=${chain}&limit=100`;
                if (cursor) url += `&cursor=${cursor}`;
                
                console.log(`ğŸ“¡ Moralis native tx: ${chainKey} (key #${currentMoralisKeyIndex + 1}/${moralisKeys.length})`);
                const res = await fetch(url, { headers: { 'X-API-Key': moralisKey } });
                
                if (res.status === 429 || res.status === 401) {
                    // Prova rotazione
                    if (rotateMoralisKey(`status ${res.status}`) && retryCount < moralisKeys.length) {
                        await new Promise(r => setTimeout(r, 300));
                        return fetchNativeTxMoralis(addr, chainKey, cursor, retryCount + 1);
                    }
                    
                    // Tutte le key Moralis fallite - usa Etherscan
                    if (ETHERSCAN_TX_APIS[chainKey] && apiKeys.etherscan) {
                        console.log(`âš ï¸ Moralis esaurito, uso Etherscan per ${chainKey}`);
                        const results = await fetchTxEtherscan(addr, chainKey, 'native');
                        console.log(`âœ… Etherscan fallback: ${results.length} native tx`);
                        return { result: results, cursor: null, source: 'etherscan' };
                    }
                    return { result: [], cursor: null };
                }
                
                if (!res.ok) return { result: [], cursor: null };
                
                const data = await res.json();
                console.log(`âœ… Moralis: ${data.result?.length || 0} native tx from ${chainKey}`);
                return { result: data.result || [], cursor: data.cursor || null, source: 'moralis' };
            } catch (e) {
                console.error('Moralis error:', e);
                // Fallback Etherscan
                if (ETHERSCAN_TX_APIS[chainKey] && apiKeys.etherscan) {
                    const results = await fetchTxEtherscan(addr, chainKey, 'native');
                    return { result: results, cursor: null, source: 'etherscan' };
                }
                return { result: [], cursor: null };
            }
        }
        
        // Scarica trasferimenti token ERC20 - Moralis con Etherscan/PulseScan fallback
        async function fetchTokenTxMoralis(addr, chainKey, cursor = null, retryCount = 0) {
            if (moralisKeys.length === 0) loadMoralisKeys();
            
            const moralisKey = getMoralisKey();
            const chain = MORALIS_CHAINS[chainKey];
            
            // PulseChain: usa direttamente PulseScan
            if (chainKey === 'pulse') {
                console.log(`ğŸ“¡ PulseScan token tx: pulse`);
                const results = await fetchTxEtherscan(addr, 'pulse', 'token');
                return { result: results, cursor: null, source: 'pulsescan' };
            }
            
            if (!moralisKey || !chain) {
                if (ETHERSCAN_TX_APIS[chainKey]) {
                    console.log(`ğŸ“¡ Etherscan fallback token tx: ${chainKey}`);
                    const results = await fetchTxEtherscan(addr, chainKey, 'token');
                    return { result: results, cursor: null, source: 'etherscan' };
                }
                return { result: [], cursor: null };
            }
            
            try {
                let url = `https://deep-index.moralis.io/api/v2.2/${addr}/erc20/transfers?chain=${chain}&limit=100`;
                if (cursor) url += `&cursor=${cursor}`;
                
                const res = await fetch(url, { headers: { 'X-API-Key': moralisKey } });
                
                if (res.status === 429 || res.status === 401) {
                    if (rotateMoralisKey(`status ${res.status}`) && retryCount < moralisKeys.length) {
                        await new Promise(r => setTimeout(r, 300));
                        return fetchTokenTxMoralis(addr, chainKey, cursor, retryCount + 1);
                    }
                    
                    // Fallback Etherscan
                    if (ETHERSCAN_TX_APIS[chainKey] && apiKeys.etherscan) {
                        console.log(`âš ï¸ Moralis esaurito, uso Etherscan per ${chainKey}`);
                        const results = await fetchTxEtherscan(addr, chainKey, 'token');
                        console.log(`âœ… Etherscan fallback: ${results.length} token tx`);
                        return { result: results, cursor: null, source: 'etherscan' };
                    }
                    return { result: [], cursor: null };
                }
                
                const data = await res.json();
                console.log(`âœ… Moralis: ${data.result?.length || 0} token tx from ${chainKey}`);
                return { result: data.result || [], cursor: data.cursor || null, source: 'moralis' };
            } catch (e) {
                if (ETHERSCAN_TX_APIS[chainKey] && apiKeys.etherscan) {
                    const results = await fetchTxEtherscan(addr, chainKey, 'token');
                    return { result: results, cursor: null, source: 'etherscan' };
                }
                return { result: [], cursor: null };
            }
        }
        
        // Scarica tutte le transazioni per un wallet (formato compatto)
        async function downloadWalletTransactions(addr, progressCallback) {
            const addrLower = addr.toLowerCase();
            const chainsToScan = ['eth', 'polygon', 'bsc', 'arbitrum', 'base', 'pulse'];
            
            console.log(`ğŸš€ Download transazioni per ${addrLower.slice(0,10)}...`);
            
            const nativeTx = [];
            const tokenTx = [];
            
            for (const chainKey of chainsToScan) {
                const chainSymbol = CHAINS[chainKey]?.symbol || 'ETH';
                
                // Download native transactions
                if (progressCallback) progressCallback(`${CHAINS[chainKey]?.name || chainKey} native...`);
                const { result: nativeResult, source: nativeSource } = await fetchNativeTxMoralis(addr, chainKey, null);
                
                for (const tx of nativeResult) {
                    let value, date;
                    
                    if (nativeSource === 'etherscan' || nativeSource === 'pulsescan') {
                        value = tx.value ? Number(tx.value) / 1e18 : 0;
                        date = tx.timeStamp ? new Date(tx.timeStamp * 1000).toISOString().slice(0, 10) : '';
                    } else {
                        value = tx.value ? Number(tx.value) / 1e18 : 0;
                        date = tx.block_timestamp?.slice(0, 10) || '';
                    }
                    
                    if (value < 0.0000001) continue;
                    
                    const toAddr = (nativeSource === 'etherscan' || nativeSource === 'pulsescan' ? tx.to : tx.to_address)?.toLowerCase();
                    
                    nativeTx.push({
                        d: date,
                        t: toAddr === addrLower ? 'in' : 'out',
                        s: chainSymbol,
                        a: value,
                        h: tx.hash?.slice(0, 10) || '',
                        c: chainKey
                    });
                }
                
                await new Promise(r => setTimeout(r, 250));
                
                // Download token transfers
                if (progressCallback) progressCallback(`${CHAINS[chainKey]?.name || chainKey} token...`);
                const { result: tokenResult, source: tokenSource } = await fetchTokenTxMoralis(addr, chainKey, null);
                
                for (const tx of tokenResult) {
                    let symbol, name, value, date, toAddr;
                    
                    if (tokenSource === 'etherscan' || tokenSource === 'pulsescan') {
                        symbol = tx.tokenSymbol || 'UNKNOWN';
                        name = tx.tokenName || symbol;
                        const decimals = parseInt(tx.tokenDecimal) || 18;
                        value = tx.value ? Number(tx.value) / Math.pow(10, decimals) : 0;
                        date = tx.timeStamp ? new Date(tx.timeStamp * 1000).toISOString().slice(0, 10) : '';
                        toAddr = tx.to?.toLowerCase();
                    } else {
                        symbol = tx.token_symbol || 'UNKNOWN';
                        name = tx.token_name || symbol;
                        const decimals = parseInt(tx.token_decimals) || 18;
                        value = tx.value ? Number(tx.value) / Math.pow(10, decimals) : 0;
                        date = tx.block_timestamp?.slice(0, 10) || '';
                        toAddr = tx.to_address?.toLowerCase();
                    }
                    
                    if (isSpam(name, symbol)) continue;
                    if (value < 0.0000001) continue;
                    
                    tokenTx.push({
                        d: date,
                        t: toAddr === addrLower ? 'in' : 'out',
                        s: symbol,
                        a: value,
                        h: (tx.hash || tx.transaction_hash)?.slice(0, 10) || '',
                        c: chainKey
                    });
                }
                
                await new Promise(r => setTimeout(r, 250));
            }
            
            console.log(`ğŸ“Š Download completato: ${nativeTx.length} native + ${tokenTx.length} token = ${nativeTx.length + tokenTx.length} totali`);
            return { nativeTx, tokenTx, lastDownload: Date.now() };
        }
        
        // Salva transazioni in localStorage
        function saveWalletTransactions() {
            try {
                const data = JSON.stringify(walletTransactions);
                if (data.length > 4000000) { // ~4MB limit
                    console.warn('âš ï¸ Transazioni troppo grandi per localStorage');
                    return false;
                }
                localStorage.setItem('cryptofolio_wallet_tx', data);
                console.log(`ğŸ’¾ Salvate transazioni: ${(data.length / 1024).toFixed(1)} KB`);
                return true;
            } catch (e) {
                console.error('Errore salvataggio transazioni:', e);
                return false;
            }
        }
        
        // Carica transazioni da localStorage
        function loadWalletTransactions() {
            try {
                const saved = localStorage.getItem('cryptofolio_wallet_tx');
                if (saved) {
                    walletTransactions = JSON.parse(saved);
                    const totalTx = Object.values(walletTransactions).reduce((sum, w) => 
                        sum + (w.nativeTx?.length || 0) + (w.tokenTx?.length || 0), 0);
                    console.log(`ğŸ“‚ Caricate ${totalTx} transazioni wallet`);
                    return true;
                }
            } catch (e) {
                console.error('Errore caricamento transazioni:', e);
            }
            return false;
        }
        
        // Conta transazioni per un wallet
        function getWalletTxCount(addr) {
            // Carica da localStorage se non in memoria
            if (Object.keys(walletTransactions).length === 0) {
                loadWalletTransactions();
            }
            const data = walletTransactions[addr.toLowerCase()];
            if (!data) return 0;
            return (data.nativeTx?.length || 0) + (data.tokenTx?.length || 0);
        }
        
        // ==================== WALLET MANAGEMENT ====================
        function addWallet() {
            const name = document.getElementById('newWalletName').value.trim();
            const address = document.getElementById('newWalletAddress').value.trim();
            
            if (!name) { alert('Inserisci un nome per il wallet'); return; }
            
            // Validazione: EVM (0x + 40 hex) o Solana (32-44 chars base58)
            const isEVM = address.startsWith('0x') && address.length === 42 && /^0x[a-fA-F0-9]{40}$/.test(address);
            const isSolana = /^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(address);
            
            if (!isEVM && !isSolana) { 
                alert('Indirizzo wallet non valido.\n\nFormati supportati:\nâ€¢ EVM: 0x... (42 caratteri)\nâ€¢ Solana: base58 (32-44 caratteri)'); 
                return; 
            }
            
            // Check duplicate
            if (savedWallets.some(w => w.address.toLowerCase() === address.toLowerCase())) {
                alert('Questo wallet Ã¨ giÃ  salvato');
                return;
            }
            
            // Detect wallet type
            const walletType = isSolana ? 'solana' : 'evm';
            
            savedWallets.push({ name, address, type: walletType, addedAt: Date.now() });
            localStorage.setItem('cryptofolio_wallets', JSON.stringify(savedWallets));
            
            document.getElementById('newWalletName').value = '';
            document.getElementById('newWalletAddress').value = '';
            
            updateWalletsList();
            updateWalletSelect();
            saveToFirebase();
            log(`âœ… Wallet "${name}" (${walletType.toUpperCase()}) aggiunto`, 'success');
        }
        
        function removeWallet(index) {
            if (confirm(`Rimuovere wallet "${savedWallets[index].name}"?`)) {
                savedWallets.splice(index, 1);
                localStorage.setItem('cryptofolio_wallets', JSON.stringify(savedWallets));
                updateWalletsList();
                updateWalletSelect();
                saveToFirebase();
            }
        }
        
        function selectWallet(index) {
            const wallet = savedWallets[index];
            document.getElementById('walletAddress').value = wallet.address;
            document.getElementById('walletSelect').value = index;
            showView('dashboard');
            log(`ğŸ‘› Wallet "${wallet.name}" selezionato`, 'info');
        }
        
        function onWalletSelect() {
            const select = document.getElementById('walletSelect');
            const idx = select.value;
            if (idx !== '' && savedWallets[idx]) {
                document.getElementById('walletAddress').value = savedWallets[idx].address;
            }
        }
        
        function updateWalletsList() {
            const container = document.getElementById('walletsList');
            document.getElementById('walletCount').textContent = savedWallets.length;
            
            if (savedWallets.length === 0) {
                container.innerHTML = '<p style="color:var(--text-secondary);padding:20px;text-align:center;">Nessun wallet salvato.<br>Aggiungi il tuo primo wallet sopra!</p>';
                return;
            }
            
            let html = '';
            savedWallets.forEach((w, i) => {
                const shortAddr = w.address.slice(0, 8) + '...' + w.address.slice(-6);
                // Calcola totale se scannerizzato
                const walletData = walletResults[w.address.toLowerCase()];
                const total = walletData ? walletData.results.reduce((s, t) => s + t.valueUSD, 0) * EUR_USD : 0;
                const totalStr = walletData ? `â‚¬${formatEUR(total)}` : '<span style="color:var(--text-secondary);">Non scansionato</span>';
                
                // Data ultima scansione
                const scanDate = walletData && walletData.scannedAt 
                    ? new Date(walletData.scannedAt).toLocaleString('it-IT', { day: '2-digit', month: '2-digit', year: '2-digit', hour: '2-digit', minute: '2-digit' })
                    : null;
                
                // Detect wallet type
                const isSolana = w.type === 'solana' || (!w.address.startsWith('0x') && /^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(w.address));
                const typeBadge = isSolana 
                    ? '<span style="background:#9945ff;color:#fff;padding:2px 6px;border-radius:4px;font-size:10px;margin-left:8px;">SOL</span>'
                    : '<span style="background:#627eea;color:#fff;padding:2px 6px;border-radius:4px;font-size:10px;margin-left:8px;">EVM</span>';
                
                html += `
                    <div style="display:flex;align-items:center;justify-content:space-between;padding:16px;background:var(--bg-primary);border-radius:12px;margin-bottom:12px;">
                        <div style="display:flex;align-items:center;gap:16px;cursor:pointer;flex:1;" onclick="openWalletDetail(${i})">
                            <div style="width:48px;height:48px;border-radius:12px;background:linear-gradient(135deg,${isSolana ? '#9945ff,#14f195' : 'var(--accent),var(--accent-light)'});display:flex;align-items:center;justify-content:center;font-size:20px;">ğŸ‘›</div>
                            <div>
                                <div style="font-weight:600;font-size:16px;">${w.name}${typeBadge}</div>
                                <div style="font-size:13px;color:var(--text-secondary);font-family:monospace;">${shortAddr}</div>
                            </div>
                            <div style="margin-left:auto;text-align:right;">
                                <div style="font-weight:600;color:var(--green);">${totalStr}</div>
                                ${scanDate ? `<div style="font-size:11px;color:var(--text-secondary);margin-top:2px;">ğŸ• ${scanDate}</div>` : ''}
                            </div>
                        </div>
                        <div style="display:flex;gap:8px;margin-left:16px;">
                            <button class="btn btn-primary" onclick="selectWallet(${i})" style="padding:8px 16px;">ğŸ“Š Scan</button>
                            <button class="btn btn-secondary" onclick="navigator.clipboard.writeText('${w.address}')" style="padding:8px 12px;">ğŸ“‹</button>
                            <button class="btn btn-secondary" onclick="removeWallet(${i})" style="padding:8px 12px;color:var(--red);">ğŸ—‘ï¸</button>
                        </div>
                    </div>
                `;
            });
            container.innerHTML = html;
        }
        
        function updateWalletSelect() {
            const select = document.getElementById('walletSelect');
            let html = '<option value="">-- Seleziona wallet salvato --</option>';
            savedWallets.forEach((w, i) => {
                const shortAddr = w.address.slice(0, 6) + '...' + w.address.slice(-4);
                html += `<option value="${i}">${w.name} (${shortAddr})</option>`;
            });
            select.innerHTML = html;
        }
        
        // ==================== WALLET DETAIL ====================
        function openWalletDetail(index) {
            const wallet = savedWallets[index];
            if (!wallet) return;
            
            currentDetailWallet = wallet;
            document.getElementById('detailWalletName').textContent = wallet.name;
            document.getElementById('detailWalletAddress').textContent = wallet.address;
            
            displayWalletDetail();
            showView('walletDetail');
        }
        
        function copyDetailAddress() {
            if (currentDetailWallet) {
                navigator.clipboard.writeText(currentDetailWallet.address);
                alert('Indirizzo copiato!');
            }
        }
        
        function displayWalletDetail() {
            if (!currentDetailWallet) return;
            
            const walletData = walletResults[currentDetailWallet.address.toLowerCase()];
            const container = document.getElementById('detailChainsContent');
            
            // Aggiorna data scansione
            const scanDateEl = document.getElementById('detailScanDate');
            if (walletData && walletData.scannedAt) {
                const scanDate = new Date(walletData.scannedAt).toLocaleString('it-IT', { 
                    day: '2-digit', month: '2-digit', year: 'numeric', 
                    hour: '2-digit', minute: '2-digit', second: '2-digit' 
                });
                scanDateEl.innerHTML = `ğŸ• Ultima scansione: <strong>${scanDate}</strong>`;
            } else {
                scanDateEl.textContent = 'âš ï¸ Mai scansionato';
            }
            
            if (!walletData || walletData.results.length === 0) {
                document.getElementById('detailTotal').textContent = 'â‚¬0,00';
                document.getElementById('detailChainCount').textContent = '0';
                document.getElementById('detailTokenCount').textContent = '0';
                container.innerHTML = '<div class="card"><div class="empty-state"><div class="icon">ğŸ“­</div><h3>Nessun dato</h3><p style="color:var(--text-secondary);">Clicca "Scan" per scansionare questo wallet</p></div></div>';
                return;
            }
            
            // Raggruppa token per chain (escludi blacklistati)
            const byChain = {};
            for (const token of walletData.results) {
                const contractAddr = token.contract || token.token_address || '';
                if (isBlacklisted(contractAddr)) continue;
                if (!byChain[token.chain]) byChain[token.chain] = [];
                byChain[token.chain].push(token);
            }
            
            // Calcola totali (escludi blacklistati)
            const visibleTokens = walletData.results.filter(t => !isBlacklisted(t.contract || t.token_address || ''));
            const totalUSD = visibleTokens.reduce((s, t) => s + t.valueUSD, 0);
            const totalEUR = totalUSD * EUR_USD;
            const chainCount = Object.keys(byChain).length;
            const tokenCount = visibleTokens.length;
            
            document.getElementById('detailTotal').textContent = 'â‚¬' + formatEUR(totalEUR);
            document.getElementById('detailChainCount').textContent = chainCount;
            document.getElementById('detailTokenCount').textContent = tokenCount;
            
            // Conta transazioni
            const txCount = getWalletTxCount(currentDetailWallet.address);
            document.getElementById('detailTxCount').textContent = txCount;
            
            // Genera HTML per ogni chain
            let html = '';
            for (const [chainKey, tokens] of Object.entries(byChain)) {
                const chain = CHAINS[chainKey];
                const chainTotal = tokens.filter(t => !isBlacklisted(t.contract || t.token_address || '')).reduce((s, t) => s + t.valueUSD, 0) * EUR_USD;
                
                html += `
                    <div class="card" style="margin-bottom:16px;">
                        <div class="card-header">
                            <div class="card-title" style="display:flex;align-items:center;gap:10px;">
                                <span style="width:12px;height:12px;border-radius:50%;background:${chain?.color || '#666'};"></span>
                                ${chain?.name || chainKey}
                            </div>
                            <div style="font-weight:600;color:var(--green);">â‚¬${formatEUR(chainTotal)}</div>
                        </div>
                        <table class="holdings-table">
                            <thead><tr><th>TOKEN</th><th>BALANCE</th><th>PREZZO</th><th>VALORE</th></tr></thead>
                            <tbody>
                `;
                
                // Ordina token per valore
                tokens.sort((a, b) => b.valueUSD - a.valueUSD);
                
                for (const t of tokens) {
                    // Salta token blacklistati o con valore troppo basso
                    const contractAddr = t.contract || t.token_address || '';
                    if (isBlacklisted(contractAddr)) continue;
                    if (t.valueUSD < 0.01) continue;
                    
                    const vEUR = t.valueUSD * EUR_USD;
                    html += `
                        <tr>
                            <td><div class="token-cell">
                                <button class="hide-btn" onclick="hideToken('${contractAddr}','${t.symbol || ''}')">âœ•</button>
                                <div class="token-icon">${t.logo ? `<img src="${t.logo}" onerror="this.parentElement.textContent='${t.symbol?.slice(0,2) || '??'}'">` : (t.symbol?.slice(0,2) || '??')}</div>
                                <div class="token-info">
                                    <div class="symbol">${t.symbol || '???'}</div>
                                    <div class="name">${t.name || ''}</div>
                                </div>
                            </div></td>
                            <td class="text-right text-mono">${formatNum(t.balance, 4)}</td>
                            <td class="text-right text-mono text-secondary">$${t.price > 0 ? formatNum(t.price, 6) : '-'}</td>
                            <td class="text-right text-mono" style="color:var(--green);">â‚¬${formatEUR(vEUR)}</td>
                        </tr>
                    `;
                }
                
                html += '</tbody></table></div>';
            }
            
            container.innerHTML = html;
        }
        
        function showWalletTab(tab) {
            const tokensBtn = document.getElementById('tabTokensBtn');
            const txBtn = document.getElementById('tabTxBtn');
            const tokensContent = document.getElementById('detailChainsContent');
            const txContent = document.getElementById('detailTxContent');
            
            if (tab === 'tokens') {
                tokensBtn.className = 'btn btn-primary';
                txBtn.className = 'btn btn-secondary';
                tokensContent.style.display = 'block';
                txContent.style.display = 'none';
            } else {
                tokensBtn.className = 'btn btn-secondary';
                txBtn.className = 'btn btn-primary';
                tokensContent.style.display = 'none';
                txContent.style.display = 'block';
                displayWalletTransactions();
            }
        }
        
        function displayWalletTransactions() {
            if (!currentDetailWallet) return;
            
            const container = document.getElementById('detailTxContent');
            const addrLower = currentDetailWallet.address.toLowerCase();
            
            console.log('ğŸ” displayWalletTransactions for:', addrLower.slice(0,10));
            console.log('ğŸ“¦ walletTransactions keys:', Object.keys(walletTransactions));
            
            // Carica da localStorage se non in memoria
            if (!walletTransactions[addrLower]) {
                console.log('ğŸ“‚ Not in memory, loading from localStorage...');
                loadWalletTransactions();
                console.log('ğŸ“¦ After load, keys:', Object.keys(walletTransactions));
            }
            
            const txData = walletTransactions[addrLower];
            console.log('ğŸ“Š txData:', txData ? `native=${txData.nativeTx?.length}, token=${txData.tokenTx?.length}` : 'NULL');
            
            if (!txData || ((txData.nativeTx?.length || 0) === 0 && (txData.tokenTx?.length || 0) === 0)) {
                container.innerHTML = `
                    <div class="card">
                        <div class="empty-state">
                            <div class="icon">ğŸ“­</div>
                            <h3>Nessuna transazione</h3>
                            <p style="color:var(--text-secondary);">Scansiona il wallet per scaricare le transazioni</p>
                            <p style="color:var(--yellow);font-size:12px;margin-top:12px;">
                                âš ï¸ Moralis supporta: Ethereum, BSC, Polygon, Arbitrum, Base, Cronos<br>
                                PulseChain e Solana non sono supportati.
                            </p>
                        </div>
                    </div>`;
                return;
            }
            
            // Combina tutte le tx
            const allTx = [
                ...txData.nativeTx.map(tx => ({ ...tx, type: 'native' })),
                ...txData.tokenTx.map(tx => ({ ...tx, type: 'token' }))
            ].sort((a, b) => new Date(b.d) - new Date(a.d));
            
            // Raggruppa per CHAIN
            const byChain = {};
            for (const tx of allTx) {
                const chain = tx.c || 'unknown';
                if (!byChain[chain]) byChain[chain] = [];
                byChain[chain].push(tx);
            }
            
            // Raggruppa per anno (per stats)
            const byYear = {};
            for (const tx of allTx) {
                const year = tx.d?.slice(0, 4) || '????';
                if (!byYear[year]) byYear[year] = [];
                byYear[year].push(tx);
            }
            
            // STATS PER ANNO
            let html = '<div class="card" style="margin-bottom:16px;"><div class="card-header"><div class="card-title">ğŸ“Š Transazioni per Anno</div></div>';
            html += '<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(80px,1fr));gap:8px;padding:12px;">';
            
            for (const year of Object.keys(byYear).sort().reverse()) {
                const yearTx = byYear[year];
                const inCount = yearTx.filter(tx => tx.t === 'in').length;
                const outCount = yearTx.filter(tx => tx.t === 'out').length;
                html += `
                    <div style="background:var(--bg-primary);padding:10px;border-radius:8px;text-align:center;">
                        <div style="font-weight:700;font-size:16px;">${year}</div>
                        <div style="font-size:11px;color:var(--text-secondary);">${yearTx.length} tx</div>
                        <div style="font-size:10px;margin-top:2px;">
                            <span style="color:var(--green);">â†“${inCount}</span> 
                            <span style="color:var(--red);">â†‘${outCount}</span>
                        </div>
                    </div>`;
            }
            html += '</div></div>';
            
            // TRANSAZIONI PER CHAIN
            for (const chainKey of Object.keys(byChain).sort()) {
                const chainTx = byChain[chainKey];
                const chain = CHAINS[chainKey];
                const chainName = chain?.name || chainKey.toUpperCase();
                const chainColor = chain?.color || '#666';
                
                // Mostra solo ultime 50 per chain
                const recentChainTx = chainTx.slice(0, 50);
                
                html += `
                    <div class="card" style="margin-bottom:16px;">
                        <div class="card-header">
                            <div class="card-title" style="display:flex;align-items:center;gap:8px;">
                                <span style="width:12px;height:12px;border-radius:50%;background:${chainColor};"></span>
                                ${chainName}
                            </div>
                            <div style="font-size:12px;color:var(--text-secondary);">${chainTx.length} transazioni</div>
                        </div>
                        <div style="max-height:300px;overflow-y:auto;">
                            <table class="holdings-table">
                                <thead><tr><th>DATA</th><th>TIPO</th><th>TOKEN</th><th>QUANTITÃ€</th></tr></thead>
                                <tbody>`;
                
                for (const tx of recentChainTx) {
                    const isIn = tx.t === 'in';
                    const color = isIn ? 'var(--green)' : 'var(--red)';
                    const arrow = isIn ? 'â†“' : 'â†‘';
                    const formattedAmt = tx.a >= 1000000 
                        ? (tx.a / 1000000).toFixed(2) + 'M'
                        : tx.a >= 1000 
                            ? (tx.a / 1000).toFixed(2) + 'K'
                            : tx.a < 0.0001 
                                ? tx.a.toExponential(2)
                                : tx.a.toFixed(4);
                    
                    html += `
                        <tr>
                            <td style="font-size:11px;">${tx.d || '-'}</td>
                            <td style="color:${color};font-weight:600;font-size:12px;">${arrow} ${isIn ? 'IN' : 'OUT'}</td>
                            <td style="font-weight:500;">${tx.s || '???'}</td>
                            <td class="text-right text-mono" style="color:${color};font-size:12px;">${isIn ? '+' : '-'}${formattedAmt}</td>
                        </tr>`;
                }
                
                html += '</tbody></table></div>';
                
                if (chainTx.length > 50) {
                    html += `<div style="text-align:center;padding:8px;font-size:11px;color:var(--text-secondary);">
                        ... e altre ${chainTx.length - 50} transazioni
                    </div>`;
                }
                
                html += '</div>';
            }
            
            // Info download
            if (txData.lastDownload) {
                const downloadDate = new Date(txData.lastDownload).toLocaleString('it-IT');
                html += `<div style="text-align:center;padding:12px;font-size:12px;color:var(--text-secondary);">
                    ğŸ“¥ Scaricate il ${downloadDate} | Totale: ${allTx.length} transazioni
                </div>`;
            }
            
            container.innerHTML = html;
        }
        
        async function scanDetailWallet() {
            if (!currentDetailWallet) return;
            
            const etherscanKey = apiKeys.etherscan;
            if (!etherscanKey && !apiKeys.moralis) { 
                alert('Configura almeno una API in API Connect'); 
                return; 
            }
            if (selectedChains.length === 0) { alert('Seleziona almeno una chain nella Dashboard'); return; }
            
            // Scan del wallet
            const addr = currentDetailWallet.address;
            const results = [];
            
            await fetchEurUsd();
            await fetchNativePrices();
            
            for (const chainKey of selectedChains) {
                const chain = CHAINS[chainKey];
                
                // Try Moralis first for supported chains
                if (apiKeys.moralis && MORALIS_CHAINS[chainKey]) {
                    const moralisResults = await scanWithMoralis(addr, chainKey);
                    if (moralisResults && moralisResults.length > 0) {
                        results.push(...moralisResults);
                        await new Promise(r => setTimeout(r, 100));
                        continue;
                    }
                }
                
                // Fallback to Etherscan/PulseScan/Solana RPC
                if (!etherscanKey && chainKey !== 'pulse' && chainKey !== 'solana') {
                    continue;
                }
                
                // Native balance
                const nativeWei = await fetchNativeBalance(addr, etherscanKey, chain.id, chainKey);
                const nativeDecimals = chainKey === 'solana' ? 9 : 18;
                const nativeBal = Number(nativeWei) / Math.pow(10, nativeDecimals);
                const nativePrice = NATIVE_PRICES[chain.symbol] || NATIVE_PRICES.ETH;
                
                if (nativeBal > 0.0001) {
                    results.push({
                        symbol: chain.symbol,
                        name: `${chain.symbol} (${chain.name})`,
                        balance: nativeBal,
                        price: nativePrice,
                        valueUSD: nativeBal * nativePrice,
                        contract: `native-${chainKey}`,
                        logo: TOKEN_ICONS[chain.symbol],
                        chain: chainKey
                    });
                }
                
                // Token balances
                const tokens = await fetchTokenTransfers(addr, etherscanKey, chain.id, chainKey);
                
                for (const [c, t] of Object.entries(tokens)) {
                    if (isBlacklisted(c) || isSpam(t.name, t.symbol) || t.balance <= 0n) continue;
                    
                    const bal = Number(t.balance) / Math.pow(10, t.decimals);
                    let price = 0, logo = TOKEN_ICONS[t.symbol?.toUpperCase()] || null;
                    
                    const pd = await fetchTokenPrice(c, chain.dex);
                    if (pd) { price = pd.price; if (pd.logo) logo = pd.logo; }
                    
                    results.push({
                        symbol: t.symbol,
                        name: t.name,
                        balance: bal,
                        price,
                        valueUSD: bal * price,
                        contract: c,
                        logo,
                        chain: chainKey
                    });
                    
                    await new Promise(r => setTimeout(r, 150));
                }
                
                await new Promise(r => setTimeout(r, 200));
            }
            
            // Salva risultati
            walletResults[addr.toLowerCase()] = {
                name: currentDetailWallet.name,
                results: results,
                scannedAt: Date.now()
            };
            
            // Download transazioni se Moralis disponibile
            // Download transazioni se API disponibile (Moralis o Etherscan)
            if ((apiKeys.moralis || apiKeys.etherscan) && addr.startsWith('0x')) {
                const scanDateEl = document.getElementById('detailScanDate');
                
                // Progress bar HTML
                scanDateEl.innerHTML = `
                    <div style="margin-top:8px;">
                        <div style="display:flex;align-items:center;gap:8px;margin-bottom:4px;">
                            <div class="spinner" style="width:16px;height:16px;border:2px solid var(--accent);border-top-color:transparent;border-radius:50%;animation:spin 1s linear infinite;"></div>
                            <span id="txProgressText">ğŸ“¥ Download transazioni...</span>
                        </div>
                        <div style="height:6px;background:var(--bg-primary);border-radius:3px;overflow:hidden;">
                            <div id="txProgressBar" style="width:0%;height:100%;background:var(--accent);transition:width 0.3s;"></div>
                        </div>
                    </div>
                `;
                
                let progress = 0;
                const txData = await downloadWalletTransactions(addr, (status) => {
                    progress += 2;
                    if (progress > 95) progress = 95;
                    document.getElementById('txProgressText').textContent = `ğŸ“¥ ${status}`;
                    document.getElementById('txProgressBar').style.width = `${progress}%`;
                });
                
                walletTransactions[addr.toLowerCase()] = txData;
                saveWalletTransactions();
                
                const txCount = txData.nativeTx.length + txData.tokenTx.length;
                scanDateEl.innerHTML = `<span style="color:var(--green);">âœ… ${txCount} transazioni scaricate</span>`;
            }
            
            // Aggiorna display
            displayWalletDetail();
            updateWalletsList();
            aggregateAndDisplay();
            saveToFirebase();
        }
        
        function initChainSelector() {
            const container = document.getElementById('chainSelector');
            let html = '';
            for (const [key, chain] of Object.entries(CHAINS)) {
                const active = selectedChains.includes(key) ? 'active' : '';
                html += `<button class="chain-btn ${active}" data-chain="${key}" onclick="toggleChain('${key}')">
                    <span class="chain-dot" style="background:${chain.color}"></span>${chain.name}
                </button>`;
            }
            container.innerHTML = html;
        }
        
        function toggleChain(key) {
            const idx = selectedChains.indexOf(key);
            if (idx >= 0) selectedChains.splice(idx, 1);
            else selectedChains.push(key);
            localStorage.setItem('cryptofolio_chains', JSON.stringify(selectedChains));
            initChainSelector();
            saveToFirebase();
        }
        
        function loadSettings() {
            const w = localStorage.getItem('cryptofolio_wallet');
            const oldKey = localStorage.getItem('etherscan_api_key');
            
            if (w) document.getElementById('walletAddress').value = w;
            
            // Backward compatibility: migra vecchia API key a nuovo sistema
            if (oldKey && !apiKeys.etherscan) {
                apiKeys.etherscan = oldKey;
                localStorage.setItem('cryptofolio_apikeys', JSON.stringify(apiKeys));
                localStorage.removeItem('etherscan_api_key'); // Rimuovi vecchia chiave
            }
        }
        
        function saveSettings() {
            const w = document.getElementById('walletAddress').value.trim();
            if (w) localStorage.setItem('cryptofolio_wallet', w);
            saveToFirebase();
        }
        
        // ==================== API ====================
        async function fetchEurUsd() { 
            try { 
                const r = await fetch('https://api.exchangerate-api.com/v4/latest/USD'); 
                const d = await r.json(); 
                EUR_USD = d.rates.EUR; 
                document.getElementById('eurUsdRate').textContent = EUR_USD.toFixed(4); 
            } catch(e) { EUR_USD = 0.849; } 
        }
        
        async function fetchNativePrices() {
            try {
                const r = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=ethereum,binancecoin,matic-network,pulsechain,solana,crypto-com-chain&vs_currencies=usd');
                const d = await r.json();
                NATIVE_PRICES.ETH = d.ethereum?.usd || 3000;
                NATIVE_PRICES.BNB = d.binancecoin?.usd || 600;
                NATIVE_PRICES.MATIC = d['matic-network']?.usd || 0.4;
                NATIVE_PRICES.PLS = d.pulsechain?.usd || 0.00003;
                NATIVE_PRICES.SOL = d.solana?.usd || 150;
                NATIVE_PRICES.CRO = d['crypto-com-chain']?.usd || 0.09;
            } catch(e) {
                NATIVE_PRICES.ETH = 3000; NATIVE_PRICES.BNB = 600; NATIVE_PRICES.MATIC = 0.4;
                NATIVE_PRICES.PLS = 0.00003; NATIVE_PRICES.SOL = 150; NATIVE_PRICES.CRO = 0.09;
            }
        }
        
        async function fetchNativeBalance(addr, apiKey, chainId, chainKey) {
            try {
                // Solana - usa RPC
                if (chainKey === 'solana') {
                    const r = await fetch('https://api.mainnet-beta.solana.com', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            jsonrpc: '2.0', id: 1, method: 'getBalance', params: [addr]
                        })
                    });
                    const d = await r.json();
                    if (d.result?.value) return BigInt(d.result.value);
                    return 0n;
                }
                
                // PulseChain - usa PulseScan API
                if (chainKey === 'pulse') {
                    const r = await fetch(`https://api.scan.pulsechain.com/api?module=account&action=balance&address=${addr}`);
                    const d = await r.json();
                    if (d.status === '1') return BigInt(d.result);
                    return 0n;
                }
                
                // EVM chains - usa Etherscan V2
                const r = await fetch(`https://api.etherscan.io/v2/api?chainid=${chainId}&module=account&action=balance&address=${addr}&tag=latest&apikey=${apiKey}`);
                const d = await r.json();
                if (d.status === '1') return BigInt(d.result);
            } catch(e) { console.error(`Balance error ${chainKey}:`, e); }
            return 0n;
        }
        
        async function fetchTokenTransfers(addr, apiKey, chainId, chainKey) {
            try {
                // Solana - usa RPC per token SPL
                if (chainKey === 'solana') {
                    const r = await fetch('https://api.mainnet-beta.solana.com', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            jsonrpc: '2.0', id: 1, 
                            method: 'getTokenAccountsByOwner',
                            params: [addr, { programId: 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' }, { encoding: 'jsonParsed' }]
                        })
                    });
                    const d = await r.json();
                    const bal = {};
                    if (d.result?.value) {
                        for (const acc of d.result.value) {
                            const info = acc.account?.data?.parsed?.info;
                            if (info && info.tokenAmount?.uiAmount > 0) {
                                const mint = info.mint;
                                bal[mint] = {
                                    symbol: 'SPL', // Will try to get from DexScreener
                                    name: 'Solana Token',
                                    decimals: info.tokenAmount.decimals,
                                    balance: BigInt(info.tokenAmount.amount)
                                };
                            }
                        }
                    }
                    return bal;
                }
                
                // PulseChain - usa PulseScan API
                if (chainKey === 'pulse') {
                    const r = await fetch(`https://api.scan.pulsechain.com/api?module=account&action=tokentx&address=${addr}&startblock=0&endblock=99999999&sort=asc`);
                    const d = await r.json();
                    if (d.status === '1' && d.result) {
                        const bal = {}, w = addr.toLowerCase();
                        for (const tx of d.result) {
                            const c = tx.contractAddress.toLowerCase();
                            if (!bal[c]) bal[c] = { symbol: tx.tokenSymbol, name: tx.tokenName, decimals: parseInt(tx.tokenDecimal||'18'), balance: 0n };
                            const v = BigInt(tx.value||'0');
                            if (tx.to.toLowerCase() === w) bal[c].balance += v;
                            if (tx.from.toLowerCase() === w) bal[c].balance -= v;
                        }
                        return bal;
                    }
                    return {};
                }
                
                // EVM chains - usa Etherscan V2
                const r = await fetch(`https://api.etherscan.io/v2/api?chainid=${chainId}&module=account&action=tokentx&address=${addr}&startblock=0&endblock=99999999&sort=asc&apikey=${apiKey}`);
                const d = await r.json();
                if (d.status === '1' && d.result) {
                    const bal = {}, w = addr.toLowerCase();
                    for (const tx of d.result) {
                        const c = tx.contractAddress.toLowerCase();
                        if (!bal[c]) bal[c] = { symbol: tx.tokenSymbol, name: tx.tokenName, decimals: parseInt(tx.tokenDecimal||'18'), balance: 0n };
                        const v = BigInt(tx.value||'0');
                        if (tx.to.toLowerCase() === w) bal[c].balance += v;
                        if (tx.from.toLowerCase() === w) bal[c].balance -= v;
                    }
                    return bal;
                }
            } catch(e) { console.error(`Token error ${chainKey}:`, e); }
            return {};
        }
        
        async function fetchTokenPrice(contract, dexChain) {
            try {
                const r = await fetch(`https://api.dexscreener.com/latest/dex/tokens/${contract}`);
                const d = await r.json();
                if (d.pairs?.length) {
                    const p = d.pairs.filter(x => x.chainId === dexChain).sort((a,b) => (b.liquidity?.usd||0) - (a.liquidity?.usd||0))[0];
                    if (p) return { price: parseFloat(p.priceUsd), logo: p.info?.imageUrl };
                }
            } catch(e) {}
            return null;
        }
        
        // ==================== SCAN ====================
        async function scanWallet() {
            const addr = document.getElementById('walletAddress').value.trim();
            const etherscanKey = apiKeys.etherscan || document.getElementById('apiKey').value.trim();
            
            if (!addr) { log('âŒ Inserisci wallet address', 'error'); return; }
            if (!etherscanKey && !apiKeys.moralis) { 
                log('âŒ Configura almeno una API (Moralis o Etherscan) in API Connect', 'error'); 
                return; 
            }
            if (selectedChains.length === 0) { log('âŒ Seleziona almeno una chain', 'error'); return; }
            
            // Detect wallet type
            const isSolanaWallet = !addr.startsWith('0x') && /^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(addr);
            
            document.getElementById('statusLog').innerHTML = '';
            log(`ğŸš€ Scan Multi-Chain...`);
            log(`ğŸ“ ${addr.slice(0,8)}...${addr.slice(-6)} ${isSolanaWallet ? '(Solana)' : '(EVM)'}`);
            log(`â›“ï¸ ${selectedChains.map(c => CHAINS[c].name).join(', ')}`);
            
            // Mostra quale API sarÃ  usata
            if (isSolanaWallet) {
                log(`ğŸŸ£ Usando Solana RPC`, 'info');
            } else if (apiKeys.moralis) {
                log(`ğŸŸ¢ Usando Moralis API (veloce)`, 'info');
            } else {
                log(`ğŸ”µ Usando Etherscan API`, 'info');
            }
            
            saveSettings();
            
            try {
                await fetchEurUsd();
                await fetchNativePrices();
                log(`ğŸ’° ETH: $${formatNum(NATIVE_PRICES.ETH)} | BNB: $${formatNum(NATIVE_PRICES.BNB)} | SOL: $${formatNum(NATIVE_PRICES.SOL)}`, 'info');
                
                const results = [];
                
                for (const chainKey of selectedChains) {
                    const chain = CHAINS[chainKey];
                    
                    // Skip incompatible chains
                    if (isSolanaWallet && chainKey !== 'solana') {
                        continue; // Wallet Solana puÃ² solo scansionare Solana
                    }
                    if (!isSolanaWallet && chainKey === 'solana') {
                        continue; // Wallet EVM non puÃ² scansionare Solana
                    }
                    
                    log(`ğŸ“¡ ${chain.name}...`);
                    
                    // SOLANA: Use Helius API if available
                    if (chainKey === 'solana' && apiKeys.helius) {
                        log(`  ğŸŸ£ Helius API...`, 'info');
                        const heliusResults = await fetchWithHelius(addr);
                        if (heliusResults && heliusResults.length > 0) {
                            results.push(...heliusResults);
                            const solToken = heliusResults.find(t => t.symbol === 'SOL');
                            if (solToken) {
                                log(`  SOL: ${formatNum(solToken.balance, 4)} ($${formatNum(solToken.valueUSD)})`, 'success');
                            }
                            const tokenCount = heliusResults.filter(t => t.symbol !== 'SOL').length;
                            if (tokenCount > 0) log(`  ${tokenCount} SPL tokens`, 'info');
                            continue;
                        } else {
                            log(`  âš ï¸ Helius: nessun risultato`, 'warning');
                        }
                    }
                    
                    // Try Moralis first for supported chains
                    if (apiKeys.moralis && MORALIS_CHAINS[chainKey]) {
                        log(`  âš¡ Moralis...`, 'info');
                        const moralisResults = await scanWithMoralis(addr, chainKey);
                        if (moralisResults && moralisResults.length > 0) {
                            results.push(...moralisResults);
                            const nativeToken = moralisResults.find(t => t.contract.startsWith('native-'));
                            if (nativeToken) {
                                log(`  ${nativeToken.symbol}: ${formatNum(nativeToken.balance, 4)} ($${formatNum(nativeToken.valueUSD)})`, 'success');
                            }
                            const tokenCount = moralisResults.filter(t => !t.contract.startsWith('native-')).length;
                            if (tokenCount > 0) log(`  ${tokenCount} tokens`, 'info');
                            await new Promise(r => setTimeout(r, 100));
                            continue;
                        }
                    }
                    
                    // Fallback to Etherscan/PulseScan/Solana RPC
                    if (!etherscanKey && chainKey !== 'pulse' && chainKey !== 'solana') {
                        log(`  âš ï¸ Skip - nessuna API key`, 'warning');
                        continue;
                    }
                    
                    // Skip Solana RPC fallback if no Helius (too unreliable)
                    if (chainKey === 'solana' && !apiKeys.helius) {
                        log(`  âš ï¸ Configura Helius API per Solana`, 'warning');
                        continue;
                    }
                    
                    // Native balance
                    const nativeWei = await fetchNativeBalance(addr, etherscanKey, chain.id, chainKey);
                    const nativeDecimals = chainKey === 'solana' ? 9 : 18;
                    const nativeBal = Number(nativeWei) / Math.pow(10, nativeDecimals);
                    const nativePrice = NATIVE_PRICES[chain.symbol] || NATIVE_PRICES.ETH;
                    
                    if (nativeBal > 0.0001) {
                        results.push({
                            symbol: chain.symbol,
                            name: `${chain.symbol} (${chain.name})`,
                            balance: nativeBal,
                            price: nativePrice,
                            valueUSD: nativeBal * nativePrice,
                            contract: `native-${chainKey}`,
                            logo: TOKEN_ICONS[chain.symbol],
                            chain: chainKey
                        });
                        log(`  ${chain.symbol}: ${formatNum(nativeBal, 4)} ($${formatNum(nativeBal * nativePrice)})`, 'success');
                    }
                    
                    // Token balances
                    const tokens = await fetchTokenTransfers(addr, etherscanKey, chain.id, chainKey);
                    let tokenCount = 0;
                    
                    for (const [c, t] of Object.entries(tokens)) {
                        if (isBlacklisted(c) || isSpam(t.name, t.symbol) || t.balance <= 0n) continue;
                        
                        const bal = Number(t.balance) / Math.pow(10, t.decimals);
                        let price = 0, logo = TOKEN_ICONS[t.symbol?.toUpperCase()] || null;
                        
                        const pd = await fetchTokenPrice(c, chain.dex);
                        if (pd) { price = pd.price; if (pd.logo) logo = pd.logo; }
                        
                        results.push({
                            symbol: t.symbol,
                            name: t.name,
                            balance: bal,
                            price,
                            valueUSD: bal * price,
                            contract: c,
                            logo,
                            chain: chainKey
                        });
                        
                        tokenCount++;
                        if (price > 0 && bal * price >= 1) {
                            log(`  ${t.symbol}: $${formatNum(bal * price)}`, 'success');
                        }
                        
                        await new Promise(r => setTimeout(r, 150));
                    }
                    
                    if (tokenCount > 0) log(`  ${tokenCount} tokens`, 'info');
                    await new Promise(r => setTimeout(r, 200));
                }
                
                results.sort((a, b) => b.valueUSD - a.valueUSD);
                
                // Trova nome wallet se salvato
                const walletName = savedWallets.find(w => w.address.toLowerCase() === addr.toLowerCase())?.name || 'Wallet';
                
                // Salva risultati per questo wallet
                walletResults[addr.toLowerCase()] = {
                    name: walletName,
                    results: results,
                    scannedAt: Date.now()
                };
                
                // Aggrega tutti i wallet per display
                aggregateAndDisplay();
                
                // Salva risultati su Firebase
                saveToFirebase();
                
                log('âœ… Completato!', 'success');
                document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString('it-IT');
                
            } catch(e) {
                log(`âŒ Errore: ${e.message}`, 'error');
                console.error(e);
            }
        }
        
        // ==================== MULTI-WALLET ====================
        function aggregateAndDisplay() {
            // Combina risultati di tutti i wallet
            const allResults = [];
            
            for (const [addr, data] of Object.entries(walletResults)) {
                for (const token of data.results) {
                    // Aggiungi info wallet al token
                    allResults.push({
                        ...token,
                        walletAddress: addr,
                        walletName: data.name
                    });
                }
            }
            
            // Ordina per valore
            allResults.sort((a, b) => b.valueUSD - a.valueUSD);
            lastScanResults = allResults;
            
            displayResults(allResults);
        }
        
        async function scanAllWallets() {
            const etherscanKey = apiKeys.etherscan;
            if (!etherscanKey && !apiKeys.moralis) { 
                log('âŒ Configura almeno una API (Moralis o Etherscan) in API Connect', 'error'); 
                return; 
            }
            if (savedWallets.length === 0) { log('âŒ Nessun wallet salvato. Vai su Wallets per aggiungerli.', 'error'); return; }
            if (selectedChains.length === 0) { log('âŒ Seleziona almeno una chain', 'error'); return; }
            
            document.getElementById('statusLog').innerHTML = '';
            log(`ğŸš€ Scan di ${savedWallets.length} wallet...`);
            
            // Mostra quale API sarÃ  usata
            if (apiKeys.moralis) {
                log(`ğŸŸ¢ Usando Moralis API (veloce)`, 'info');
            } else {
                log(`ğŸ”µ Usando Etherscan API`, 'info');
            }
            
            // Reset risultati
            walletResults = {};
            
            await fetchEurUsd();
            await fetchNativePrices();
            log(`ğŸ’° ETH: $${formatNum(NATIVE_PRICES.ETH)} | BNB: $${formatNum(NATIVE_PRICES.BNB)} | SOL: $${formatNum(NATIVE_PRICES.SOL)}`, 'info');
            
            for (let i = 0; i < savedWallets.length; i++) {
                const wallet = savedWallets[i];
                log(`\nğŸ“ [${i+1}/${savedWallets.length}] ${wallet.name}`);
                log(`   ${wallet.address.slice(0,8)}...${wallet.address.slice(-6)}`);
                
                // Detect wallet type
                const isSolanaWallet = wallet.type === 'solana' || (!wallet.address.startsWith('0x') && /^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(wallet.address));
                
                const results = [];
                
                for (const chainKey of selectedChains) {
                    const chain = CHAINS[chainKey];
                    
                    // Skip incompatible chains
                    if (isSolanaWallet && chainKey !== 'solana') {
                        continue; // Wallet Solana puÃ² solo scansionare Solana
                    }
                    if (!isSolanaWallet && chainKey === 'solana') {
                        continue; // Wallet EVM non puÃ² scansionare Solana
                    }
                    
                    log(`   â›“ï¸ ${chain.name}...`);
                    
                    // SOLANA: Use Helius API if available
                    if (chainKey === 'solana' && apiKeys.helius) {
                        const heliusResults = await fetchWithHelius(wallet.address);
                        if (heliusResults && heliusResults.length > 0) {
                            results.push(...heliusResults);
                            const solToken = heliusResults.find(t => t.symbol === 'SOL');
                            if (solToken) {
                                log(`      SOL: ${formatNum(solToken.balance, 4)} ($${formatNum(solToken.valueUSD)})`, 'success');
                            }
                            for (const t of heliusResults.filter(t => t.symbol !== 'SOL' && t.valueUSD >= 1)) {
                                log(`      ${t.symbol}: $${formatNum(t.valueUSD)}`, 'success');
                            }
                            continue;
                        }
                    }
                    
                    // Skip Solana if no Helius
                    if (chainKey === 'solana' && !apiKeys.helius) {
                        log(`      âš ï¸ Configura Helius per Solana`, 'warning');
                        continue;
                    }
                    
                    // Try Moralis first for supported chains
                    if (apiKeys.moralis && MORALIS_CHAINS[chainKey]) {
                        const moralisResults = await scanWithMoralis(wallet.address, chainKey);
                        if (moralisResults && moralisResults.length > 0) {
                            results.push(...moralisResults);
                            const nativeToken = moralisResults.find(t => t.contract.startsWith('native-'));
                            if (nativeToken) {
                                log(`      ${nativeToken.symbol}: ${formatNum(nativeToken.balance, 4)} ($${formatNum(nativeToken.valueUSD)})`, 'success');
                            }
                            const tokenCount = moralisResults.filter(t => !t.contract.startsWith('native-') && t.valueUSD >= 1).length;
                            for (const t of moralisResults.filter(t => !t.contract.startsWith('native-') && t.valueUSD >= 1)) {
                                log(`      ${t.symbol}: $${formatNum(t.valueUSD)}`, 'success');
                            }
                            await new Promise(r => setTimeout(r, 100));
                            continue;
                        }
                    }
                    
                    // Fallback to Etherscan/PulseScan
                    if (!etherscanKey && chainKey !== 'pulse') {
                        continue; // Skip silently
                    }
                    
                    // Native balance
                    const nativeWei = await fetchNativeBalance(wallet.address, etherscanKey, chain.id, chainKey);
                    const nativeDecimals = chainKey === 'solana' ? 9 : 18;
                    const nativeBal = Number(nativeWei) / Math.pow(10, nativeDecimals);
                    const nativePrice = NATIVE_PRICES[chain.symbol] || NATIVE_PRICES.ETH;
                    
                    if (nativeBal > 0.0001) {
                        results.push({
                            symbol: chain.symbol,
                            name: `${chain.symbol} (${chain.name})`,
                            balance: nativeBal,
                            price: nativePrice,
                            valueUSD: nativeBal * nativePrice,
                            contract: `native-${chainKey}`,
                            logo: TOKEN_ICONS[chain.symbol],
                            chain: chainKey
                        });
                        log(`      ${chain.symbol}: ${formatNum(nativeBal, 4)} ($${formatNum(nativeBal * nativePrice)})`, 'success');
                    }
                    
                    // Token balances
                    const tokens = await fetchTokenTransfers(wallet.address, etherscanKey, chain.id, chainKey);
                    
                    for (const [c, t] of Object.entries(tokens)) {
                        if (isBlacklisted(c) || isSpam(t.name, t.symbol) || t.balance <= 0n) continue;
                        
                        const bal = Number(t.balance) / Math.pow(10, t.decimals);
                        let price = 0, logo = TOKEN_ICONS[t.symbol?.toUpperCase()] || null;
                        
                        const pd = await fetchTokenPrice(c, chain.dex);
                        if (pd) { price = pd.price; if (pd.logo) logo = pd.logo; }
                        
                        results.push({
                            symbol: t.symbol,
                            name: t.name,
                            balance: bal,
                            price,
                            valueUSD: bal * price,
                            contract: c,
                            logo,
                            chain: chainKey
                        });
                        
                        if (price > 0 && bal * price >= 1) {
                            log(`      ${t.symbol}: $${formatNum(bal * price)}`, 'success');
                        }
                        
                        await new Promise(r => setTimeout(r, 150));
                    }
                    
                    await new Promise(r => setTimeout(r, 200));
                }
                
                // Salva risultati wallet
                walletResults[wallet.address.toLowerCase()] = {
                    name: wallet.name,
                    results: results,
                    scannedAt: Date.now()
                };
                
                const walletTotal = results.reduce((s, t) => s + t.valueUSD, 0);
                log(`   ğŸ’° Totale ${wallet.name}: $${formatNum(walletTotal)}`, 'success');
                
                // Download transazioni se wallet EVM e API disponibile (Moralis o Etherscan)
                if (!isSolanaWallet && (apiKeys.moralis || apiKeys.etherscan)) {
                    const addrLower = wallet.address.toLowerCase();
                    const existingTx = walletTransactions[addrLower];
                    const txAge = existingTx ? (Date.now() - (existingTx.lastDownload || 0)) / 3600000 : 999;
                    
                    // Scarica solo se > 24h o non esistono
                    if (txAge > 24) {
                        log(`   ğŸ“¥ Download transazioni...`);
                        const txData = await downloadWalletTransactions(wallet.address, (status) => {
                            // Progress silenzioso
                        });
                        walletTransactions[addrLower] = txData;
                        const txCount = txData.nativeTx.length + txData.tokenTx.length;
                        log(`   âœ… ${txCount} transazioni scaricate`, 'success');
                    } else {
                        const txCount = getWalletTxCount(wallet.address);
                        log(`   ğŸ“‚ ${txCount} transazioni in cache`, 'info');
                    }
                }
            }
            
            // Aggrega e mostra
            aggregateAndDisplay();
            
            // Salva risultati su Firebase
            saveToFirebase();
            
            // Salva transazioni
            saveWalletTransactions();
            
            const grandTotal = Object.values(walletResults).reduce((sum, w) => 
                sum + w.results.reduce((s, t) => s + t.valueUSD, 0), 0);
            
            const totalTx = Object.values(walletTransactions).reduce((sum, w) => 
                sum + (w.nativeTx?.length || 0) + (w.tokenTx?.length || 0), 0);
            
            log(`\nğŸ‰ TOTALE PORTFOLIO: $${formatNum(grandTotal)} (â‚¬${formatNum(grandTotal * EUR_USD)})`, 'success');
            log(`ğŸ“œ ${totalTx} transazioni totali salvate`, 'info');
            document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString('it-IT');
        }
        
        function clearWalletResults() {
            walletResults = {};
            lastScanResults = [];
            displayResults([]);
            saveToFirebase();
            log('ğŸ—‘ï¸ Risultati cancellati', 'info');
        }
        
        // ==================== DISPLAY ====================
        function displayResults(results) {
            const visible = results.filter(t => !isBlacklisted(t.contract));
            const withVal = visible.filter(t => t.valueUSD >= 0.01);
            const walletsUSD = withVal.reduce((s, t) => s + t.valueUSD, 0);
            
            // Calcola totale exchange da CSV (usa anno piÃ¹ recente disponibile)
            let exchangeTotalEUR = 0;
            let exchangeNames = [];
            for (const exchId of Object.keys(exchangeData)) {
                const data = exchangeData[exchId];
                if (data && data.totals) {
                    // Prendi anno piÃ¹ recente con valore > 0
                    const latestYear = [2025, 2024, 2023, 2022, 2021].find(y => data.totals[y] > 0);
                    if (latestYear && data.totals[latestYear] > 0) {
                        exchangeTotalEUR += data.totals[latestYear];
                        const exchInfo = EXCHANGE_LIST.find(e => e.id === exchId);
                        if (exchInfo) exchangeNames.push(exchInfo.name);
                    }
                }
            }
            
            const totalUSD = walletsUSD + (exchangeTotalEUR / EUR_USD);
            const totalEUR = totalUSD * EUR_USD;
            
            document.getElementById('totalEUR').textContent = 'â‚¬' + formatEUR(totalEUR);
            document.getElementById('totalUSD').textContent = '$' + formatEUR(totalUSD) + ' USD';
            document.getElementById('tokenCount').textContent = withVal.length;
            
            // Aggiorna card Exchanges
            document.getElementById('exchangeTotalEUR').textContent = 'â‚¬' + formatEUR(exchangeTotalEUR);
            if (exchangeNames.length > 0) {
                document.getElementById('exchangeNames').textContent = exchangeNames.join(', ') + ' âœ“';
            } else {
                document.getElementById('exchangeNames').textContent = 'Nessuno';
            }
            
            // Conta wallet scansionati
            const scannedCount = Object.keys(walletResults).length;
            document.getElementById('scannedWallets').textContent = scannedCount;
            const walletNames = Object.values(walletResults).map(w => w.name).join(', ') || '-';
            document.getElementById('chainNames').textContent = walletNames.length > 30 ? walletNames.slice(0, 30) + '...' : walletNames;
            
            const container = document.getElementById('holdingsContent');
            if (!withVal.length) {
                container.innerHTML = '<div class="empty-state"><div class="icon">ğŸ“­</div><h3>Nessun token con valore</h3></div>';
                return;
            }
            
            let html = `<table class="holdings-table">
                <thead><tr><th>TOKEN</th><th>BALANCE</th><th>PREZZO</th><th>VALORE</th></tr></thead>
                <tbody>`;
            
            for (const t of withVal) {
                const chain = CHAINS[t.chain];
                const pct = totalUSD > 0 ? ((t.valueUSD / totalUSD) * 100).toFixed(1) : '0';
                const vEUR = t.valueUSD * EUR_USD;
                
                html += `<tr>
                    <td><div class="token-cell">
                        <button class="hide-btn" onclick="hideToken('${t.contract}','${t.symbol}')">âœ•</button>
                        <div class="token-icon">${t.logo ? `<img src="${t.logo}" onerror="this.parentElement.textContent='${t.symbol.slice(0,2)}'">` : t.symbol.slice(0,2)}</div>
                        <div class="token-info">
                            <div class="symbol">${t.symbol}<span class="chain-badge" style="background:${chain?.color || '#666'}20;color:${chain?.color || '#666'}">${t.chain}</span></div>
                            <div class="name">${t.name}${t.walletName ? ` <span style="color:var(--accent-light);font-size:10px;">â€¢ ${t.walletName}</span>` : ''}</div>
                        </div>
                    </div></td>
                    <td class="text-right text-mono">${formatNum(t.balance, 4)}</td>
                    <td class="text-right text-mono text-secondary">$${t.price > 0 ? formatNum(t.price, 6) : '-'}</td>
                    <td class="text-right">
                        <div class="text-mono" style="color:var(--green);">â‚¬${formatEUR(vEUR)}</div>
                        <div class="text-secondary" style="font-size:11px;">${pct}%</div>
                    </td>
                </tr>`;
            }
            
            html += '</tbody></table>';
            container.innerHTML = html;
            
            // Chart
            if (withVal.length > 0) renderChart(withVal, totalUSD);
        }
        
        function renderChart(tokens, total) {
            const ctx = document.getElementById('allocationChart').getContext('2d');
            if (allocationChart) allocationChart.destroy();
            
            const top5 = tokens.slice(0, 5);
            const others = tokens.slice(5);
            const othersVal = others.reduce((s, t) => s + t.valueUSD, 0);
            
            const labels = top5.map(t => t.symbol);
            const data = top5.map(t => t.valueUSD);
            if (othersVal > 0) { labels.push('Altri'); data.push(othersVal); }
            
            const colors = ['#6c5ce7', '#00cec9', '#ffeaa7', '#ff7675', '#74b9ff', '#a29bfe'];
            
            allocationChart = new Chart(ctx, {
                type: 'doughnut',
                data: { labels, datasets: [{ data, backgroundColor: colors.slice(0, data.length), borderWidth: 0 }] },
                options: { responsive: true, cutout: '70%', plugins: { legend: { position: 'bottom', labels: { color: '#a0a0a0', padding: 15 } } } }
            });
        }
        
        // ==================== TAX REPORT ====================
        async function calculateTaxReportAll() {
            const etherscanKey = apiKeys.etherscan;
            
            if (!etherscanKey) { 
                alert('Configura Etherscan API in API Connect prima! (necessaria per storico transazioni)'); 
                return; 
            }
            
            if (savedWallets.length === 0) {
                alert('Nessun wallet salvato! Vai su Wallets per aggiungerne.');
                return;
            }
            
            if (selectedChains.length === 0) {
                alert('Seleziona almeno una chain nella Dashboard!');
                return;
            }
            
            const container = document.getElementById('taxReportContent');
            const detailCard = document.getElementById('taxDetailCard');
            const detailContent = document.getElementById('taxDetailContent');
            
            container.innerHTML = `<div class="empty-state"><div class="icon">â³</div><h3>Caricamento ${savedWallets.length} wallet su ${selectedChains.length} chain...</h3></div>`;
            
            const years = [2021, 2022, 2023, 2024, 2025, 2026];
            
            // Totali aggregati per anno
            const grandTotals = {};
            for (const y of years) grandTotals[y] = { eur: 0, usd: 0 };
            
            // Dettagli per wallet
            const walletDetails = [];
            
            // Chain native symbols
            const CHAIN_NATIVE = {
                eth: 'ETH', bsc: 'BNB', polygon: 'MATIC', arbitrum: 'ETH', 
                optimism: 'ETH', base: 'ETH', pulse: 'PLS', solana: 'SOL'
            };
            
            try {
                for (let wi = 0; wi < savedWallets.length; wi++) {
                    const wallet = savedWallets[wi];
                    const addr = wallet.address;
                    const walletLower = addr.toLowerCase();
                    
                    const balances = {};
                    const allTokens = {};
                    for (const y of years) balances[y] = {};
                    
                    for (const chainKey of selectedChains) {
                        const chain = CHAINS[chainKey];
                        const nativeSym = CHAIN_NATIVE[chainKey];
                        
                        container.innerHTML = `<div class="empty-state"><div class="icon">â³</div><h3>Wallet ${wi + 1}/${savedWallets.length}: ${wallet.name}<br><small style="color:var(--text-secondary);">${chain.name}...</small></h3></div>`;
                        
                        let nativeTx = [], internalTx = [], tokenTx = [];
                        
                        // Fetch transactions based on chain type
                        if (chainKey === 'pulse') {
                            // PulseChain - use PulseScan
                            const [nRes, tRes] = await Promise.all([
                                fetch(`https://api.scan.pulsechain.com/api?module=account&action=txlist&address=${addr}&startblock=0&endblock=99999999&sort=asc`).then(r => r.json()),
                                fetch(`https://api.scan.pulsechain.com/api?module=account&action=tokentx&address=${addr}&startblock=0&endblock=99999999&sort=asc`).then(r => r.json())
                            ]);
                            nativeTx = nRes.status === '1' ? nRes.result : [];
                            tokenTx = tRes.status === '1' ? tRes.result : [];
                        } else if (chainKey === 'solana') {
                            // Solana - skip for now (no easy historical API)
                            continue;
                        } else {
                            // EVM chains - use Etherscan V2
                            const [nRes, iRes, tRes] = await Promise.all([
                                fetch(`https://api.etherscan.io/v2/api?chainid=${chain.id}&module=account&action=txlist&address=${addr}&startblock=0&endblock=99999999&sort=asc&apikey=${etherscanKey}`).then(r => r.json()),
                                fetch(`https://api.etherscan.io/v2/api?chainid=${chain.id}&module=account&action=txlistinternal&address=${addr}&startblock=0&endblock=99999999&sort=asc&apikey=${etherscanKey}`).then(r => r.json()),
                                fetch(`https://api.etherscan.io/v2/api?chainid=${chain.id}&module=account&action=tokentx&address=${addr}&startblock=0&endblock=99999999&sort=asc&apikey=${etherscanKey}`).then(r => r.json())
                            ]);
                            nativeTx = nRes.status === '1' ? nRes.result : [];
                            internalTx = iRes.status === '1' ? iRes.result : [];
                            tokenTx = tRes.status === '1' ? tRes.result : [];
                        }
                        
                        // Get tokens from this chain
                        for (const tx of tokenTx) {
                            const sym = tx.tokenSymbol?.toUpperCase();
                            const c = tx.contractAddress.toLowerCase();
                            const key = `${chainKey}:${c}`;
                            if (!allTokens[key]) {
                                allTokens[key] = { 
                                    symbol: tx.tokenSymbol, 
                                    decimals: parseInt(tx.tokenDecimal || '18'),
                                    chain: chainKey,
                                    chainName: chain.name
                                };
                            }
                        }
                        
                        // Calculate native balance per year
                        for (const y of years) {
                            const ts = new Date(`${y + 1}-01-01T00:00:00Z`).getTime() / 1000;
                            let bal = 0n;
                            
                            for (const tx of nativeTx) {
                                if (parseInt(tx.timeStamp) >= ts || tx.isError === '1') continue;
                                const v = BigInt(tx.value || '0');
                                const g = BigInt(tx.gasUsed || '0') * BigInt(tx.gasPrice || '0');
                                if (tx.to?.toLowerCase() === walletLower) bal += v;
                                if (tx.from?.toLowerCase() === walletLower) { bal -= v; bal -= g; }
                            }
                            
                            for (const tx of internalTx) {
                                if (parseInt(tx.timeStamp) >= ts || tx.isError === '1') continue;
                                const v = BigInt(tx.value || '0');
                                if (tx.to?.toLowerCase() === walletLower) bal += v;
                                if (tx.from?.toLowerCase() === walletLower) bal -= v;
                            }
                            
                            const nativeKey = `${nativeSym} (${chain.name})`;
                            if (!balances[y][nativeKey]) balances[y][nativeKey] = 0;
                            balances[y][nativeKey] += Number(bal < 0n ? 0n : bal) / 1e18;
                        }
                        
                        // Calculate token balances per year
                        for (const tx of tokenTx) {
                            const c = tx.contractAddress.toLowerCase();
                            const key = `${chainKey}:${c}`;
                            const info = allTokens[key];
                            if (!info) continue;
                            
                            for (const y of years) {
                                const ts = new Date(`${y + 1}-01-01T00:00:00Z`).getTime() / 1000;
                                if (parseInt(tx.timeStamp) >= ts) continue;
                                
                                const tokenKey = `${info.symbol} (${chain.name})`;
                                if (!balances[y][tokenKey]) balances[y][tokenKey] = 0;
                                
                                const v = BigInt(tx.value || '0');
                                const amount = Number(v) / Math.pow(10, info.decimals);
                                
                                if (tx.to?.toLowerCase() === walletLower) {
                                    balances[y][tokenKey] += amount;
                                }
                                if (tx.from?.toLowerCase() === walletLower) {
                                    balances[y][tokenKey] -= amount;
                                }
                            }
                        }
                        
                        // Rate limit
                        await new Promise(r => setTimeout(r, 250));
                    }
                    
                    // Fix negative balances
                    for (const y of years) {
                        for (const key of Object.keys(balances[y])) {
                            if (balances[y][key] < 0) balances[y][key] = 0;
                        }
                    }
                    
                    // Calculate wallet totals per year
                    const walletTotals = {};
                    for (const y of years) {
                        walletTotals[y] = { eur: 0, usd: 0 };
                        
                        for (const [tokenKey, bal] of Object.entries(balances[y])) {
                            if (bal <= 0) continue;
                            
                            // Extract symbol and chain from key like "ETH (Ethereum)" or "SHIB (PulseChain)"
                            const sym = tokenKey.split(' (')[0].toUpperCase();
                            const chainMatch = tokenKey.match(/\(([^)]+)\)/);
                            const chain = chainMatch ? chainMatch[1] : '';
                            
                            // PulseChain cloni = prezzo 0 (solo PLS, PLSX, HEX, INC hanno valore)
                            const isPulseClone = chain === 'PulseChain' && !['PLS', 'PLSX', 'HEX', 'INC', 'WPLS'].includes(sym);
                            
                            const cgId = SYMBOL_TO_CG[sym];
                            const price = isPulseClone ? 0 : (HISTORICAL_PRICES[cgId]?.[y] || 0);
                            
                            if (price > 0) {
                                walletTotals[y].usd += bal * price;
                                walletTotals[y].eur += bal * price * EUR_USD;
                            }
                        }
                        
                        // Add to grand totals
                        grandTotals[y].usd += walletTotals[y].usd;
                        grandTotals[y].eur += walletTotals[y].eur;
                    }
                    
                    walletDetails.push({ wallet, balances, totals: walletTotals, tokens: allTokens });
                }
                
                // Prepara struttura dati serializzabile per Firebase
                const chainNames = selectedChains.map(c => CHAINS[c].name).join(', ');
                const serializedWalletDetails = walletDetails.map(wd => {
                    // Get all token keys that have value
                    const tokenKeys = new Set();
                    for (const y of years) {
                        for (const key of Object.keys(wd.balances[y])) {
                            if (wd.balances[y][key] > 0) tokenKeys.add(key);
                        }
                    }
                    
                    const rows = [];
                    for (const tokenKey of tokenKeys) {
                        const sym = tokenKey.split(' (')[0].toUpperCase();
                        const chainMatch = tokenKey.match(/\(([^)]+)\)/);
                        const chain = chainMatch ? chainMatch[1] : '';
                        
                        // PulseChain cloni = prezzo 0
                        const isPulseClone = chain === 'PulseChain' && !['PLS', 'PLSX', 'HEX', 'INC', 'WPLS'].includes(sym);
                        
                        const cgId = SYMBOL_TO_CG[sym];
                        
                        // Check if has any value
                        const hasValue = years.some(y => {
                            const bal = wd.balances[y][tokenKey] || 0;
                            const price = isPulseClone ? 0 : (HISTORICAL_PRICES[cgId]?.[y] || 0);
                            return bal * price * EUR_USD >= 1;
                        });
                        if (!hasValue) continue;
                        
                        const cells = {};
                        for (const y of years) {
                            const bal = wd.balances[y][tokenKey] || 0;
                            const price = isPulseClone ? 0 : (HISTORICAL_PRICES[cgId]?.[y] || 0);
                            cells[y] = {
                                balance: bal,
                                eur: bal * price * EUR_USD,
                                hasValue: bal > 0 && price > 0
                            };
                        }
                        rows.push({ tokenKey, cells });
                    }
                    
                    return {
                        walletName: wd.wallet.name,
                        walletAddress: wd.wallet.address.slice(0,8) + '...' + wd.wallet.address.slice(-6),
                        totals: wd.totals,
                        rows
                    };
                });
                
                // Salva in memoria e Firebase
                taxReportData = {
                    grandTotals,
                    walletDetails: serializedWalletDetails,
                    walletCount: savedWallets.length,
                    chainNames,
                    calculatedAt: Date.now()
                };
                saveToFirebase();
                
                // Render usando la funzione condivisa
                renderTaxReport(taxReportData);
                
            } catch(e) {
                container.innerHTML = `<div class="empty-state"><div class="icon">âŒ</div><h3>Errore: ${e.message}</h3></div>`;
                console.error(e);
            }
        }
        
        // ==================== TRANSACTIONS VIEW ====================
        let allTransactions = [];
        let filteredTransactions = [];
        let currentTxPage = 1;
        
        // Conta transazioni per anno (da tutti gli exchange)
        function countTransactionsByYear() {
            const counts = { 2021: 0, 2022: 0, 2023: 0, 2024: 0, 2025: 0, 2026: 0 };
            
            for (const [exchId, data] of Object.entries(exchangeData)) {
                if (data.transactions && data.transactions.length > 0) {
                    for (const tx of data.transactions) {
                        const date = tx.date instanceof Date ? tx.date : new Date(tx.date);
                        const year = date.getFullYear();
                        if (counts[year] !== undefined) {
                            counts[year]++;
                        }
                    }
                }
            }
            
            return counts;
        }
        
        function loadAllTransactions() {
            allTransactions = [];
            
            // Carica transazioni da Exchange
            for (const [exchId, data] of Object.entries(exchangeData)) {
                if (data.transactions && data.transactions.length > 0) {
                    const exchInfo = EXCHANGE_LIST.find(e => e.id === exchId) || { name: exchId, color: '#666' };
                    for (const tx of data.transactions) {
                        allTransactions.push({
                            ...tx,
                            date: tx.date instanceof Date ? tx.date : new Date(tx.date),
                            source: 'exchange',
                            sourceName: exchInfo.name,
                            sourceColor: exchInfo.color,
                            sourceId: exchId
                        });
                    }
                }
            }
            
            return allTransactions;
        }
        
        function formatNumber(num) {
            if (num === undefined || num === null || num === '') return '-';
            const n = parseFloat(num);
            if (isNaN(n)) return '-';
            if (n === 0) return '0';
            if (Math.abs(n) >= 1000000) return n.toLocaleString('it-IT', { maximumFractionDigits: 0 });
            if (Math.abs(n) >= 1000) return n.toLocaleString('it-IT', { maximumFractionDigits: 2 });
            if (Math.abs(n) >= 1) return n.toLocaleString('it-IT', { maximumFractionDigits: 4 });
            if (Math.abs(n) >= 0.0001) return n.toFixed(6);
            return n.toExponential(2);
        }
        
        // ==================== EXCHANGES CSV ====================
        // Mostra dettagli calcolo per un anno specifico
        function showYearDetails(exchId, year) {
            const data = exchangeData[exchId];
            if (!data) {
                alert('Nessun dato disponibile');
                return;
            }
            
            const balances = data.balances?.[year] || {};
            const realBalances = data.realBalances || {};
            
            // Per 2025/2026 usa saldi reali se disponibili
            const useReal = (year >= 2025) && Object.keys(realBalances).length > 0;
            const snapshot = useReal ? realBalances : balances;
            
            let details = `ğŸ“Š DETTAGLIO ${year} - ${exchId.toUpperCase()}\n`;
            details += `${'â”€'.repeat(40)}\n\n`;
            
            if (useReal) {
                details += `âœ… Usando SALDI REALI\n\n`;
            } else {
                details += `ğŸ“ˆ Usando saldi calcolati dalle transazioni\n\n`;
            }
            
            let totalEur = 0;
            const items = [];
            let skippedLD = 0;
            
            for (const [coin, amount] of Object.entries(snapshot)) {
                if (!amount || amount <= 0) continue;
                // ğŸš« Salta token LD* (duplicati Earn)
                if (coin.startsWith('LD')) {
                    skippedLD++;
                    continue;
                }
                const price = getHistoricalPrice(coin, year);
                const eurValue = amount * price * EUR_USD;
                totalEur += eurValue;
                items.push({ coin, amount, price, eurValue });
            }
            
            // Ordina per valore EUR
            items.sort((a, b) => b.eurValue - a.eurValue);
            
            for (const item of items.slice(0, 15)) {
                const amtStr = item.amount < 1 ? item.amount.toFixed(6) : item.amount.toLocaleString('it-IT', { maximumFractionDigits: 2 });
                const priceStr = item.price < 0.01 ? item.price.toExponential(2) : item.price.toFixed(4);
                details += `${item.coin}: ${amtStr}\n`;
                details += `   Prezzo: $${priceStr} â†’ â‚¬${item.eurValue.toFixed(2)}\n\n`;
            }
            
            if (items.length > 15) {
                details += `... e altri ${items.length - 15} token\n\n`;
            }
            
            details += `${'â”€'.repeat(40)}\n`;
            details += `ğŸ’° TOTALE: â‚¬${totalEur.toFixed(2)}\n`;
            if (skippedLD > 0) {
                details += `\nâš ï¸ Esclusi ${skippedLD} token LD* (duplicati Earn)`;
            }
            details += `\nğŸ’¡ I prezzi sono stime storiche.`;
            
            alert(details);
        }
        
        // Mostra tutti i saldi di un exchange
        function showExchangeBalances(exchId) {
            const data = exchangeData[exchId];
            if (!data) {
                alert('Nessun dato disponibile');
                return;
            }
            
            const realBalances = data.realBalances || {};
            const hasReal = Object.keys(realBalances).length > 0;
            
            let details = `ğŸ’ SALDI ${exchId.toUpperCase()}\n`;
            details += `${'â”€'.repeat(40)}\n\n`;
            
            if (hasReal) {
                // Separa token normali da token LD* (Earn)
                const normalTokens = [];
                const earnTokens = [];
                let totalEur = 0;
                
                for (const [coin, amount] of Object.entries(realBalances)) {
                    if (amount <= 0) continue;
                    if (coin.startsWith('LD')) {
                        earnTokens.push([coin, amount]);
                    } else {
                        normalTokens.push([coin, amount]);
                        const price = getHistoricalPrice(coin, 2026);
                        totalEur += amount * price * EUR_USD;
                    }
                }
                
                // Ordina per quantitÃ 
                normalTokens.sort((a, b) => b[1] - a[1]);
                earnTokens.sort((a, b) => b[1] - a[1]);
                
                details += `âœ… SALDI REALI (Spot + Earn):\n\n`;
                for (const [coin, amount] of normalTokens) {
                    const amtStr = amount < 1 ? amount.toFixed(6) : amount.toLocaleString('it-IT', { maximumFractionDigits: 2 });
                    const price = getHistoricalPrice(coin, 2026);
                    const eurValue = amount * price * EUR_USD;
                    details += `${coin}: ${amtStr}`;
                    if (price > 0) {
                        details += ` â†’ â‚¬${eurValue.toFixed(2)}`;
                    }
                    details += `\n`;
                }
                
                if (earnTokens.length > 0) {
                    details += `\nğŸ”’ TOKEN IN EARN (giÃ  inclusi sopra):\n`;
                    for (const [coin, amount] of earnTokens.slice(0, 10)) {
                        const realCoin = coin.substring(2); // Rimuovi "LD"
                        const amtStr = amount < 1 ? amount.toFixed(6) : amount.toLocaleString('it-IT', { maximumFractionDigits: 2 });
                        details += `${coin} (=${realCoin}): ${amtStr}\n`;
                    }
                    if (earnTokens.length > 10) {
                        details += `... e altri ${earnTokens.length - 10}\n`;
                    }
                }
                
                details += `\n${'â”€'.repeat(40)}\n`;
                details += `ğŸ’° TOTALE: â‚¬${totalEur.toFixed(2)}\n`;
                details += `ğŸ“Š Token: ${normalTokens.length} (+ ${earnTokens.length} in Earn)`;
            } else {
                details += `âš ï¸ Nessun saldo reale disponibile.\n`;
                details += `I saldi sono calcolati dalle transazioni.`;
            }
            
            alert(details);
        }
        
        // ==================== EXCHANGE DETAIL VIEW ====================
        let currentDetailExchange = null;
        let exchDetailTxPage = 1;
        let exchDetailFilteredTx = [];
        
        function initExchangeGrid() {
            const grid = document.getElementById('exchangeGrid');
            if (!grid) return;
            
            let html = '';
            for (const exch of EXCHANGE_LIST) {
                const data = exchangeData[exch.id] || {};
                const hasTx = (data.transactions && data.transactions.length > 0);
                const hasData = hasTx || data.transactionCount > 0 || data.isZeroed || data.isManual || (data.totals && Object.values(data.totals).some(v => v > 0));
                const txCount = data.transactions ? data.transactions.length : (data.transactionCount || 0);
                const total2025 = data.totals ? (data.totals[2025] || 0) : 0;
                const total2026 = data.totals ? (data.totals[2026] || 0) : 0;
                const displayTotal = total2026 > 0 ? total2026 : total2025;
                const displayYear = total2026 > 0 ? '2026' : '2025';
                const isZeroed = data.isZeroed || false;
                const source = data.source || '';
                
                // Card compatta cliccabile
                html += `<div class="card" style="cursor:pointer;transition:all 0.2s;border:2px solid transparent;" 
                         onclick="openExchangeDetail('${exch.id}')"
                         onmouseover="this.style.borderColor='var(--accent)'"
                         onmouseout="this.style.borderColor='transparent'">`;
                html += '<div style="display:flex;align-items:center;gap:12px;">';
                
                // Logo
                if (exch.logo) {
                    html += `<img src="${exch.logo}" style="width:48px;height:48px;border-radius:12px;object-fit:cover;" 
                             onerror="this.outerHTML='<span style=\\'width:48px;height:48px;background:${exch.color};border-radius:12px;display:flex;align-items:center;justify-content:center;font-size:18px;font-weight:bold;color:#fff;\\'>${exch.icon}</span>'">`;
                } else {
                    html += `<span style="width:48px;height:48px;background:${exch.color};border-radius:12px;display:flex;align-items:center;justify-content:center;font-size:18px;font-weight:bold;color:#fff;">${exch.icon}</span>`;
                }
                
                // Info
                html += '<div style="flex:1;min-width:0;">';
                html += `<div style="font-size:15px;font-weight:600;">${exch.name}</div>`;
                
                if (isZeroed) {
                    html += '<div style="font-size:11px;color:var(--yellow);">âš ï¸ Azzerato</div>';
                } else if (source === 'api') {
                    html += `<div style="font-size:11px;color:var(--green);">âœ“ ${txCount} tx via API</div>`;
                } else if (hasData && txCount > 0) {
                    html += `<div style="font-size:11px;color:var(--green);">âœ“ ${txCount} transazioni</div>`;
                } else if (hasData) {
                    html += '<div style="font-size:11px;color:var(--accent);">âœ“ Dati salvati</div>';
                } else {
                    html += `<div style="font-size:11px;color:var(--text-secondary);">Clicca per configurare</div>`;
                }
                html += '</div>';
                
                // Totale
                if (hasData && displayTotal > 0) {
                    html += `<div style="text-align:right;">
                        <div style="font-size:10px;color:var(--text-secondary);">${displayYear}</div>
                        <div style="font-size:18px;font-weight:700;color:var(--green);">â‚¬${Math.round(displayTotal)}</div>
                    </div>`;
                } else if (isZeroed) {
                    html += `<div style="text-align:right;">
                        <div style="font-size:10px;color:var(--text-secondary);">2025</div>
                        <div style="font-size:18px;font-weight:700;color:var(--yellow);">â‚¬0</div>
                    </div>`;
                } else {
                    html += '<div style="font-size:24px;color:var(--text-secondary);">â†’</div>';
                }
                
                html += '</div></div>';
            }
            
            grid.innerHTML = html;
        }
        
        function openExchangeDetail(exchId) {
            currentDetailExchange = exchId;
            const exch = EXCHANGE_LIST.find(e => e.id === exchId);
            const data = exchangeData[exchId] || {};
            
            if (!exch) return;
            
            // Header
            document.getElementById('exchDetailName').textContent = exch.name;
            
            // Logo
            const logoDiv = document.getElementById('exchDetailLogo');
            if (exch.logo) {
                logoDiv.innerHTML = `<img src="${exch.logo}" style="width:64px;height:64px;border-radius:16px;object-fit:cover;" 
                    onerror="this.outerHTML='<span style=\\'width:64px;height:64px;background:${exch.color};border-radius:16px;display:flex;align-items:center;justify-content:center;font-size:28px;font-weight:bold;color:#fff;\\'>${exch.icon}</span>'">`;
            } else {
                logoDiv.innerHTML = `<span style="width:64px;height:64px;background:${exch.color};border-radius:16px;display:flex;align-items:center;justify-content:center;font-size:28px;font-weight:bold;color:#fff;">${exch.icon}</span>`;
            }
            
            // Status
            const txCount = data.transactions?.length || data.transactionCount || 0;
            const source = data.source || 'csv';
            let statusText = '';
            if (data.isZeroed) {
                statusText = 'âš ï¸ Exchange azzerato (nessun saldo)';
            } else if (source === 'api') {
                statusText = `âœ… ${txCount} transazioni importate via API`;
            } else if (txCount > 0) {
                statusText = `âœ… ${txCount} transazioni importate da CSV`;
            } else if (data.isManual) {
                statusText = 'âœï¸ Valori inseriti manualmente';
            } else {
                statusText = 'ğŸ“‚ Nessun dato importato';
            }
            document.getElementById('exchDetailStatus').textContent = statusText;
            
            // Last update
            if (data.lastImport) {
                const date = new Date(data.lastImport);
                document.getElementById('exchDetailLastUpdate').textContent = `Ultimo aggiornamento: ${date.toLocaleString('it-IT')}`;
            } else {
                document.getElementById('exchDetailLastUpdate').textContent = '';
            }
            
            // Year grid
            renderExchDetailYearGrid(data);
            
            // API section (Binance, Bitget, ecc.)
            const apiSection = document.getElementById('exchDetailApiSection');
            const apiBtn = document.getElementById('exchDetailApiBtn');
            if (exch.hasApi) {
                apiSection.style.display = 'block';
                // Configura pulsante in base all'exchange
                if (exchId === 'binance') {
                    apiBtn.textContent = 'ğŸ”— Connetti API Binance';
                    apiBtn.style.background = '#f3ba2f';
                    apiBtn.style.color = '#000';
                } else if (exchId === 'bitget') {
                    apiBtn.textContent = 'ğŸ”— Connetti API Bitget';
                    apiBtn.style.background = '#00f0ff';
                    apiBtn.style.color = '#000';
                } else if (exchId === 'bitpanda') {
                    apiBtn.textContent = 'ğŸ”— Connetti API Bitpanda';
                    apiBtn.style.background = '#08b289';
                    apiBtn.style.color = '#fff';
                }
                checkBinanceServerStatus();
            } else {
                apiSection.style.display = 'none';
            }
            
            // Balances section
            const balancesSection = document.getElementById('exchDetailBalancesSection');
            if (data.realBalances && Object.keys(data.realBalances).length > 0) {
                balancesSection.style.display = 'block';
                renderExchDetailBalances(data.realBalances);
            } else {
                balancesSection.style.display = 'none';
            }
            
            // Transactions
            document.getElementById('exchDetailTxCount').textContent = txCount;
            exchDetailTxPage = 1;
            filterExchDetailTx();
            
            showView('exchangeDetail');
        }
        
        function renderExchDetailYearGrid(data) {
            const container = document.getElementById('exchDetailYearGrid');
            const years = [2021, 2022, 2023, 2024, 2025, 2026];
            
            // Conta transazioni per anno
            const txByYear = { 2021: 0, 2022: 0, 2023: 0, 2024: 0, 2025: 0, 2026: 0 };
            if (data.transactions) {
                for (const tx of data.transactions) {
                    const d = tx.date instanceof Date ? tx.date : new Date(tx.date);
                    const y = d.getFullYear();
                    if (txByYear[y] !== undefined) txByYear[y]++;
                }
            }
            
            let html = '';
            for (const y of years) {
                const val = data.totals?.[y] || 0;
                const txCount = txByYear[y];
                html += `<div style="background:var(--bg-primary);padding:12px 8px;border-radius:8px;text-align:center;cursor:pointer;" 
                         onclick="showYearDetails('${currentDetailExchange}',${y})" title="Clicca per dettagli">
                    <div style="font-size:13px;font-weight:600;color:var(--text-primary);">${y}</div>
                    <div style="font-size:20px;font-weight:700;color:var(--green);margin:6px 0;">â‚¬${Math.round(val)}</div>
                    ${txCount > 0 ? `<div style="font-size:10px;color:var(--accent);background:rgba(108,92,231,0.15);padding:3px 6px;border-radius:4px;display:inline-block;">${txCount} tx</div>` : '<div style="font-size:10px;color:var(--text-secondary);">-</div>'}
                </div>`;
            }
            container.innerHTML = html;
        }
        
        function renderExchDetailBalances(balances) {
            const container = document.getElementById('exchDetailBalances');
            const items = Object.entries(balances)
                .filter(([coin, amt]) => amt > 0 && !coin.startsWith('LD')) // Escludi token LD* (Earn duplicati)
                .sort((a, b) => {
                    const priceA = getHistoricalPrice(a[0], 2026) * a[1];
                    const priceB = getHistoricalPrice(b[0], 2026) * b[1];
                    return priceB - priceA;
                })
                .slice(0, 8);
            
            let html = '';
            for (const [coin, amount] of items) {
                const price = getHistoricalPrice(coin, 2026);
                const eurValue = amount * price * EUR_USD;
                const amtStr = amount < 1 ? amount.toFixed(4) : amount.toLocaleString('it-IT', { maximumFractionDigits: 2 });
                html += `<div style="background:var(--bg-primary);padding:10px;border-radius:6px;">
                    <div style="font-weight:600;font-size:13px;">${coin}</div>
                    <div style="font-size:12px;color:var(--text-secondary);">${amtStr}</div>
                    <div style="font-size:14px;font-weight:600;color:var(--green);">â‚¬${eurValue.toFixed(2)}</div>
                </div>`;
            }
            container.innerHTML = html || '<div style="color:var(--text-secondary);">Nessun saldo</div>';
        }
        
        function showAllExchBalances() {
            if (currentDetailExchange) {
                showExchangeBalances(currentDetailExchange);
            }
        }
        
        function filterExchDetailTx() {
            const data = exchangeData[currentDetailExchange] || {};
            const transactions = data.transactions || [];
            const yearFilter = document.getElementById('exchDetailTxYear')?.value || '';
            const typeFilter = document.getElementById('exchDetailTxType')?.value || '';
            
            exchDetailFilteredTx = transactions.filter(tx => {
                const d = tx.date instanceof Date ? tx.date : new Date(tx.date);
                if (yearFilter && d.getFullYear().toString() !== yearFilter) return false;
                if (typeFilter && tx.type !== typeFilter) return false;
                return true;
            });
            
            // Ordina per data desc
            exchDetailFilteredTx.sort((a, b) => {
                const da = a.date instanceof Date ? a.date : new Date(a.date);
                const db = b.date instanceof Date ? b.date : new Date(b.date);
                return db - da;
            });
            
            exchDetailTxPage = 1;
            renderExchDetailTxTable();
        }
        
        function renderExchDetailTxTable() {
            const tbody = document.getElementById('exchDetailTxTable');
            const perPage = 50;
            
            if (exchDetailFilteredTx.length === 0) {
                tbody.innerHTML = '<tr><td colspan="5" style="text-align:center;padding:40px;color:var(--text-secondary);">Nessuna transazione trovata</td></tr>';
                document.getElementById('exchDetailTxPagination').innerHTML = '';
                return;
            }
            
            const start = (exchDetailTxPage - 1) * perPage;
            const pageTx = exchDetailFilteredTx.slice(start, start + perPage);
            
            const typeColors = {
                deposit: { bg: 'rgba(0,206,201,0.15)', color: 'var(--green)', icon: 'ğŸ“¥' },
                fiat_deposit: { bg: 'rgba(0,206,201,0.15)', color: 'var(--green)', icon: 'ğŸ’¶' },
                withdrawal: { bg: 'rgba(255,107,107,0.15)', color: 'var(--red)', icon: 'ğŸ“¤' },
                fiat_withdrawal: { bg: 'rgba(255,107,107,0.15)', color: 'var(--red)', icon: 'ğŸ’¶' },
                trade: { bg: 'rgba(108,92,231,0.15)', color: 'var(--accent)', icon: 'ğŸ“Š' },
                buy: { bg: 'rgba(0,206,201,0.15)', color: 'var(--green)', icon: 'ğŸ›’' },
                sell: { bg: 'rgba(255,107,107,0.15)', color: 'var(--red)', icon: 'ğŸ’°' },
                convert: { bg: 'rgba(243,186,47,0.15)', color: '#f3ba2f', icon: 'ğŸ”„' },
                staking: { bg: 'rgba(0,206,201,0.15)', color: 'var(--green)', icon: 'ğŸ¥©' },
                interest: { bg: 'rgba(0,206,201,0.15)', color: 'var(--green)', icon: 'ğŸ’°' },
                dividend: { bg: 'rgba(0,206,201,0.15)', color: 'var(--green)', icon: 'ğŸ' },
                fee: { bg: 'rgba(255,107,107,0.15)', color: 'var(--red)', icon: 'ğŸ’¸' },
                transfer: { bg: 'rgba(108,92,231,0.15)', color: 'var(--accent)', icon: 'â†”ï¸' },
                refund: { bg: 'rgba(0,206,201,0.15)', color: 'var(--green)', icon: 'â†©ï¸' }
            };
            
            let html = '';
            for (const tx of pageTx) {
                const d = tx.date instanceof Date ? tx.date : new Date(tx.date);
                const dateStr = d.toLocaleDateString('it-IT');
                const timeStr = d.toLocaleTimeString('it-IT', { hour: '2-digit', minute: '2-digit' });
                const style = typeColors[tx.type] || { bg: 'rgba(160,160,160,0.15)', color: 'var(--text-secondary)', icon: 'â€¢' };
                const amt = parseFloat(tx.amount) || 0;
                const change = parseFloat(tx.change) || 0;
                const amtColor = change >= 0 ? 'var(--green)' : 'var(--red)';
                const sign = change >= 0 ? '+' : '';
                
                // Etichette piÃ¹ leggibili
                const typeLabels = {
                    deposit: 'Deposit',
                    withdrawal: 'Withdraw',
                    fiat_deposit: 'Fiat In',
                    fiat_withdrawal: 'Fiat Out',
                    trade: 'Trade',
                    buy: 'Buy',
                    sell: 'Sell',
                    convert: 'Convert',
                    staking: 'Staking',
                    interest: 'Interest',
                    dividend: 'Dividend',
                    fee: 'Fee',
                    dust: 'Dust',
                    transfer: 'Transfer',
                    refund: 'Refund'
                };
                const typeLabel = typeLabels[tx.type] || tx.type || '-';
                
                // Valore EUR se disponibile o calcolato
                let eurValue = '';
                if (tx.amountEur && tx.amountEur > 0) {
                    eurValue = `â‚¬${formatNumber(tx.amountEur)}`;
                } else {
                    // Prova a calcolare dal prezzo
                    const exchData = exchangeData[currentDetailExchange] || {};
                    const savedPrices = exchData.tokenPrices || {};
                    
                    // Prima prova prezzo salvato, poi CoinGecko
                    let price = savedPrices[tx.coin] || getHistoricalPrice(tx.coin, new Date(tx.date).getFullYear());
                    if (price && price > 0) {
                        const calcEur = amt * price * (savedPrices[tx.coin] ? 1 : EUR_USD);
                        if (calcEur > 0.01) {
                            eurValue = `~â‚¬${formatNumber(calcEur)}`;
                        }
                    }
                }
                
                html += `<tr>
                    <td style="white-space:nowrap;">
                        <div style="font-size:14px;font-weight:500;">${dateStr}</div>
                        <div style="font-size:11px;color:var(--text-secondary);">${timeStr}</div>
                    </td>
                    <td>
                        <span class="tx-badge" style="background:${style.bg};color:${style.color};">${style.icon} ${typeLabel}</span>
                    </td>
                    <td style="text-align:center;font-weight:600;font-size:14px;">${tx.coin || '-'}</td>
                    <td style="text-align:right;color:${amtColor};font-weight:600;font-size:14px;font-family:'SF Mono',Monaco,monospace;">${sign}${formatNumber(Math.abs(change) || amt)}</td>
                    <td style="text-align:right;font-size:13px;color:var(--text-secondary);font-family:'SF Mono',Monaco,monospace;">${eurValue}</td>
                </tr>`;
            }
            tbody.innerHTML = html;
            
            // Pagination
            const totalPages = Math.ceil(exchDetailFilteredTx.length / perPage);
            if (totalPages > 1) {
                let pagHtml = '';
                pagHtml += `<button class="btn btn-secondary" style="padding:4px 8px;font-size:11px;" onclick="exchDetailTxPage--;renderExchDetailTxTable()" ${exchDetailTxPage === 1 ? 'disabled' : ''}>â†</button>`;
                pagHtml += `<span style="font-size:12px;color:var(--text-secondary);margin:0 8px;">Pagina ${exchDetailTxPage}/${totalPages}</span>`;
                pagHtml += `<button class="btn btn-secondary" style="padding:4px 8px;font-size:11px;" onclick="exchDetailTxPage++;renderExchDetailTxTable()" ${exchDetailTxPage === totalPages ? 'disabled' : ''}>â†’</button>`;
                document.getElementById('exchDetailTxPagination').innerHTML = pagHtml;
            } else {
                document.getElementById('exchDetailTxPagination').innerHTML = '';
            }
        }
        
        function exportExchDetailTx() {
            if (exchDetailFilteredTx.length === 0) {
                alert('Nessuna transazione da esportare');
                return;
            }
            let csv = 'Data,Tipo,Coin,Importo,Change,Operazione\n';
            for (const tx of exchDetailFilteredTx) {
                const d = tx.date instanceof Date ? tx.date : new Date(tx.date);
                csv += `"${d.toISOString()}","${tx.type || ''}","${tx.coin || ''}",${tx.amount || 0},${tx.change || 0},"${tx.operation || ''}"\n`;
            }
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${currentDetailExchange}_transazioni.csv`;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        function clearCurrentExchangeData() {
            if (currentDetailExchange && confirm(`Vuoi eliminare tutti i dati di ${currentDetailExchange}?`)) {
                clearExchangeData(currentDetailExchange);
                showView('exchanges');
            }
        }
        
        function scanCurrentExchange() {
            if (currentDetailExchange === 'binance') {
                openBinanceApiModal();
            } else if (currentDetailExchange === 'bitget') {
                openBitgetApiModal();
            } else if (currentDetailExchange === 'bitpanda') {
                openBitpandaApiModal();
            } else {
                document.getElementById('exchDetailFileInput').click();
            }
        }
        
        function handleExchDetailFileSelect(event) {
            const files = event.target.files;
            if (files.length > 0 && currentDetailExchange) {
                processExchangeFiles(files, currentDetailExchange);
            }
        }
        
        function handleExchDetailDrop(event) {
            event.preventDefault();
            event.target.style.borderColor = 'var(--border)';
            event.target.style.background = 'transparent';
            const files = event.dataTransfer.files;
            if (files.length > 0 && currentDetailExchange) {
                processExchangeFiles(files, currentDetailExchange);
            }
        }
        
        // ==================== EXCHANGE API FUNCTIONS ====================
        
        // Verifica se il server Binance Ã¨ attivo
        async function checkBinanceServerStatus() {
            const statusEl = document.getElementById('serverStatus-binance');
            const modalStatusEl = document.getElementById('modalServerStatus');
            
            try {
                const response = await fetch('http://localhost:3457/status', { 
                    method: 'GET',
                    signal: AbortSignal.timeout(2000) 
                });
                
                if (response.ok) {
                    // Aggiorna badge nella card
                    if (statusEl) {
                        statusEl.textContent = 'ğŸŸ¢ ON';
                        statusEl.style.background = 'var(--green)';
                        statusEl.style.color = '#000';
                    }
                    // Aggiorna badge nel modal
                    if (modalStatusEl) {
                        modalStatusEl.textContent = 'ONLINE';
                        modalStatusEl.className = 'server-status-badge server-on';
                    }
                    console.log('âœ… Binance Tax Server attivo');
                    return true;
                }
            } catch (e) {
                // Server non attivo
            }
            
            // Server offline
            if (statusEl) {
                statusEl.textContent = 'âš« OFF';
                statusEl.style.background = 'var(--red)';
                statusEl.style.color = '#fff';
            }
            if (modalStatusEl) {
                modalStatusEl.textContent = 'OFFLINE';
                modalStatusEl.className = 'server-status-badge server-off';
            }
            console.log('âš ï¸ Binance Tax Server non attivo');
            return false;
        }
        
        // Funzioni Modal Binance API
        function openExchangeApiModal() {
            // Apre il modal corretto in base all'exchange corrente
            if (currentDetailExchange === 'binance') {
                openBinanceApiModal();
            } else if (currentDetailExchange === 'bitget') {
                openBitgetApiModal();
            } else if (currentDetailExchange === 'bitpanda') {
                openBitpandaApiModal();
            } else {
                alert('API non supportata per questo exchange');
            }
        }
        
        function openBinanceApiModal() {
            const modal = document.getElementById('binanceApiModal');
            const apiKeyInput = document.getElementById('modalApiKey');
            const secretKeyInput = document.getElementById('modalSecretKey');
            
            // Pre-popola con chiavi salvate
            if (apiKeys.binanceTaxKey) apiKeyInput.value = apiKeys.binanceTaxKey;
            if (apiKeys.binanceTaxSecret) secretKeyInput.value = apiKeys.binanceTaxSecret;
            
            // Reset progress
            document.getElementById('modalProgress').style.display = 'none';
            document.getElementById('modalProgressBar').style.width = '0%';
            document.getElementById('modalProgressText').textContent = '';
            
            modal.classList.add('active');
            checkModalServerStatus();
        }
        
        function closeBinanceApiModal() {
            document.getElementById('binanceApiModal').classList.remove('active');
        }
        
        async function checkModalServerStatus() {
            const statusEl = document.getElementById('modalServerStatus');
            const cardStatusEl = document.getElementById('serverStatus-binance');
            
            try {
                const response = await fetch('http://localhost:3457/status', { 
                    method: 'GET',
                    signal: AbortSignal.timeout(2000) 
                });
                
                if (response.ok) {
                    statusEl.textContent = 'ONLINE';
                    statusEl.className = 'server-status-badge server-on';
                    if (cardStatusEl) {
                        cardStatusEl.textContent = 'ğŸŸ¢ ON';
                        cardStatusEl.style.background = 'var(--green)';
                        cardStatusEl.style.color = '#000';
                    }
                    return true;
                }
            } catch (e) {}
            
            statusEl.textContent = 'OFFLINE';
            statusEl.className = 'server-status-badge server-off';
            if (cardStatusEl) {
                cardStatusEl.textContent = 'âš« OFF';
                cardStatusEl.style.background = 'var(--red)';
                cardStatusEl.style.color = '#fff';
            }
            return false;
        }
        
        async function downloadFromModal() {
            const apiKey = document.getElementById('modalApiKey').value.trim();
            const secretKey = document.getElementById('modalSecretKey').value.trim();
            const progressContainer = document.getElementById('modalProgress');
            const progressBar = document.getElementById('modalProgressBar');
            const progressText = document.getElementById('modalProgressText');
            
            if (!apiKey || !secretKey) {
                alert('âš ï¸ Inserisci API Key e Secret Key!\n\nVai su Binance â†’ Profilo â†’ Gestione API â†’ "Crea API report fiscale"');
                return;
            }
            
            // Salva le chiavi
            apiKeys.binanceTaxKey = apiKey;
            apiKeys.binanceTaxSecret = secretKey;
            localStorage.setItem('cryptofolio_apikeys', JSON.stringify(apiKeys));
            
            // Mostra progress
            progressContainer.style.display = 'block';
            progressBar.style.width = '5%';
            progressText.textContent = 'Verifica server...';
            
            try {
                // Verifica server
                const serverOnline = await checkModalServerStatus();
                if (!serverOnline) {
                    throw new Error('Server non attivo! Avvia AVVIA_SERVER.command');
                }
                
                progressBar.style.width = '10%';
                progressText.textContent = 'Download in corso... (1-2 minuti)';
                
                // Download
                const downloadUrl = `http://localhost:3457/download?apiKey=${encodeURIComponent(apiKey)}&secretKey=${encodeURIComponent(secretKey)}`;
                const response = await fetch(downloadUrl);
                const data = await response.json();
                
                if (data.error) throw new Error(data.error);
                
                let rawTransactions = data.transactions || [];
                const txCount = data.count || rawTransactions.length;
                
                if (txCount === 0) {
                    progressText.textContent = 'âš ï¸ Nessuna transazione trovata';
                    alert('âš ï¸ Nessuna transazione.\n\nVerifica di aver usato "API report fiscale"');
                    return;
                }
                
                progressBar.style.width = '70%';
                progressText.textContent = `Elaborazione ${txCount} transazioni...`;
                
                // ğŸ”‘ De-duplicazione transazioni (Binance a volte restituisce duplicati)
                const seenTx = new Set();
                const uniqueTransactions = rawTransactions.filter(tx => {
                    // Chiave unica basata su txId O combinazione data+coin+amount+type
                    const key = tx.txId || `${tx.date}-${tx.coin}-${tx.amount}-${tx.type}`;
                    if (seenTx.has(key)) {
                        console.log('âš ï¸ Duplicato rimosso:', tx.type, tx.coin, tx.amount);
                        return false;
                    }
                    seenTx.add(key);
                    return true;
                });
                
                const removedCount = rawTransactions.length - uniqueTransactions.length;
                if (removedCount > 0) {
                    console.log(`ğŸ”‘ Rimossi ${removedCount} duplicati`);
                }
                
                // Converti le transazioni
                const allTransactions = uniqueTransactions.map(tx => ({
                    ...tx,
                    date: new Date(tx.date),
                    change: tx.change || tx.amount || 0
                }));
                
                allTransactions.sort((a, b) => a.date - b.date);
                
                progressBar.style.width = '85%';
                progressText.textContent = 'Calcolo saldi 31/12...';
                
                // Calcola saldi al 31/12 dalle transazioni
                const balances = {};
                const yearEndSnapshots = {};
                const years = [2021, 2022, 2023, 2024, 2025, 2026];
                let yearIndex = 0;
                
                for (const tx of allTransactions) {
                    if (!balances[tx.coin]) balances[tx.coin] = 0;
                    balances[tx.coin] += tx.change || 0;
                    if (Math.abs(balances[tx.coin]) < 0.00000001) balances[tx.coin] = 0;
                    
                    while (yearIndex < years.length && tx.date > new Date(years[yearIndex], 11, 31, 23, 59, 59)) {
                        yearEndSnapshots[years[yearIndex]] = { ...balances };
                        yearIndex++;
                    }
                }
                
                for (let i = yearIndex; i < years.length; i++) {
                    yearEndSnapshots[years[i]] = { ...balances };
                }
                
                // ğŸ†• USA SALDI REALI per 2025 e 2026 se disponibili!
                const realBalances = data.realBalances || {};
                const hasRealBalances = Object.keys(realBalances).length > 0;
                
                if (hasRealBalances) {
                    console.log('âœ… Usando SALDI REALI per 2025/2026:', Object.keys(realBalances).length, 'asset');
                    yearEndSnapshots[2025] = { ...realBalances };
                    yearEndSnapshots[2026] = { ...realBalances }; // Saldi attuali = 2026
                }
                
                // Calcola totali EUR
                const yearTotals = {};
                for (const year of years) {
                    let totalEur = 0;
                    const snapshot = yearEndSnapshots[year] || {};
                    for (const [coin, amount] of Object.entries(snapshot)) {
                        if (!amount || amount <= 0) continue;
                        // ğŸš« Salta i token LD* (sono duplicati dei token in Earn)
                        if (coin.startsWith('LD')) {
                            console.log('âš ï¸ Saltato token Earn duplicato:', coin);
                            continue;
                        }
                        const price = getHistoricalPrice(coin, year);
                        if (price && !isNaN(price)) {
                            totalEur += amount * price * EUR_USD;
                        }
                    }
                    yearTotals[year] = isNaN(totalEur) ? 0 : Math.round(totalEur * 100) / 100;
                }
                
                // Salva
                exchangeData['binance'] = {
                    transactions: allTransactions,
                    balances: yearEndSnapshots,
                    realBalances: hasRealBalances ? realBalances : null,
                    totals: yearTotals,
                    transactionCount: allTransactions.length,
                    isManual: false,
                    lastImport: new Date().toISOString(),
                    source: 'api'
                };
                
                progressBar.style.width = '100%';
                const realMsg = hasRealBalances ? ` (con saldi reali!)` : '';
                progressText.textContent = `âœ… ${txCount} transazioni importate${realMsg}`;
                
                saveExchangeDataToFirebase();
                initExchangeGrid();
                updateExchangeTotals();
                
                // Mostra dettagli saldi reali
                let alertMsg = `âœ… Binance importato!\n\nğŸ“Š ${txCount} transazioni`;
                if (hasRealBalances) {
                    alertMsg += `\n\nğŸ’ SALDI REALI 2025:`;
                    const topBalances = Object.entries(realBalances)
                        .filter(([_, amt]) => amt > 0)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 5);
                    for (const [coin, amt] of topBalances) {
                        alertMsg += `\n   ${coin}: ${amt.toFixed(amt < 1 ? 6 : 2)}`;
                    }
                    alertMsg += `\n\nğŸ’° Totale 2025: â‚¬${yearTotals[2025]?.toLocaleString('it-IT') || '?'}`;
                }
                
                // Chiudi modal dopo 1.5 secondi
                setTimeout(() => {
                    closeBinanceApiModal();
                    alert(alertMsg);
                }, 1500);
                
            } catch (e) {
                console.error('Binance API error:', e);
                progressBar.style.width = '0%';
                progressText.textContent = 'âŒ ' + e.message;
                
                if (e.message.includes('Failed to fetch') || e.message.includes('non attivo')) {
                    alert('âš ï¸ Server non attivo!\n\nAvvia AVVIA_SERVER.command e riprova.');
                } else {
                    alert('âŒ Errore: ' + e.message);
                }
            }
        }
        
        // ==================== BITGET API FUNCTIONS ====================
        
        function openBitgetApiModal() {
            const modal = document.getElementById('bitgetApiModal');
            const apiKeyInput = document.getElementById('bitgetModalApiKey');
            const secretKeyInput = document.getElementById('bitgetModalSecretKey');
            const passphraseInput = document.getElementById('bitgetModalPassphrase');
            
            // Pre-popola con chiavi salvate
            if (apiKeys.bitgetApiKey) apiKeyInput.value = apiKeys.bitgetApiKey;
            if (apiKeys.bitgetSecretKey) secretKeyInput.value = apiKeys.bitgetSecretKey;
            if (apiKeys.bitgetPassphrase) passphraseInput.value = apiKeys.bitgetPassphrase;
            
            // Reset progress
            document.getElementById('bitgetModalProgress').style.display = 'none';
            document.getElementById('bitgetModalProgressBar').style.width = '0%';
            document.getElementById('bitgetModalProgressText').textContent = '';
            
            modal.classList.add('active');
            checkBitgetServerStatus();
        }
        
        function closeBitgetApiModal() {
            document.getElementById('bitgetApiModal').classList.remove('active');
        }
        
        async function checkBitgetServerStatus() {
            const statusEl = document.getElementById('bitgetModalServerStatus');
            
            try {
                const response = await fetch('http://localhost:3457/status', { 
                    method: 'GET',
                    signal: AbortSignal.timeout(2000) 
                });
                
                if (response.ok) {
                    statusEl.textContent = 'ONLINE';
                    statusEl.className = 'server-status-badge server-on';
                    return true;
                }
            } catch (e) {}
            
            statusEl.textContent = 'OFFLINE';
            statusEl.className = 'server-status-badge server-off';
            return false;
        }
        
        async function downloadFromBitgetModal() {
            const apiKey = document.getElementById('bitgetModalApiKey').value.trim();
            const secretKey = document.getElementById('bitgetModalSecretKey').value.trim();
            const passphrase = document.getElementById('bitgetModalPassphrase').value.trim();
            const progressContainer = document.getElementById('bitgetModalProgress');
            const progressBar = document.getElementById('bitgetModalProgressBar');
            const progressText = document.getElementById('bitgetModalProgressText');
            
            if (!apiKey || !secretKey || !passphrase) {
                alert('âš ï¸ Inserisci API Key, Secret Key e Passphrase!\n\nVai su Bitget â†’ Account â†’ API');
                return;
            }
            
            // Salva le chiavi
            apiKeys.bitgetApiKey = apiKey;
            apiKeys.bitgetSecretKey = secretKey;
            apiKeys.bitgetPassphrase = passphrase;
            localStorage.setItem('cryptofolio_apikeys', JSON.stringify(apiKeys));
            saveToFirebase(); // Sync con cloud
            
            // Mostra progress
            progressContainer.style.display = 'block';
            progressBar.style.width = '5%';
            progressText.textContent = 'Verifica server...';
            
            try {
                // Verifica server
                const serverOnline = await checkBitgetServerStatus();
                if (!serverOnline) {
                    throw new Error('Server non attivo! Avvia il server prima');
                }
                
                progressBar.style.width = '10%';
                progressText.textContent = 'Download in corso... (1-2 minuti)';
                
                // Download
                const downloadUrl = `http://localhost:3457/bitget/download?apiKey=${encodeURIComponent(apiKey)}&secretKey=${encodeURIComponent(secretKey)}&passphrase=${encodeURIComponent(passphrase)}`;
                const response = await fetch(downloadUrl);
                const data = await response.json();
                
                if (data.error) throw new Error(data.error);
                
                let rawTransactions = data.transactions || [];
                const txCount = data.count || rawTransactions.length;
                
                if (txCount === 0 && !data.realBalances) {
                    progressText.textContent = 'âš ï¸ Nessun dato trovato';
                    alert('âš ï¸ Nessuna transazione o saldo trovato.\n\nVerifica che le API abbiano i permessi corretti.');
                    return;
                }
                
                progressBar.style.width = '70%';
                progressText.textContent = `Elaborazione ${txCount} transazioni...`;
                
                // De-duplicazione
                const seenTx = new Set();
                const uniqueTransactions = rawTransactions.filter(tx => {
                    const key = tx.id || `${tx.date}-${tx.coin}-${tx.amount}-${tx.type}`;
                    if (seenTx.has(key)) return false;
                    seenTx.add(key);
                    return true;
                });
                
                // Converti le transazioni
                const allTransactions = uniqueTransactions.map(tx => ({
                    ...tx,
                    date: new Date(tx.date),
                    change: tx.change || tx.amount || 0
                }));
                
                allTransactions.sort((a, b) => a.date - b.date);
                
                progressBar.style.width = '85%';
                progressText.textContent = 'Calcolo saldi 31/12...';
                
                // Calcola saldi al 31/12 dalle transazioni
                const balances = {};
                const yearEndSnapshots = {};
                const years = [2021, 2022, 2023, 2024, 2025, 2026];
                let yearIndex = 0;
                
                for (const tx of allTransactions) {
                    if (!balances[tx.coin]) balances[tx.coin] = 0;
                    balances[tx.coin] += tx.change || 0;
                    if (Math.abs(balances[tx.coin]) < 0.00000001) balances[tx.coin] = 0;
                    
                    while (yearIndex < years.length && tx.date > new Date(years[yearIndex], 11, 31, 23, 59, 59)) {
                        yearEndSnapshots[years[yearIndex]] = { ...balances };
                        yearIndex++;
                    }
                }
                
                for (let i = yearIndex; i < years.length; i++) {
                    yearEndSnapshots[years[i]] = { ...balances };
                }
                
                // USA SALDI REALI per 2025 e 2026 se disponibili!
                const realBalances = data.realBalances || {};
                const hasRealBalances = Object.keys(realBalances).length > 0;
                
                if (hasRealBalances) {
                    console.log('âœ… Usando SALDI REALI Bitget per 2025/2026:', Object.keys(realBalances).length, 'asset');
                    yearEndSnapshots[2025] = { ...realBalances };
                    yearEndSnapshots[2026] = { ...realBalances };
                }
                
                // Calcola totali EUR
                const yearTotals = {};
                for (const year of years) {
                    let totalEur = 0;
                    const snapshot = yearEndSnapshots[year] || {};
                    for (const [coin, amount] of Object.entries(snapshot)) {
                        if (!amount || amount <= 0) continue;
                        const price = getHistoricalPrice(coin, year);
                        if (price && !isNaN(price)) {
                            totalEur += amount * price * EUR_USD;
                        }
                    }
                    yearTotals[year] = isNaN(totalEur) ? 0 : Math.round(totalEur * 100) / 100;
                }
                
                // Salva
                exchangeData['bitget'] = {
                    transactions: allTransactions,
                    balances: yearEndSnapshots,
                    realBalances: hasRealBalances ? realBalances : null,
                    totals: yearTotals,
                    transactionCount: allTransactions.length,
                    isManual: false,
                    lastImport: new Date().toISOString(),
                    source: 'api'
                };
                
                progressBar.style.width = '100%';
                const realMsg = hasRealBalances ? ` (con saldi reali!)` : '';
                progressText.textContent = `âœ… ${txCount} transazioni importate${realMsg}`;
                
                saveExchangeDataToFirebase();
                initExchangeGrid();
                updateExchangeTotals();
                
                // Messaggio finale
                let alertMsg = `âœ… Bitget importato!\n\nğŸ“Š ${txCount} transazioni`;
                if (hasRealBalances) {
                    alertMsg += `\n\nğŸ’ SALDI REALI:`;
                    const topBalances = Object.entries(realBalances)
                        .filter(([_, amt]) => amt > 0)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 5);
                    for (const [coin, amt] of topBalances) {
                        alertMsg += `\n   ${coin}: ${amt.toFixed(amt < 1 ? 6 : 2)}`;
                    }
                    alertMsg += `\n\nğŸ’° Totale 2025: â‚¬${yearTotals[2025]?.toLocaleString('it-IT') || '?'}`;
                }
                
                // Chiudi modal dopo 1.5 secondi
                setTimeout(() => {
                    closeBitgetApiModal();
                    alert(alertMsg);
                    // Aggiorna vista dettaglio se aperta
                    if (currentDetailExchange === 'bitget') {
                        openExchangeDetail('bitget');
                    }
                }, 1500);
                
            } catch (e) {
                console.error('Bitget API error:', e);
                progressBar.style.width = '0%';
                progressText.textContent = 'âŒ ' + e.message;
                
                if (e.message.includes('Failed to fetch') || e.message.includes('non attivo')) {
                    alert('âš ï¸ Server non attivo!\n\nAvvia il server e riprova.');
                } else {
                    alert('âŒ Errore: ' + e.message);
                }
            }
        }
        
        // ==================== BITPANDA API FUNCTIONS ====================
        
        function openBitpandaApiModal() {
            const modal = document.getElementById('bitpandaApiModal');
            const apiKeyInput = document.getElementById('bitpandaModalApiKey');
            
            // Pre-popola con chiave salvata
            if (apiKeys.bitpandaApiKey) apiKeyInput.value = apiKeys.bitpandaApiKey;
            
            // Reset progress
            document.getElementById('bitpandaModalProgress').style.display = 'none';
            document.getElementById('bitpandaModalProgressBar').style.width = '0%';
            document.getElementById('bitpandaModalProgressText').textContent = '';
            
            modal.classList.add('active');
        }
        
        function closeBitpandaApiModal() {
            document.getElementById('bitpandaApiModal').classList.remove('active');
        }
        
        async function downloadFromBitpandaModal() {
            const apiKey = document.getElementById('bitpandaModalApiKey').value.trim();
            const progressContainer = document.getElementById('bitpandaModalProgress');
            const progressBar = document.getElementById('bitpandaModalProgressBar');
            const progressText = document.getElementById('bitpandaModalProgressText');
            
            if (!apiKey) {
                alert('âš ï¸ Inserisci la tua Bitpanda API Key!\n\nVai su Bitpanda â†’ Profilo â†’ API');
                return;
            }
            
            // Salva la chiave
            apiKeys.bitpandaApiKey = apiKey;
            localStorage.setItem('cryptofolio_apikeys', JSON.stringify(apiKeys));
            saveToFirebase();
            
            // Mostra progress
            progressContainer.style.display = 'block';
            progressBar.style.width = '5%';
            progressText.textContent = 'Connessione a Bitpanda...';
            
            try {
                const allTransactions = [];
                const realBalances = {};
                
                // 1. Fetch crypto wallets (saldi)
                progressBar.style.width = '10%';
                progressText.textContent = 'Caricamento wallet crypto...';
                
                const walletsRes = await fetch('https://api.bitpanda.com/v1/wallets', {
                    headers: { 'X-Api-Key': apiKey }
                });
                
                if (!walletsRes.ok) {
                    if (walletsRes.status === 401) throw new Error('API Key non valida');
                    throw new Error(`Errore wallet: ${walletsRes.status}`);
                }
                
                const walletsData = await walletsRes.json();
                console.log('Bitpanda wallets:', walletsData);
                
                // Estrai saldi reali (inclusi staked)
                for (const wallet of (walletsData.data || [])) {
                    const symbol = wallet.attributes?.cryptocoin_symbol;
                    const balance = parseFloat(wallet.attributes?.balance) || 0;
                    const stakedBalance = parseFloat(wallet.attributes?.staked_balance) || 0;
                    const totalBalance = balance + stakedBalance;
                    
                    if (symbol && totalBalance > 0) {
                        realBalances[symbol] = (realBalances[symbol] || 0) + totalBalance;
                        if (stakedBalance > 0) {
                            console.log(`  ğŸ’ ${symbol}: ${balance} + ${stakedBalance} staked = ${totalBalance}`);
                        }
                    }
                }
                
                // 2. Fetch crypto transactions
                progressBar.style.width = '30%';
                progressText.textContent = 'Caricamento transazioni crypto...';
                
                let cursor = null;
                let pageCount = 0;
                const maxPages = 50;
                
                do {
                    let txUrl = 'https://api.bitpanda.com/v1/wallets/transactions?page_size=100';
                    if (cursor) txUrl += `&cursor=${cursor}`;
                    
                    const txRes = await fetch(txUrl, {
                        headers: { 'X-Api-Key': apiKey }
                    });
                    
                    if (!txRes.ok) break;
                    
                    const txData = await txRes.json();
                    
                    for (const tx of (txData.data || [])) {
                        const attrs = tx.attributes;
                        const date = attrs?.time?.date_iso8601 ? new Date(attrs.time.date_iso8601) : new Date();
                        const amount = parseFloat(attrs?.amount) || 0;
                        // Prova vari campi per il valore EUR
                        const amountEur = parseFloat(attrs?.amount_eur) || parseFloat(attrs?.current_fiat_amount) || 0;
                        
                        // Debug primi 3 tx
                        if (allTransactions.length < 3) {
                            console.log('ğŸ“‹ Bitpanda TX attrs:', JSON.stringify(attrs, null, 2));
                        }
                        
                        // Mappa tipo transazione
                        let type = attrs?.type || 'unknown';
                        const inOrOut = attrs?.in_or_out || '';
                        
                        // Normalizza tipi
                        if (type === 'transfer' && inOrOut === 'incoming') type = 'deposit';
                        if (type === 'transfer' && inOrOut === 'outgoing') type = 'withdrawal';
                        if (type === 'reward' || type === 'staking_reward' || type === 'distribution') type = 'staking';
                        if (type === 'best_reward') type = 'staking'; // BEST/VSN rewards
                        
                        // Debug per vedere tutti i tipi
                        if (!['buy', 'sell', 'deposit', 'withdrawal', 'staking', 'transfer'].includes(type)) {
                            console.log(`  ğŸ“‹ Bitpanda tx type: ${attrs?.type} â†’ ${type}`);
                        }
                        
                        // Trova simbolo crypto (da cryptocoin_id)
                        const cryptoId = attrs?.cryptocoin_id;
                        const symbol = findBitpandaCryptoSymbol(cryptoId, walletsData.data) || 'UNKNOWN';
                        
                        // Calcola change (positivo per incoming, negativo per outgoing)
                        const isIncoming = inOrOut === 'incoming' || type === 'buy' || type === 'deposit' || type === 'staking';
                        const change = isIncoming ? amount : -amount;
                        
                        allTransactions.push({
                            date: date,
                            type: type,
                            coin: symbol,
                            amount: amount,
                            change: change,
                            amountEur: amountEur,
                            fee: parseFloat(attrs?.fee) || 0,
                            account: 'bitpanda',
                            txHash: tx.id || ''
                        });
                    }
                    
                    // Paginazione
                    cursor = txData.links?.next ? extractCursor(txData.links.next) : null;
                    pageCount++;
                    
                    progressBar.style.width = `${30 + (pageCount / maxPages) * 30}%`;
                    progressText.textContent = `Transazioni crypto: ${allTransactions.length}...`;
                    
                    await new Promise(r => setTimeout(r, 200));
                } while (cursor && pageCount < maxPages);
                
                // 3. Fetch trades
                progressBar.style.width = '65%';
                progressText.textContent = 'Caricamento trades...';
                
                cursor = null;
                pageCount = 0;
                
                do {
                    let tradesUrl = 'https://api.bitpanda.com/v1/trades?page_size=100';
                    if (cursor) tradesUrl += `&cursor=${cursor}`;
                    
                    const tradesRes = await fetch(tradesUrl, {
                        headers: { 'X-Api-Key': apiKey }
                    });
                    
                    if (!tradesRes.ok) break;
                    
                    const tradesData = await tradesRes.json();
                    
                    for (const trade of (tradesData.data || [])) {
                        const attrs = trade.attributes;
                        const date = attrs?.time?.date_iso8601 ? new Date(attrs.time.date_iso8601) : new Date();
                        const amount = parseFloat(attrs?.amount_cryptocoin) || 0;
                        const amountFiat = parseFloat(attrs?.amount_fiat) || 0;
                        const type = attrs?.type || 'trade'; // buy o sell
                        const cryptoId = attrs?.cryptocoin_id;
                        const symbol = findBitpandaCryptoSymbol(cryptoId, walletsData.data) || 'UNKNOWN';
                        
                        // Buy = +crypto, Sell = -crypto
                        const change = type === 'buy' ? amount : -amount;
                        
                        allTransactions.push({
                            date: date,
                            type: type,
                            coin: symbol,
                            amount: amount,
                            change: change,
                            amountEur: amountFiat,
                            fee: parseFloat(attrs?.fee) || 0,
                            account: 'bitpanda',
                            txHash: trade.id || ''
                        });
                    }
                    
                    cursor = tradesData.links?.next ? extractCursor(tradesData.links.next) : null;
                    pageCount++;
                    
                    await new Promise(r => setTimeout(r, 200));
                } while (cursor && pageCount < maxPages);
                
                // 4. Fetch fiat wallets
                progressBar.style.width = '85%';
                progressText.textContent = 'Caricamento wallet fiat...';
                
                try {
                    const fiatWalletsRes = await fetch('https://api.bitpanda.com/v1/fiatwallets', {
                        headers: { 'X-Api-Key': apiKey }
                    });
                    
                    if (fiatWalletsRes.ok) {
                        const fiatData = await fiatWalletsRes.json();
                        console.log('ğŸ’¶ Bitpanda fiat wallets:', fiatData);
                        for (const wallet of (fiatData.data || [])) {
                            const symbol = wallet.attributes?.fiat_symbol;
                            const balance = parseFloat(wallet.attributes?.balance) || 0;
                            console.log(`  ğŸ’µ ${symbol}: ${balance}`);
                            if (symbol && balance > 0) {
                                realBalances[symbol] = (realBalances[symbol] || 0) + balance;
                            }
                        }
                    } else {
                        console.log('âš ï¸ Fiat wallets API failed:', fiatWalletsRes.status);
                    }
                } catch (e) {
                    console.log('âš ï¸ Fiat wallets error:', e.message);
                }
                
                // Ordina per data
                allTransactions.sort((a, b) => new Date(b.date) - new Date(a.date));
                
                // Calcola totali per anno
                const years = [2021, 2022, 2023, 2024, 2025, 2026];
                const yearTotals = {};
                const yearEndSnapshots = {};
                
                for (const year of years) {
                    yearEndSnapshots[year] = {};
                    yearTotals[year] = 0;
                }
                
                // Calcola snapshot fine anno dai trades
                for (const tx of allTransactions) {
                    const txYear = new Date(tx.date).getFullYear();
                    for (const year of years) {
                        if (txYear <= year) {
                            if (!yearEndSnapshots[year][tx.coin]) yearEndSnapshots[year][tx.coin] = 0;
                            // Entrate: buy, deposit, staking rewards
                            if (tx.type === 'buy' || tx.type === 'deposit' || tx.type === 'staking' || tx.type === 'interest' || tx.type === 'reward') {
                                yearEndSnapshots[year][tx.coin] += tx.amount;
                            } else if (tx.type === 'sell' || tx.type === 'withdrawal') {
                                yearEndSnapshots[year][tx.coin] -= tx.amount;
                            }
                        }
                    }
                }
                
                // Calcola se ci sono saldi reali
                const hasRealBalances = Object.keys(realBalances).length > 0;
                
                // Mappa prezzi token da transazioni (per token senza prezzo CoinGecko)
                const tokenPricesFromTx = {};
                for (const tx of allTransactions) {
                    if (tx.amountEur && tx.amount && tx.amount > 0) {
                        const pricePerUnit = tx.amountEur / tx.amount;
                        if (pricePerUnit > 0) {
                            tokenPricesFromTx[tx.coin] = pricePerUnit; // Ultimo prezzo conosciuto
                        }
                    }
                }
                console.log('ğŸ’° Prezzi token da transazioni:', tokenPricesFromTx);
                
                // Tassi di cambio fiat
                const fiatRates = { 'EUR': 1, 'USD': EUR_USD, 'CHF': 0.95, 'GBP': 1.17 };
                
                // Calcola valore EUR per anno
                const currentYear = new Date().getFullYear();
                for (const year of years) {
                    let totalEur = 0;
                    // Per anno corrente, usa saldi reali se disponibili
                    const balancesToUse = (year === currentYear && hasRealBalances) ? realBalances : yearEndSnapshots[year];
                    
                    for (const [coin, amount] of Object.entries(balancesToUse || {})) {
                        if (amount > 0) {
                            // 1. Check se Ã¨ fiat
                            if (fiatRates[coin]) {
                                totalEur += amount * fiatRates[coin];
                                continue;
                            }
                            
                            // 2. Prova prezzo CoinGecko
                            const price = getHistoricalPrice(coin, year);
                            if (price && !isNaN(price) && price > 0) {
                                totalEur += amount * price * EUR_USD;
                                continue;
                            }
                            
                            // 3. Usa prezzo da transazioni se disponibile
                            if (tokenPricesFromTx[coin]) {
                                totalEur += amount * tokenPricesFromTx[coin];
                            }
                        }
                    }
                    yearTotals[year] = Math.round(totalEur * 100) / 100;
                }
                
                console.log('ğŸ“Š Bitpanda yearTotals:', yearTotals);
                console.log('ğŸ“Š Bitpanda realBalances:', realBalances);
                
                // Se anno corrente ha saldi reali, copia per snapshot
                if (hasRealBalances) {
                    yearEndSnapshots[currentYear] = { ...realBalances };
                }
                
                // Salva
                exchangeData['bitpanda'] = {
                    transactions: allTransactions,
                    balances: yearEndSnapshots,
                    realBalances: hasRealBalances ? realBalances : null,
                    totals: yearTotals,
                    tokenPrices: tokenPricesFromTx, // Salva prezzi token per reload
                    transactionCount: allTransactions.length,
                    isManual: false,
                    lastImport: new Date().toISOString(),
                    source: 'api'
                };
                
                progressBar.style.width = '100%';
                const realMsg = hasRealBalances ? ` (con saldi reali!)` : '';
                progressText.textContent = `âœ… ${allTransactions.length} transazioni importate${realMsg}`;
                
                saveExchangeDataToFirebase();
                initExchangeGrid();
                updateExchangeTotals();
                
                // Messaggio finale
                let alertMsg = `âœ… Bitpanda importato!\n\nğŸ“Š ${allTransactions.length} transazioni`;
                if (hasRealBalances) {
                    alertMsg += `\n\nğŸ’ SALDI REALI:`;
                    const topBalances = Object.entries(realBalances)
                        .filter(([_, amt]) => amt > 0)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 5);
                    for (const [coin, amt] of topBalances) {
                        alertMsg += `\n   ${coin}: ${typeof amt === 'number' ? amt.toFixed(amt < 1 ? 6 : 2) : amt}`;
                    }
                }
                
                setTimeout(() => {
                    closeBitpandaApiModal();
                    alert(alertMsg);
                    if (currentDetailExchange === 'bitpanda') {
                        openExchangeDetail('bitpanda');
                    }
                }, 1500);
                
            } catch (e) {
                console.error('Bitpanda API error:', e);
                progressBar.style.width = '0%';
                
                if (e.message.includes('Failed to fetch') || e.name === 'TypeError') {
                    progressText.textContent = 'âŒ CORS bloccato - serve proxy server';
                    alert('âš ï¸ Bitpanda blocca le richieste dal browser (CORS).\n\nServe un proxy server per usare l\'API.\n\nAlternativa: importa il CSV da Bitpanda.');
                } else {
                    progressText.textContent = 'âŒ ' + e.message;
                    alert('âŒ Errore: ' + e.message);
                }
            }
        }
        
        // Helper: trova simbolo crypto da ID
        function findBitpandaCryptoSymbol(cryptoId, wallets) {
            if (!cryptoId || !wallets) return null;
            for (const wallet of wallets) {
                if (wallet.attributes?.cryptocoin_id === cryptoId) {
                    return wallet.attributes?.cryptocoin_symbol;
                }
            }
            // Mapping comune Bitpanda (cryptocoin_id â†’ symbol)
            const idMap = { 
                '1': 'BTC', '3': 'ETH', '5': 'LTC', '8': 'XRP', 
                '27': 'ADA', '28': 'DOT', '30': 'LINK', '34': 'UNI',
                '39': 'BEST', '130': 'VSN', // Bitpanda tokens
                '11': 'USDT', '42': 'USDC', '17': 'DOGE', '18': 'TRX',
                '22': 'XLM', '29': 'SOL', '31': 'AVAX', '32': 'MATIC'
            };
            return idMap[cryptoId] || null;
        }
        
        // Helper: estrai cursor da URL
        function extractCursor(url) {
            if (!url) return null;
            const match = url.match(/cursor=([^&]+)/);
            return match ? match[1] : null;
        }
        
        async function testExchangeApi(exchId) {
            if (exchId === 'binance') {
                const apiKey = document.getElementById('apiKey-binance')?.value.trim();
                const secretKey = document.getElementById('secretKey-binance')?.value.trim();
                
                if (!apiKey || !secretKey || apiKey.includes('...') || secretKey.includes('â€¢â€¢')) {
                    alert('âš ï¸ Inserisci API Key e Secret Key valide!');
                    return;
                }
                
                try {
                    // Prima verifica che il server sia attivo
                    const statusResponse = await fetch('http://localhost:3457/status');
                    if (!statusResponse.ok) throw new Error('Server non attivo');
                    
                    // Test connessione Binance
                    const testUrl = `http://localhost:3457/test?apiKey=${encodeURIComponent(apiKey)}&secretKey=${encodeURIComponent(secretKey)}`;
                    const response = await fetch(testUrl);
                    const data = await response.json();
                    
                    if (data.success) {
                        alert('âœ… Connessione riuscita! API valida.');
                    } else {
                        alert('âŒ Errore: ' + (data.error || 'Sconosciuto'));
                    }
                } catch (e) {
                    if (e.message.includes('Failed to fetch') || e.message.includes('non attivo')) {
                        alert('âš ï¸ Server non attivo!\n\n1. Scarica il file "binance-tax-server.js"\n2. Apri terminale nella cartella\n3. Esegui: node binance-tax-server.js\n4. Riprova');
                    } else {
                        alert('âŒ Errore: ' + e.message);
                    }
                }
            }
        }
        
        async function saveAndDownloadExchangeApi(exchId) {
            if (exchId === 'binance') {
                const apiKey = document.getElementById('apiKey-binance')?.value.trim();
                const secretKey = document.getElementById('secretKey-binance')?.value.trim();
                
                if (!apiKey || !secretKey || apiKey.includes('...') || secretKey.includes('â€¢â€¢')) {
                    alert('âš ï¸ Inserisci API Key e Secret Key valide!\n\nVai su Binance â†’ Profilo â†’ Gestione API â†’ "Crea API report fiscale"');
                    return;
                }
                
                // Salva le chiavi
                apiKeys.binanceTaxKey = apiKey;
                apiKeys.binanceTaxSecret = secretKey;
                localStorage.setItem('cryptofolio_apikeys', JSON.stringify(apiKeys));
                
                // Mostra progresso
                const progress = document.getElementById('apiProgress-binance');
                const progressBar = document.getElementById('apiProgressBar-binance');
                const progressText = document.getElementById('apiProgressText-binance');
                if (progress) progress.style.display = 'block';
                
                try {
                    // Verifica server
                    if (progressText) progressText.textContent = 'Verifica server...';
                    if (progressBar) progressBar.style.width = '5%';
                    
                    const serverOnline = await checkBinanceServerStatus();
                    if (!serverOnline) {
                        throw new Error('Server non attivo');
                    }
                    
                    // Download dati da server
                    if (progressText) progressText.textContent = 'Download in corso... (puÃ² richiedere 1-2 minuti)';
                    if (progressBar) progressBar.style.width = '10%';
                    
                    const downloadUrl = `http://localhost:3457/download?apiKey=${encodeURIComponent(apiKey)}&secretKey=${encodeURIComponent(secretKey)}`;
                    const response = await fetch(downloadUrl);
                    const data = await response.json();
                    
                    // Gestisce diversi formati di risposta
                    if (data.error) {
                        throw new Error(data.error);
                    }
                    
                    // Estrai transazioni (supporta entrambi i formati)
                    let rawTransactions = data.transactions || [];
                    const txCount = data.count || rawTransactions.length;
                    
                    if (txCount === 0) {
                        if (progressText) progressText.textContent = 'âš ï¸ Nessuna transazione trovata';
                        alert('âš ï¸ Nessuna transazione trovata.\n\nVerifica che:\n1. Hai usato "API report fiscale" (non API normale)\n2. Hai transazioni su Binance');
                        return;
                    }
                    
                    if (progressBar) progressBar.style.width = '80%';
                    if (progressText) progressText.textContent = `Elaborazione ${txCount} transazioni...`;
                    
                    // Converti le transazioni
                    const allTransactions = rawTransactions.map(tx => ({
                        ...tx,
                        date: new Date(tx.date),
                        change: tx.change || tx.amount || 0
                    }));
                    
                    // Ordina per data
                    allTransactions.sort((a, b) => a.date - b.date);
                    
                    // Calcola saldi al 31/12
                    if (progressText) progressText.textContent = 'Calcolo saldi 31/12...';
                    if (progressBar) progressBar.style.width = '90%';
                    
                    const balances = {};
                    const yearEndSnapshots = {};
                    const years = [2021, 2022, 2023, 2024, 2025, 2026];
                    let yearIndex = 0;
                    
                    for (const tx of allTransactions) {
                        if (!balances[tx.coin]) balances[tx.coin] = 0;
                        balances[tx.coin] += tx.change || 0;
                        if (Math.abs(balances[tx.coin]) < 0.00000001) balances[tx.coin] = 0;
                        
                        while (yearIndex < years.length && tx.date > new Date(years[yearIndex], 11, 31, 23, 59, 59)) {
                            yearEndSnapshots[years[yearIndex]] = { ...balances };
                            yearIndex++;
                        }
                    }
                    
                    for (let i = yearIndex; i < years.length; i++) {
                        yearEndSnapshots[years[i]] = { ...balances };
                    }
                    
                    // Calcola totali EUR
                    const yearTotals = {};
                    for (const year of years) {
                        let totalEur = 0;
                        const snapshot = yearEndSnapshots[year] || {};
                        for (const [coin, amount] of Object.entries(snapshot)) {
                            if (amount <= 0) continue;
                            // ğŸš« Salta token LD* (duplicati Earn)
                            if (coin.startsWith('LD')) continue;
                            const price = getHistoricalPrice(coin, year);
                            totalEur += amount * price * EUR_USD;
                        }
                        yearTotals[year] = Math.round(totalEur * 100) / 100;
                    }
                    
                    // Salva
                    exchangeData['binance'] = {
                        transactions: allTransactions,
                        balances: yearEndSnapshots,
                        totals: yearTotals,
                        transactionCount: allTransactions.length,
                        isManual: false,
                        lastImport: new Date().toISOString(),
                        source: 'api'
                    };
                    
                    if (progressBar) progressBar.style.width = '100%';
                    if (progressText) progressText.textContent = `âœ… ${allTransactions.length} transazioni importate!`;
                    
                    saveExchangeDataToFirebase();
                    initExchangeGrid();
                    updateExchangeTotals();
                    
                    // Conta tipi di transazione
                    const summary = data.summary || {};
                    const deposits = summary.deposits || allTransactions.filter(t => t.type === 'deposit').length;
                    const withdrawals = summary.withdrawals || allTransactions.filter(t => t.type === 'withdrawal').length;
                    const dividends = summary.dividend || summary.dividends || allTransactions.filter(t => t.type === 'dividend').length;
                    const staking = summary.staking || allTransactions.filter(t => t.type === 'staking').length;
                    const earn = summary.earn || allTransactions.filter(t => t.type === 'interest').length;
                    const converts = summary.conversions || summary.converts || allTransactions.filter(t => t.type === 'convert' || t.type === 'dust').length;
                    const trades = summary.trades || allTransactions.filter(t => t.type === 'trade').length;
                    
                    setTimeout(() => {
                        alert(`âœ… Binance Tax API completato!\n\nğŸ“Š ${allTransactions.length} transazioni totali\nğŸ“¥ ${deposits} depositi\nğŸ“¤ ${withdrawals} prelievi\nğŸ ${dividends} distribuzione\nğŸ”„ ${converts} conversioni\nğŸ“ˆ ${trades} trades\nğŸ¥© ${staking} staking\nğŸ’° ${earn} earn`);
                    }, 500);
                    
                } catch (e) {
                    console.error('Binance Tax API error:', e);
                    if (progressText) progressText.textContent = 'âŒ Errore: ' + e.message;
                    
                    if (e.message.includes('Failed to fetch') || e.message.includes('non attivo')) {
                        alert('âš ï¸ Server non attivo!\n\nPer usare l\'API Binance:\n\n1. Scarica "binance-tax-server.js"\n2. Apri terminale nella cartella\n3. Esegui: node binance-tax-server.js\n4. Riprova\n\nOppure usa il metodo CSV/ZIP.');
                    } else {
                        alert('âŒ Errore: ' + e.message);
                    }
                }
            }
        }
        
        function toggleExchangeDropzone(exchId) {
            const dropzone = document.getElementById('dropzone-' + exchId);
            if (dropzone) {
                dropzone.style.display = dropzone.style.display === 'none' ? 'block' : 'none';
            }
        }
        
        function handleDragOver(e, exchId) {
            e.preventDefault();
            const dropzone = document.getElementById('dropzone-' + exchId);
            if (dropzone) {
                dropzone.style.borderColor = 'var(--green)';
                dropzone.style.background = 'rgba(0,230,118,0.1)';
            }
        }
        
        function handleDragLeave(e, exchId) {
            e.preventDefault();
            const dropzone = document.getElementById('dropzone-' + exchId);
            if (dropzone) {
                dropzone.style.borderColor = 'var(--border)';
                dropzone.style.background = 'transparent';
            }
        }
        
        async function handleDrop(e, exchId) {
            e.preventDefault();
            handleDragLeave(e, exchId);
            const files = e.dataTransfer.files;
            await processExchangeFiles(files, exchId);
        }
        
        async function handleFileSelect(e, exchId) {
            const files = e.target.files;
            await processExchangeFiles(files, exchId);
        }
        
        async function processExchangeFiles(files, exchId) {
            console.log('Processing files for', exchId, files.length, 'files');
            
            // Mostra stato caricamento
            const dropzone = document.getElementById('dropzone-' + exchId);
            if (dropzone) {
                dropzone.innerHTML = '<div style="font-size:32px;margin-bottom:8px;">â³</div><div style="color:var(--accent);font-size:13px;">Elaborazione in corso...</div>';
            }
            
            let allTransactions = [];
            
            try {
                for (const file of files) {
                    console.log('Processing file:', file.name, 'size:', file.size);
                    
                    if (file.name.endsWith('.zip')) {
                        // Estrai ZIP
                        const transactions = await processZipFile(file, exchId);
                        console.log('ZIP parsed:', transactions.length, 'transactions');
                        allTransactions.push(...transactions);
                    } else if (file.name.endsWith('.csv')) {
                        // Parse CSV direttamente
                        const text = await file.text();
                        console.log('CSV loaded, length:', text.length);
                        const transactions = parseExchangeCSV(text, exchId);
                        console.log('CSV parsed:', transactions.length, 'transactions');
                        allTransactions.push(...transactions);
                    }
                }
                
                console.log('Total transactions:', allTransactions.length);
                
                if (allTransactions.length > 0) {
                    // Salva transazioni (solo totali per risparmiare spazio)
                    if (!exchangeData[exchId]) {
                        exchangeData[exchId] = { transactions: [], balances: {}, totals: {} };
                    }
                    exchangeData[exchId].transactions = allTransactions;
                    
                    // Calcola saldi al 31/12
                    calculateExchangeBalances(exchId);
                    
                    // Aggiorna UI
                    initExchangeGrid();
                    updateExchangeTotals();
                    saveExchangeDataToFirebase();
                    
                    alert('âœ… ' + exchId.toUpperCase() + ': Importate ' + allTransactions.length + ' transazioni!');
                } else {
                    alert('âŒ Nessuna transazione trovata nei file. Controlla la console (F12) per i dettagli.');
                    initExchangeGrid(); // Ripristina dropzone
                }
            } catch (err) {
                console.error('Error processing files:', err);
                alert('âŒ Errore: ' + err.message);
                initExchangeGrid(); // Ripristina dropzone
            }
        }
        
        async function processZipFile(file, exchId) {
            // Usa JSZip (giÃ  caricato nell'head)
            try {
                console.log('Processing ZIP file:', file.name);
                const zip = await JSZip.loadAsync(file);
                let allTransactions = [];
                
                for (const [path, zipEntry] of Object.entries(zip.files)) {
                    console.log('ZIP entry:', path);
                    if (path.endsWith('.csv') && !path.includes('__MACOSX') && !path.includes('.DS_Store')) {
                        const text = await zipEntry.async('text');
                        console.log('Parsing CSV:', path, 'length:', text.length);
                        const transactions = parseExchangeCSV(text, exchId);
                        console.log('Parsed', transactions.length, 'transactions from', path);
                        allTransactions.push(...transactions);
                    }
                }
                
                return allTransactions;
            } catch (e) {
                console.error('ZIP processing error:', e);
                alert('Errore lettura ZIP: ' + e.message);
                return [];
            }
        }
        
        function loadScript(src) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = src;
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }
        
        function parseExchangeCSV(text, exchId) {
            // Parser generico che adatta al formato dell'exchange
            // Rimuovi BOM (byte order mark) se presente
            const cleanText = text.replace(/^\uFEFF/, '').trim();
            const lines = cleanText.split('\n');
            console.log('parseExchangeCSV for', exchId, '- lines:', lines.length);
            
            if (lines.length < 2) {
                console.log('Not enough lines in CSV');
                return [];
            }
            
            // Pulisci header da BOM e caratteri speciali
            let header = lines[0].toLowerCase().replace(/^\uFEFF/, '').replace(/[^\x20-\x7E,]/g, '').trim();
            console.log('Header (cleaned):', header.substring(0, 120));
            
            // === BINANCE ===
            if (header.includes('utc_time') && header.includes('coin')) {
                console.log('Detected Binance format');
                return parseBinanceCSV(lines);
            }
            
            // === BITGET ===
            if (header.includes('order') && header.includes('date') && header.includes('coin') && header.includes('amount')) {
                console.log('Detected Bitget format');
                return parseBitgetCSV(lines);
            }
            
            // === CRYPTO.COM APP ===
            if (header.includes('timestamp') && header.includes('transaction description') && header.includes('currency')) {
                console.log('Detected Crypto.com App format');
                return parseCryptoComAppCSV(lines);
            }
            
            // === CRYPTO.COM EXCHANGE ===
            if (header.includes('event_time_display') && header.includes('instrument_name') && header.includes('journal_type')) {
                console.log('Detected Crypto.com Exchange format');
                return parseCryptoComExchangeCSV(lines);
            }
            
            // === COINBASE ===
            if (header.includes('transaction type') && header.includes('asset') && header.includes('quantity')) {
                console.log('Detected Coinbase format');
                return parseCoinbaseCSV(lines);
            }
            // Coinbase - cerca header nelle prime righe
            for (let i = 0; i < Math.min(10, lines.length); i++) {
                const testHeader = lines[i].toLowerCase();
                if (testHeader.includes('transaction type') && testHeader.includes('asset') && testHeader.includes('quantity')) {
                    console.log('Detected Coinbase format at line', i);
                    return parseCoinbaseCSV(lines.slice(i));
                }
            }
            
            // === COSMOS ===
            if (header.includes('tx_type') && header.includes('received_amount') && header.includes('received_currency')) {
                console.log('Detected Cosmos format');
                return parseCosmosCSV(lines);
            }
            
            // === BYBIT AssetChangeDetails ===
            if (header.includes('uid') && header.includes('currency') && header.includes('change') && header.includes('wallet balance')) {
                console.log('Detected Bybit AssetChangeDetails format');
                return parseBybitAssetChangeCSV(lines);
            }
            // Bybit - cerca header nelle prime righe (salta riga UID)
            for (let i = 0; i < Math.min(5, lines.length); i++) {
                const testHeader = lines[i].toLowerCase();
                if (testHeader.includes('uid') && testHeader.includes('currency') && testHeader.includes('change')) {
                    console.log('Detected Bybit AssetChangeDetails at line', i);
                    return parseBybitAssetChangeCSV(lines.slice(i));
                }
            }
            
            // === BYBIT Deposit/Withdraw History ===
            for (let i = 0; i < Math.min(5, lines.length); i++) {
                const testHeader = lines[i].toLowerCase();
                if (testHeader.includes('uid') && testHeader.includes('date') && testHeader.includes('type') && testHeader.includes('asset') && testHeader.includes('amount')) {
                    console.log('Detected Bybit DepositWithdraw at line', i);
                    return parseBybitDepositWithdrawCSV(lines.slice(i));
                }
            }
            
            // === BITPANDA ===
            // Cerca header nelle prime 10 righe (salta disclaimer)
            for (let i = 0; i < Math.min(10, lines.length); i++) {
                const testHeader = lines[i].toLowerCase();
                if (testHeader.includes('transaction id') && testHeader.includes('transaction type') && testHeader.includes('amount asset')) {
                    console.log('Detected Bitpanda format at line', i);
                    return parseBitpandaCSV(lines.slice(i));
                }
            }
            
            // === TATAX FORMAT ===
            // Symbol,TokenAddress,TimeStamp,MovementType,Quantity,Countervalue,...
            if (header.includes('symbol') && header.includes('movementtype') && header.includes('quantity')) {
                console.log('Detected Tatax format');
                return parseTataxCSV(lines);
            }
            
            console.log('No matching parser found, using generic');
            return parseGenericCSV(lines, exchId);
        }
        
        // === CRYPTO.COM APP PARSER ===
        function parseCryptoComAppCSV(lines) {
            // Timestamp (UTC),Transaction Description,Currency,Amount,To Currency,To Amount,...,Transaction Kind
            const transactions = [];
            console.log('Parsing Crypto.com App CSV, lines:', lines.length);
            
            for (let i = 1; i < lines.length; i++) {
                const cols = parseCSVLine(lines[i]);
                if (cols.length < 10) continue;
                
                const [timestamp, description, currency, amount, toCurrency, toAmount, nativeCurrency, nativeAmount, nativeUsd, txKind] = cols;
                const date = new Date(timestamp);
                if (isNaN(date.getTime())) continue;
                
                // Prima valuta (puÃ² essere + o -)
                const amountNum = parseFloat(amount) || 0;
                if (amountNum !== 0 && currency && currency !== '-') {
                    transactions.push({
                        date: date,
                        account: 'app',
                        operation: description,
                        coin: currency,
                        change: amountNum,
                        remark: txKind || ''
                    });
                }
                
                // Seconda valuta (To Currency / To Amount) - solo se presente e diversa dalla prima
                const toAmountNum = parseFloat(toAmount) || 0;
                if (toAmountNum !== 0 && toCurrency && toCurrency !== '-' && toCurrency !== currency) {
                    transactions.push({
                        date: date,
                        account: 'app',
                        operation: description,
                        coin: toCurrency,
                        change: toAmountNum, // To Amount Ã¨ sempre positivo (ricevuto)
                        remark: txKind || ''
                    });
                }
            }
            console.log('Parsed', transactions.length, 'Crypto.com App transactions');
            return transactions;
        }
        
        // === CRYPTO.COM EXCHANGE PARSER ===
        function parseCryptoComExchangeCSV(lines) {
            // event_time_display,instrument_name,journal_id,journal_type,...,transaction_qty,...
            const transactions = [];
            console.log('Parsing Crypto.com Exchange CSV, lines:', lines.length);
            
            for (let i = 1; i < lines.length; i++) {
                const cols = parseCSVLine(lines[i]);
                if (cols.length < 8) continue;
                
                const [eventTime, instrumentName, journalId, journalType, orderId, side, takerSide, transactionQty] = cols;
                const date = new Date(eventTime);
                if (isNaN(date.getTime())) continue;
                
                const qty = parseFloat(transactionQty) || 0;
                if (qty === 0) continue;
                
                transactions.push({
                    date: date,
                    account: 'exchange',
                    operation: journalType,
                    coin: instrumentName,
                    change: qty,
                    remark: ''
                });
            }
            console.log('Parsed', transactions.length, 'Crypto.com Exchange transactions');
            return transactions;
        }
        
        // === COINBASE PARSER ===
        function parseCoinbaseCSV(lines) {
            // ID,Timestamp,Transaction Type,Asset,Quantity Transacted,...
            const transactions = [];
            console.log('Parsing Coinbase CSV, lines:', lines.length);
            
            for (let i = 1; i < lines.length; i++) {
                const cols = parseCSVLine(lines[i]);
                if (cols.length < 5) continue;
                
                const [id, timestamp, txType, asset, quantity] = cols;
                const date = new Date(timestamp);
                if (isNaN(date.getTime())) continue;
                
                let qty = parseFloat(quantity) || 0;
                if (qty === 0) continue;
                
                // Determina segno basato sul tipo
                const txTypeLower = txType.toLowerCase();
                if (txTypeLower.includes('sell') || txTypeLower.includes('send') || txTypeLower.includes('withdraw')) {
                    qty = -Math.abs(qty);
                } else {
                    qty = Math.abs(qty);
                }
                
                transactions.push({
                    date: date,
                    account: 'coinbase',
                    operation: txType,
                    coin: asset,
                    change: qty,
                    remark: ''
                });
            }
            console.log('Parsed', transactions.length, 'Coinbase transactions');
            return transactions;
        }
        
        // === COSMOS PARSER ===
        function parseCosmosCSV(lines) {
            // timestamp,tx_type,received_amount,received_currency,sent_amount,sent_currency,...
            const transactions = [];
            console.log('Parsing Cosmos CSV, lines:', lines.length);
            
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].replace(/\r/g, '');
                const cols = parseCSVLine(line);
                if (cols.length < 6) continue;
                
                const [timestamp, txType, receivedAmount, receivedCurrency, sentAmount, sentCurrency] = cols;
                const date = new Date(timestamp);
                if (isNaN(date.getTime())) continue;
                
                // Received
                const recvAmt = parseFloat(receivedAmount) || 0;
                if (recvAmt > 0 && receivedCurrency) {
                    transactions.push({
                        date: date,
                        account: 'cosmos',
                        operation: txType,
                        coin: receivedCurrency.toUpperCase(),
                        change: recvAmt,
                        remark: ''
                    });
                }
                
                // Sent
                const sentAmt = parseFloat(sentAmount) || 0;
                if (sentAmt > 0 && sentCurrency) {
                    transactions.push({
                        date: date,
                        account: 'cosmos',
                        operation: txType,
                        coin: sentCurrency.toUpperCase(),
                        change: -sentAmt,
                        remark: ''
                    });
                }
            }
            console.log('Parsed', transactions.length, 'Cosmos transactions');
            return transactions;
        }
        
        // === BYBIT ASSET CHANGE DETAILS PARSER ===
        function parseBybitAssetChangeCSV(lines) {
            // Uid,Currency,Contract,Type,Direction,...,Change,...,Time(UTC)
            const transactions = [];
            console.log('Parsing Bybit AssetChange CSV, lines:', lines.length);
            
            // Trova indice colonne
            const header = lines[0].toLowerCase();
            const cols = header.split(',');
            const currencyIdx = cols.findIndex(c => c.includes('currency'));
            const changeIdx = cols.findIndex(c => c === 'change');
            const timeIdx = cols.findIndex(c => c.includes('time'));
            const typeIdx = cols.findIndex(c => c === 'type');
            
            if (currencyIdx === -1 || changeIdx === -1 || timeIdx === -1) {
                console.log('Cannot find required columns in Bybit CSV');
                return [];
            }
            
            for (let i = 1; i < lines.length; i++) {
                const parts = lines[i].split(',');
                if (parts.length <= Math.max(currencyIdx, changeIdx, timeIdx)) continue;
                
                const currency = parts[currencyIdx];
                const change = parseFloat(parts[changeIdx]) || 0;
                const timeStr = parts[timeIdx];
                const txType = typeIdx >= 0 ? parts[typeIdx] : '';
                
                const date = new Date(timeStr);
                if (isNaN(date.getTime()) || change === 0) continue;
                
                transactions.push({
                    date: date,
                    account: 'bybit',
                    operation: txType,
                    coin: currency,
                    change: change,
                    remark: ''
                });
            }
            console.log('Parsed', transactions.length, 'Bybit AssetChange transactions');
            return transactions;
        }
        
        // === BYBIT DEPOSIT/WITHDRAW PARSER ===
        function parseBybitDepositWithdrawCSV(lines) {
            // Uid,Date,Type,Asset,Chain,Amount,...
            const transactions = [];
            console.log('Parsing Bybit DepositWithdraw CSV, lines:', lines.length);
            
            for (let i = 1; i < lines.length; i++) {
                const cols = lines[i].split(',');
                if (cols.length < 6) continue;
                
                const [uid, dateStr, txType, asset, chain, amount] = cols;
                const date = new Date(dateStr);
                if (isNaN(date.getTime())) continue;
                
                let qty = parseFloat(amount) || 0;
                if (qty === 0) continue;
                
                // Withdraw = negativo
                if (txType.toLowerCase().includes('withdraw')) {
                    qty = -Math.abs(qty);
                }
                
                transactions.push({
                    date: date,
                    account: 'bybit',
                    operation: txType,
                    coin: asset,
                    change: qty,
                    remark: chain
                });
            }
            console.log('Parsed', transactions.length, 'Bybit DepositWithdraw transactions');
            return transactions;
        }
        
        // === BITPANDA PARSER ===
        function parseBitpandaCSV(lines) {
            // "Transaction ID",Timestamp,"Transaction Type",In/Out,"Amount Fiat",Fiat,"Amount Asset",Asset,...
            const transactions = [];
            console.log('Parsing Bitpanda CSV, lines:', lines.length);
            
            for (let i = 1; i < lines.length; i++) {
                const cols = parseCSVLine(lines[i]);
                if (cols.length < 8) continue;
                
                const [txId, timestamp, txType, inOut, amountFiat, fiat, amountAsset, asset] = cols;
                const date = new Date(timestamp);
                if (isNaN(date.getTime())) continue;
                
                let qty = parseFloat(amountAsset) || 0;
                if (qty === 0 || !asset || asset === '-') continue;
                
                // In/Out determina segno
                if (inOut.toLowerCase() === 'outgoing') {
                    qty = -Math.abs(qty);
                }
                
                transactions.push({
                    date: date,
                    account: 'bitpanda',
                    operation: txType,
                    coin: asset,
                    change: qty,
                    remark: ''
                });
            }
            console.log('Parsed', transactions.length, 'Bitpanda transactions');
            return transactions;
        }
        
        function parseBitgetCSV(lines) {
            // Formato: order,Date,Coin,Type,Amount,Fee,Available
            const transactions = [];
            console.log('Parsing Bitget CSV, lines:', lines.length);
            console.log('Header:', lines[0]);
            console.log('First data line:', lines[1]);
            
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i];
                if (!line.trim()) continue;
                
                // Parse CSV (puÃ² avere tab iniziale)
                const cleanLine = line.replace(/^\t/, '').trim();
                const cols = cleanLine.split(',');
                
                if (cols.length < 5) {
                    console.log('Skipping line (not enough cols):', cols.length);
                    continue;
                }
                
                const [order, dateStr, coin, type, amount, fee, available] = cols;
                
                // Parse date (formato: YYYY-MM-DD HH:MM:SS)
                const date = new Date(dateStr);
                if (isNaN(date.getTime())) {
                    console.log('Invalid date:', dateStr);
                    continue;
                }
                
                const amountNum = parseFloat(amount) || 0;
                
                transactions.push({
                    date: date,
                    account: 'spot',
                    operation: type,
                    coin: coin,
                    change: amountNum, // GiÃ  con segno corretto
                    remark: ''
                });
            }
            
            console.log('Parsed', transactions.length, 'Bitget transactions');
            if (transactions.length > 0) {
                console.log('First tx:', transactions[0]);
                console.log('Last tx:', transactions[transactions.length - 1]);
            }
            
            return transactions;
        }
        
        function parseBinanceCSV(lines) {
            // Formato: "User_ID","UTC_Time","Account","Operation","Coin","Change","Remark"
            const transactions = [];
            console.log('Parsing Binance CSV, lines:', lines.length);
            console.log('Header:', lines[0]);
            console.log('First data line:', lines[1]);
            
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i];
                if (!line.trim()) continue;
                
                // Parse CSV con virgolette
                const cols = parseCSVLine(line);
                if (cols.length < 6) {
                    console.log('Skipping line (not enough cols):', cols.length, line.substring(0, 50));
                    continue;
                }
                
                const [userId, utcTime, account, operation, coin, change, remark] = cols;
                
                // Parse date
                const date = new Date(utcTime);
                if (isNaN(date.getTime())) {
                    console.log('Invalid date:', utcTime);
                    continue;
                }
                
                const changeNum = parseFloat(change) || 0;
                
                transactions.push({
                    date: date,
                    account: account,
                    operation: operation,
                    coin: coin,
                    change: changeNum,
                    remark: remark || ''
                });
            }
            
            console.log('Parsed', transactions.length, 'transactions');
            if (transactions.length > 0) {
                console.log('First tx:', transactions[0]);
                console.log('Last tx:', transactions[transactions.length - 1]);
            }
            
            return transactions;
        }
        
        function parseGenericCSV(lines, exchId) {
            // Parser generico - cerca colonne comuni
            console.log('Using generic parser for', exchId);
            return [];
        }
        
        // === TATAX PARSER ===
        function parseTataxCSV(lines) {
            // Format: "Symbol","TokenAddress","TimeStamp","MovementType","Quantity","Countervalue","SymbolCountervalue","SourceCountervalue","SourceSymbolCountervalue"
            const transactions = [];
            console.log('Parsing Tatax CSV, lines:', lines.length);
            
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i];
                if (!line.trim()) continue;
                
                const cols = parseCSVLine(line);
                if (cols.length < 5) continue;
                
                let symbol = cols[0] || '';
                const timestamp = cols[2] || '';
                const moveType = (cols[3] || '').toUpperCase();
                let quantity = cols[4] || '0';
                
                // Parse date
                const date = new Date(timestamp);
                if (isNaN(date.getTime())) continue;
                
                // Pulisci symbol (rimuovi .LENDING@BINANCE, .STAKING@BINANCE)
                symbol = symbol.replace('.LENDING@BINANCE', '').replace('.STAKING@BINANCE', '');
                
                // Parse quantity (gestisce notazione scientifica come "1E+2")
                let qtyNum = parseFloat(quantity);
                if (isNaN(qtyNum)) qtyNum = 0;
                
                // Mappa MovementType alle nostre categorie
                let type = 'other';
                if (moveType === 'DEPOSIT') type = 'deposit';
                else if (moveType === 'WITHDRAWAL') type = 'withdrawal';
                else if (moveType === 'CREDIT') type = 'credit';
                else if (moveType === 'DEBIT') type = 'debit';
                else if (moveType === 'EXCHANGE_FEE') type = 'fee';
                else if (moveType === 'EARN') type = 'earn';
                else if (moveType.includes('FEE')) type = 'fee';
                
                transactions.push({
                    date: date,
                    type: type,
                    coin: symbol,
                    change: qtyNum,
                    operation: moveType
                });
            }
            
            console.log('Tatax parsed', transactions.length, 'transactions');
            if (transactions.length > 0) {
                console.log('First tx:', transactions[0]);
                console.log('Last tx:', transactions[transactions.length - 1]);
            }
            
            return transactions;
        }
        
        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            result.push(current.trim());
            
            return result;
        }
        
        function calculateExchangeBalances(exchId) {
            const data = exchangeData[exchId];
            if (!data || !data.transactions) {
                console.log('No transactions for', exchId);
                return;
            }
            
            console.log('Calculating balances for', exchId, 'with', data.transactions.length, 'transactions');
            
            // Ordina transazioni per data
            data.transactions.sort((a, b) => a.date - b.date);
            
            // Calcola saldi cumulativi
            const balances = {}; // { coin: amount }
            const yearEndBalances = {}; // { 2021: { BTC: 0.5, ... }, ... }
            const yearEndTotals = {}; // { 2021: 12345, ... }
            
            const years = [2021, 2022, 2023, 2024, 2025, 2026];
            let currentYearIndex = 0;
            
            // Prima trova la data piÃ¹ vecchia
            const firstDate = data.transactions[0]?.date;
            const lastDate = data.transactions[data.transactions.length - 1]?.date;
            console.log('Date range:', firstDate, 'to', lastDate);
            
            for (const tx of data.transactions) {
                // Aggiorna saldo
                if (!balances[tx.coin]) balances[tx.coin] = 0;
                balances[tx.coin] += tx.change;
                
                // Controlla se abbiamo superato la fine dell'anno
                while (currentYearIndex < years.length && tx.date > new Date(years[currentYearIndex], 11, 31, 23, 59, 59)) {
                    // Salva snapshot al 31/12
                    yearEndBalances[years[currentYearIndex]] = { ...balances };
                    console.log('Snapshot for', years[currentYearIndex], '- coins:', Object.keys(balances).length);
                    currentYearIndex++;
                }
            }
            
            // Salva ultimi anni rimasti
            for (let i = currentYearIndex; i < years.length; i++) {
                yearEndBalances[years[i]] = { ...balances };
            }
            
            // Log dei saldi finali
            console.log('Final balances (coins with value):', 
                Object.entries(balances).filter(([c, a]) => a > 0.0001).map(([c, a]) => c + ': ' + a.toFixed(4)).join(', ').substring(0, 200));
            
            // Calcola totali EUR per ogni anno
            for (const year of years) {
                const yb = yearEndBalances[year] || {};
                let totalEur = 0;
                let coinsWithValue = [];
                
                for (const [coin, amount] of Object.entries(yb)) {
                    if (amount <= 0) continue;
                    const price = getHistoricalPrice(coin, year);
                    if (price > 0) {
                        const valueUsd = amount * price;
                        const valueEur = valueUsd * EUR_USD;
                        totalEur += valueEur;
                        if (valueEur > 10) { // Solo coin > â‚¬10
                            coinsWithValue.push(coin + ': â‚¬' + valueEur.toFixed(0));
                        }
                    }
                }
                
                yearEndTotals[year] = Math.round(totalEur * 100) / 100; // Arrotonda a 2 decimali
                if (coinsWithValue.length > 0) {
                    console.log('Year', year, '- Top coins:', coinsWithValue.slice(0, 10).join(', '));
                }
            }
            
            data.balances = yearEndBalances;
            data.totals = yearEndTotals;
            
            console.log('Year-end totals (EUR):', yearEndTotals);
        }
        
        function getHistoricalPrice(coin, year, chain = '') {
            const coinUpper = coin.toUpperCase();
            
            // PulseChain cloni = prezzo 0 (solo PLS, PLSX, HEX, INC hanno valore)
            if (chain === 'PulseChain' && !['PLS', 'PLSX', 'HEX', 'INC', 'WPLS'].includes(coinUpper)) {
                return 0;
            }
            
            // Usa i prezzi storici dalla YEAR_END_PRICES se disponibili
            const cgId = SYMBOL_TO_CG[coinUpper];
            if (cgId && YEAR_END_PRICES[cgId] && YEAR_END_PRICES[cgId][year]) {
                return YEAR_END_PRICES[cgId][year];
            }
            
            // Stablecoins - sempre $1
            if (['USDT', 'USDC', 'BUSD', 'FDUSD', 'DAI', 'UST', 'USTC', 'TUSD', 'USDP', 'GUSD', 'PAX', 'FRAX'].includes(coinUpper)) {
                return 1.0;
            }
            
            // EUR token
            if (coinUpper === 'EUR' || coinUpper === 'EUROC' || coinUpper === 'EURT') {
                return 1 / EUR_USD;
            }
            
            // BTC variations
            if (['BTC', 'WBTC', 'BTCB'].includes(coinUpper)) {
                return YEAR_END_PRICES['bitcoin']?.[year] || 50000;
            }
            
            // ETH variations
            if (['ETH', 'WETH', 'BETH', 'STETH'].includes(coinUpper)) {
                return YEAR_END_PRICES['ethereum']?.[year] || 2000;
            }
            
            // BNB variations  
            if (['BNB', 'WBNB'].includes(coinUpper)) {
                return YEAR_END_PRICES['binancecoin']?.[year] || 300;
            }
            
            // Monete molto piccole o sconosciute - log per debug
            // console.log('Unknown coin price:', coinUpper, 'year:', year);
            
            return 0;
        }
        
        function updateExchangeTotals() {
            const years = [2021, 2022, 2023, 2024, 2025, 2026];
            const totals = { 2021: 0, 2022: 0, 2023: 0, 2024: 0, 2025: 0, 2026: 0 };
            
            for (const exchId of Object.keys(exchangeData)) {
                const data = exchangeData[exchId];
                if (data && data.totals) {
                    for (const y of years) {
                        const val = data.totals[y];
                        if (val && !isNaN(val)) {
                            totals[y] += val;
                        }
                    }
                }
            }
            
            // Arrotonda a 2 decimali e gestisci NaN
            for (const y of years) {
                totals[y] = isNaN(totals[y]) ? 0 : Math.round(totals[y] * 100) / 100;
            }
            
            // Aggiorna UI
            for (const y of years) {
                const el = document.getElementById('exchTotal' + y);
                if (el) {
                    el.textContent = 'â‚¬' + formatEUR(totals[y]);
                }
            }
            
            // Aggiorna exchangeValues per Tax Report
            exchangeValues = totals;
            
            // Aggiorna anche gli input nel Tax Report se visibili
            loadExchangeValuesUI();
        }
        
        function clearExchangeData(exchId) {
            if (!confirm('Cancellare i dati di ' + exchId.toUpperCase() + '?')) return;
            delete exchangeData[exchId];
            initExchangeGrid();
            updateExchangeTotals();
            updateExchangeCount();
            saveExchangeDataToFirebase();
        }
        
        function zeroExchangeData(exchId) {
            if (!confirm('Impostare tutti i valori di ' + exchId.toUpperCase() + ' a â‚¬0?\n(Usa se hai prelevato tutto dall\'exchange)')) return;
            
            // Mantieni la struttura ma azzera tutti i totali
            if (!exchangeData[exchId]) {
                exchangeData[exchId] = {};
            }
            exchangeData[exchId].totals = { 2021: 0, 2022: 0, 2023: 0, 2024: 0, 2025: 0, 2026: 0 };
            exchangeData[exchId].balances = {};
            exchangeData[exchId].transactions = [];
            exchangeData[exchId].transactionCount = 0;
            exchangeData[exchId].isZeroed = true; // Flag per indicare che Ã¨ stato azzerato manualmente
            exchangeData[exchId].isManual = true;
            
            initExchangeGrid();
            updateExchangeTotals();
            updateExchangeCount();
            saveExchangeDataToFirebase();
            alert('âœ… ' + exchId.toUpperCase() + ' impostato a â‚¬0 per tutti gli anni!');
        }
        
        function updateManualExchangeValue(exchId, year, value) {
            // Aggiorna valore in memoria (non salva ancora)
            if (!exchangeData[exchId]) {
                exchangeData[exchId] = { totals: {}, balances: {}, transactions: [], isManual: true };
            }
            if (!exchangeData[exchId].totals) {
                exchangeData[exchId].totals = {};
            }
            exchangeData[exchId].totals[year] = parseFloat(value) || 0;
            exchangeData[exchId].isManual = true;
            exchangeData[exchId].isZeroed = false;
            
            // Aggiorna totali in tempo reale
            updateExchangeTotals();
        }
        
        function saveManualExchangeValues(exchId) {
            // Leggi tutti i valori dagli input
            const years = [2021, 2022, 2023, 2024, 2025, 2026];
            if (!exchangeData[exchId]) {
                exchangeData[exchId] = { totals: {}, balances: {}, transactions: [], isManual: true };
            }
            
            for (const y of years) {
                const input = document.getElementById('manual-' + exchId + '-' + y);
                if (input) {
                    exchangeData[exchId].totals[y] = parseFloat(input.value) || 0;
                }
            }
            exchangeData[exchId].isManual = true;
            exchangeData[exchId].isZeroed = false;
            exchangeData[exchId].transactionCount = 0; // Non basato su CSV
            
            updateExchangeTotals();
            updateExchangeCount();
            saveExchangeDataToFirebase();
            alert('âœ… Valori manuali salvati per ' + exchId.toUpperCase() + '!');
        }
        
        function enableManualEntry(exchId) {
            // Abilita inserimento manuale per exchange senza dati
            if (!exchangeData[exchId]) {
                exchangeData[exchId] = { 
                    totals: { 2021: 0, 2022: 0, 2023: 0, 2024: 0, 2025: 0, 2026: 0 }, 
                    balances: {}, 
                    transactions: [], 
                    isManual: true 
                };
            }
            initExchangeGrid();
        }
        
        async function clearAllExchangeData() {
            if (!confirm('Cancellare TUTTI i dati degli exchange (inclusi dati API vecchi)?')) return;
            exchangeData = {};
            await resetAllBinanceLegacyData();
            initExchangeGrid();
            updateExchangeTotals();
            updateExchangeCount();
            saveExchangeDataToFirebase();
            alert('âœ… Tutti i dati exchange cancellati!');
        }
        
        function recalculateAllExchanges() {
            let recalculated = 0;
            for (const exchId of Object.keys(exchangeData)) {
                // Solo ricalcola se ci sono transazioni in memoria
                if (exchangeData[exchId].transactions && exchangeData[exchId].transactions.length > 0) {
                    calculateExchangeBalances(exchId);
                    recalculated++;
                }
            }
            initExchangeGrid();
            updateExchangeTotals();
            updateExchangeCount();
            if (recalculated > 0) {
                saveExchangeDataToFirebase();
                alert('âœ… Ricalcolati ' + recalculated + ' exchange!');
            } else {
                alert('âš ï¸ Nessuna transazione in memoria da ricalcolare.\nI totali salvati sono giÃ  visualizzati.');
            }
        }
        
        async function saveExchangeDataToFirebase() {
            // PRIMA salva in localStorage (sempre!)
            saveExchangeTransactionsToLocalStorage();
            
            // POI prova a salvare in Firebase
            try {
                const dataToSave = {};
                for (const exchId of Object.keys(exchangeData)) {
                    const data = exchangeData[exchId];
                    dataToSave[exchId] = {
                        totals: data.totals || {},
                        balances: data.balances || {},
                        realBalances: data.realBalances || null,
                        tokenPrices: data.tokenPrices || null,
                        transactionCount: data.transactions ? data.transactions.length : 0,
                        isZeroed: data.isZeroed || false,
                        isManual: data.isManual || false,
                        lastImport: data.lastImport || new Date().toISOString(),
                        source: data.source || 'manual'
                    };
                }
                
                await db.collection('cryptofolio').doc('exchanges').set({
                    data: dataToSave,
                    lastUpdate: new Date().toISOString()
                });
                console.log('âœ… Exchange data saved to Firebase');
            } catch (e) {
                console.error('Exchange Firebase save error:', e);
            }
        }
        
        function saveExchangeTransactionsToLocalStorage() {
            try {
                // Salva TUTTE le transazioni per riconciliazione
                const txToSave = {};
                let totalSaved = 0;
                
                for (const exchId of Object.keys(exchangeData)) {
                    const data = exchangeData[exchId];
                    if (data.transactions && data.transactions.length > 0) {
                        // Salva tutte le transazioni (max 5000 per exchange)
                        const toSave = data.transactions.slice(0, 5000).map(tx => ({
                            date: tx.date instanceof Date ? tx.date.toISOString() : tx.date,
                            operation: tx.operation || '',
                            type: tx.type || '',
                            coin: tx.coin || '',
                            amount: parseFloat(tx.amount) || Math.abs(parseFloat(tx.change)) || 0,
                            change: parseFloat(tx.change) || 0,
                            amountEur: parseFloat(tx.amountEur) || 0
                        }));
                        
                        txToSave[exchId] = toSave;
                        totalSaved += toSave.length;
                        console.log(`ğŸ’¾ ${exchId}: ${toSave.length} transazioni`);
                    }
                }
                
                localStorage.setItem('cryptofolio_exchange_tx', JSON.stringify(txToSave));
                console.log(`ğŸ’¾ Totale ${totalSaved} transazioni salvate in localStorage`);
                
                // Conferma visiva
                if (totalSaved > 0) {
                    console.log('âœ… Transazioni pronte per riconciliazione!');
                }
            } catch (e) {
                console.warn('Errore salvataggio transazioni localStorage:', e);
                alert('âš ï¸ Errore salvataggio: ' + e.message);
            }
        }
        
        function loadExchangeTransactionsFromLocalStorage() {
            try {
                const saved = localStorage.getItem('cryptofolio_exchange_tx');
                if (!saved) return;
                
                const txData = JSON.parse(saved);
                let totalLoaded = 0;
                
                for (const exchId of Object.keys(txData)) {
                    if (!exchangeData[exchId]) {
                        exchangeData[exchId] = { transactions: [], totals: {}, balances: {} };
                    }
                    
                    // Converti date da stringa a Date e assicura amount
                    exchangeData[exchId].transactions = txData[exchId].map(tx => ({
                        ...tx,
                        date: new Date(tx.date),
                        amount: parseFloat(tx.amount) || Math.abs(parseFloat(tx.change)) || 0,
                        change: parseFloat(tx.change) || 0,
                        amountEur: parseFloat(tx.amountEur) || 0
                    }));
                    totalLoaded += txData[exchId].length;
                }
                
                console.log(`ğŸ“‚ Caricate ${totalLoaded} transazioni exchange da localStorage`);
            } catch (e) {
                console.warn('Errore caricamento transazioni localStorage:', e);
            }
        }
        
        async function loadExchangeDataFromFirebase() {
            try {
                const doc = await db.collection('cryptofolio').doc('exchanges').get();
                if (doc.exists) {
                    const data = doc.data();
                    const savedData = data.data || {};
                    
                    // Carica solo totali e balances da Firebase
                    for (const exchId of Object.keys(savedData)) {
                        exchangeData[exchId] = {
                            transactions: [], // Vuoto - verrÃ  caricato da localStorage
                            totals: savedData[exchId].totals || {},
                            balances: savedData[exchId].balances || {},
                            realBalances: savedData[exchId].realBalances || null,
                            tokenPrices: savedData[exchId].tokenPrices || null,
                            transactionCount: savedData[exchId].transactionCount || 0,
                            isZeroed: savedData[exchId].isZeroed || false,
                            isManual: savedData[exchId].isManual || false,
                            lastImport: savedData[exchId].lastImport || null,
                            source: savedData[exchId].source || 'manual'
                        };
                    }
                    
                    console.log('âœ… Exchange data loaded from Firebase:', Object.keys(exchangeData).length, 'exchanges');
                }
                
                // SEMPRE carica transazioni da localStorage (anche se Firebase Ã¨ vuoto)
                loadExchangeTransactionsFromLocalStorage();
                
            } catch (e) {
                console.error('Exchange Firebase load error:', e);
                // Prova comunque a caricare da localStorage
                loadExchangeTransactionsFromLocalStorage();
            }
        }
        
        // ==================== LEGACY CLEANUP ====================
        async function cleanupLegacyBinanceData() {
            // Pulisce i vecchi dati API Binance da Firebase
            try {
                const doc = await db.collection('fiscal').doc('binance_live').get();
                if (doc.exists) {
                    await db.collection('fiscal').doc('binance_live').delete();
                    console.log('ğŸ§¹ Cleaned up legacy Binance API data from Firebase');
                }
                // Reset local data
                binanceData = { balances: { spot: [], earn: [], staking: [] }, totals: { spot: 0, earn: 0, staking: 0 }, lastUpdate: null };
            } catch (e) {
                console.log('No legacy Binance data to clean');
            }
        }
        
        // Funzioni API Binance rimosse - usiamo solo CSV
        
        function updateExchangeCount() {
            // Conta exchange con dati (transazioni in memoria O dati salvati da Firebase O manuali)
            let count = 0;
            for (const exchId of Object.keys(exchangeData)) {
                const data = exchangeData[exchId];
                const hasTx = data.transactions && data.transactions.length > 0;
                const hasData = hasTx || data.transactionCount > 0 || data.isZeroed || data.isManual || (data.totals && Object.values(data.totals).some(v => v > 0));
                if (hasData) count++;
            }
            document.getElementById('exchangeCount').textContent = count;
        }
        
        async function resetAllBinanceLegacyData() {
            // Resetta i vecchi dati API Binance in Firebase
            binanceData = { balances: { spot: [], earn: [], staking: [] }, totals: { spot: 0, earn: 0, staking: 0 }, lastUpdate: null };
            try {
                await db.collection('fiscal').doc('binance_live').delete();
                console.log('âœ… Binance legacy API data deleted');
            } catch(e) {
                console.log('No legacy binance data to delete');
            }
            updateExchangeCount();
        }
        
        // ==================== INIT ====================
        async function init() {
            loadSettings();
            await loadFromFirebase();
            await cleanupLegacyBinanceData(); // Pulisce vecchi dati API
            await loadExchangeDataFromFirebase();
            loadWalletTransactions(); // Carica transazioni wallet
            initChainSelector();
            initExchangeGrid();
            updateBlacklist();
            updateWalletsList();
            updateWalletSelect();
            updateApiCount();
            updateExchangeCount();
            updateExchangeTotals();
            loadNFTDataFromLocalStorage(); // Carica NFT salvati
            
            // Mostra API key se configurata
            if (apiKeys.moralis && apiKeys.etherscan) {
                document.getElementById('apiKey').value = 'âœ“ Moralis + Etherscan';
            } else if (apiKeys.moralis) {
                document.getElementById('apiKey').value = 'âœ“ Moralis configurato';
            } else if (apiKeys.etherscan) {
                document.getElementById('apiKey').value = 'âœ“ Etherscan configurato';
            } else {
                document.getElementById('apiKey').value = '';
                document.getElementById('apiKey').placeholder = 'âš ï¸ Configura API...';
            }
            
            // Mostra risultati salvati se presenti
            if (Object.keys(walletResults).length > 0) {
                aggregateAndDisplay();
                const lastScan = Object.values(walletResults).reduce((latest, w) => 
                    w.scannedAt > latest ? w.scannedAt : latest, 0);
                if (lastScan) {
                    document.getElementById('lastUpdate').textContent = 'Ultimo: ' + new Date(lastScan).toLocaleString('it-IT');
                }
                console.log('ğŸ“Š Loaded', Object.keys(walletResults).length, 'wallet results from Firebase');
            }
            
            // Check Exchange CSV e aggiorna dashboard
            let exchangeTotalEUR = 0;
            let exchangeNames = [];
            for (const exchId of Object.keys(exchangeData)) {
                const data = exchangeData[exchId];
                if (data && data.totals) {
                    const latestYear = [2025, 2024, 2023, 2022, 2021].find(y => data.totals[y] > 0);
                    if (latestYear && data.totals[latestYear] > 0) {
                        exchangeTotalEUR += data.totals[latestYear];
                        const exchInfo = EXCHANGE_LIST.find(e => e.id === exchId);
                        if (exchInfo) exchangeNames.push(exchInfo.name);
                    }
                }
            }
            
            if (exchangeTotalEUR > 0) {
                document.getElementById('exchangeTotalEUR').textContent = 'â‚¬' + exchangeTotalEUR.toLocaleString('it-IT', {maximumFractionDigits: 2});
                document.getElementById('exchangeNames').textContent = exchangeNames.join(', ') + ' âœ“';
                console.log('ğŸ’° Exchanges loaded: â‚¬' + exchangeTotalEUR.toFixed(2));
                
                // Se non ci sono wallet results, mostra comunque il totale Exchange nel portfolio
                if (Object.keys(walletResults).length === 0) {
                    document.getElementById('totalEUR').textContent = 'â‚¬' + exchangeTotalEUR.toLocaleString('it-IT', {maximumFractionDigits: 2});
                    document.getElementById('totalUSD').textContent = '$' + (exchangeTotalEUR / EUR_USD).toLocaleString('it-IT', {maximumFractionDigits: 2}) + ' USD';
                }
            }
        }
        
        // ==================== RICONCILIAZIONE ====================
        let reconcileData = {
            exchangeTx: [],   // Transazioni exchange (deposit/withdraw crypto)
            walletTx: [],     // Transazioni wallet
            matches: [],      // Match trovati
            unmatchedExch: [],
            unmatchedWallet: [],
            currentYearFilter: 'all'
        };
        
        // Import CSV Exchange per Riconciliazione (supporta Tatax e Binance)
        async function importExchangeCSVForReconcile(file) {
            if (!file) return;
            
            // RESET dati exchange prima di importare
            reconcileData.exchangeTx = [];
            reconcileData.matches = [];
            reconcileData.unmatchedExch = [];
            reconcileData.unmatchedWallet = [];
            
            const text = await file.text();
            const lines = text.split('\n').filter(l => l.trim());
            
            if (lines.length < 2) {
                alert('âŒ File CSV vuoto o non valido');
                return;
            }
            
            const header = lines[0].toLowerCase();
            console.log('ğŸ“ Header CSV:', header);
            
            let imported = 0;
            
            // Formato Tatax: Symbol,TokenAddress,TimeStamp,MovementType,Quantity,...
            if (header.includes('movementtype') || header.includes('symbol')) {
                console.log('ğŸ“ Rilevato formato Tatax');
                
                for (let i = 1; i < lines.length; i++) {
                    try {
                        // Parse CSV con virgolette
                        const row = lines[i].match(/(".*?"|[^,]+)(?=\s*,|\s*$)/g);
                        if (!row || row.length < 5) continue;
                        
                        const clean = (s) => s ? s.replace(/"/g, '').trim() : '';
                        
                        const symbol = clean(row[0]);
                        const timestamp = clean(row[2]);
                        const moveType = clean(row[3]).toUpperCase();
                        const quantity = parseFloat(clean(row[4])) || 0;
                        
                        // Solo DEPOSIT e WITHDRAWAL crypto (non fiat, non fee)
                        if (!['DEPOSIT', 'WITHDRAWAL'].includes(moveType)) continue;
                        if (['EUR', 'USD', 'GBP'].includes(symbol)) continue;
                        if (Math.abs(quantity) < 0.0000001) continue;
                        
                        reconcileData.exchangeTx.push({
                            source: 'exchange',
                            exchange: 'binance',
                            date: new Date(timestamp),
                            type: moveType === 'WITHDRAWAL' ? 'withdraw' : 'deposit',
                            coin: symbol.replace('.LENDING@BINANCE', '').replace('.STAKING@BINANCE', ''),
                            amount: Math.abs(quantity)
                        });
                        imported++;
                        
                    } catch (e) {
                        // Skip invalid rows
                    }
                }
            }
            // Formato Binance diretto: User_ID,UTC_Time,Account,Operation,Coin,Change,Remark
            else if (header.includes('operation') || header.includes('utc_time')) {
                console.log('ğŸ“ Rilevato formato Binance');
                
                for (let i = 1; i < lines.length; i++) {
                    try {
                        const row = lines[i].match(/(".*?"|[^,]+)(?=\s*,|\s*$)/g);
                        if (!row || row.length < 6) continue;
                        
                        const clean = (s) => s ? s.replace(/"/g, '').trim() : '';
                        
                        const timestamp = clean(row[1]);
                        const operation = clean(row[3]).toLowerCase();
                        const coin = clean(row[4]);
                        const change = parseFloat(clean(row[5])) || 0;
                        
                        // Solo Deposit e Withdraw
                        if (!operation.includes('deposit') && !operation.includes('withdraw')) continue;
                        if (['EUR', 'USD', 'GBP'].includes(coin)) continue;
                        if (Math.abs(change) < 0.0000001) continue;
                        
                        reconcileData.exchangeTx.push({
                            source: 'exchange',
                            exchange: 'binance',
                            date: new Date(timestamp),
                            type: operation.includes('withdraw') ? 'withdraw' : 'deposit',
                            coin: coin,
                            amount: Math.abs(change)
                        });
                        imported++;
                        
                    } catch (e) {
                        // Skip invalid rows
                    }
                }
            }
            else {
                alert('âŒ Formato CSV non riconosciuto.\nFormati supportati: Tatax, Binance');
                return;
            }
            
            // Ordina per data
            reconcileData.exchangeTx.sort((a, b) => a.date - b.date);
            
            console.log(`âœ… Importate ${imported} transazioni exchange (deposit/withdraw)`);
            
            updateReconcileSummary();
            renderReconcileData();
            saveReconcileToLocalStorage(); // Salva in localStorage
            
            alert(`âœ… Importato!\n\nâ€¢ ${imported} transazioni exchange (deposit/withdraw crypto)\nâ€¢ ${reconcileData.exchangeTx.length} totali\n\nOra clicca "Esegui Riconciliazione" per trovare i match.`);
        }
        
        async function loadReconciliationData() {
            console.log('ğŸ”— Caricamento dati per riconciliazione...');
            
            // RESET tutti i dati di riconciliazione
            reconcileData.exchangeTx = [];
            reconcileData.walletTx = [];
            reconcileData.matches = [];
            reconcileData.unmatchedExch = [];
            reconcileData.unmatchedWallet = [];
            
            // Mostra loading
            document.getElementById('reconcileMatches').innerHTML = '<div style="color:var(--text-secondary);text-align:center;padding:40px;">â³ Caricamento in corso...</div>';
            
            // DEBUG: Mostra stato exchangeData
            const exchKeys = Object.keys(exchangeData);
            let debugInfo = `ğŸ“Š Exchange trovati: ${exchKeys.length}\n`;
            let totalTx = 0;
            
            for (const exchId of exchKeys) {
                const data = exchangeData[exchId];
                const txCount = data.transactions?.length || 0;
                totalTx += txCount;
                debugInfo += `  â€¢ ${exchId}: ${txCount} transazioni\n`;
            }
            
            console.log(debugInfo);
            
            if (totalTx === 0) {
                // Prova a caricare da localStorage
                console.log('âš ï¸ Nessuna transazione in memoria, provo localStorage...');
                loadExchangeTransactionsFromLocalStorage();
                
                // Ricontrolla
                totalTx = 0;
                for (const exchId of Object.keys(exchangeData)) {
                    totalTx += exchangeData[exchId].transactions?.length || 0;
                }
                console.log(`ğŸ“‚ Dopo localStorage: ${totalTx} transazioni`);
            }
            
            // 1. Carica transazioni Exchange (da exchangeData - CSV giÃ  importati)
            console.log('ğŸ“Š Checking exchangeData:', Object.keys(exchangeData));
            
            for (const exchId of Object.keys(exchangeData)) {
                const data = exchangeData[exchId];
                console.log(`  ğŸ“Š ${exchId}: ${data.transactions?.length || 0} transazioni`);
                
                if (data.transactions && data.transactions.length > 0) {
                    for (const tx of data.transactions) {
                        // Identifica tipo transazione
                        const operation = (tx.operation || '').toLowerCase();
                        const txType = (tx.type || '').toLowerCase();
                        const coin = tx.coin || '';
                        const change = tx.change || tx.amount || 0;
                        
                        // Escludi fiat
                        if (['EUR', 'USD', 'GBP'].includes(coin.toUpperCase())) continue;
                        
                        // Identifica deposit/withdraw
                        let finalType = null;
                        
                        // Metodo 1: dal campo type (Tatax)
                        if (txType === 'withdrawal' || txType === 'withdraw') {
                            finalType = 'withdraw';
                        } else if (txType === 'deposit') {
                            finalType = 'deposit';
                        }
                        // Metodo 2: dal campo operation (Binance, altri)
                        else if (operation.includes('withdraw') || operation.includes('prelievo') || operation.includes('send')) {
                            finalType = 'withdraw';
                        } else if (operation.includes('deposit') || operation.includes('versamento') || operation.includes('receive')) {
                            finalType = 'deposit';
                        }
                        // Metodo 3: crypto_withdrawal/crypto_deposit (Crypto.com)
                        else if (operation.includes('crypto_withdrawal')) {
                            finalType = 'withdraw';
                        } else if (operation.includes('crypto_deposit')) {
                            finalType = 'deposit';
                        }
                        
                        // Solo deposit e withdraw
                        if (!finalType) continue;
                        
                        const amount = Math.abs(change);
                        if (amount < 0.0000001) continue;
                        
                        reconcileData.exchangeTx.push({
                            source: 'exchange',
                            exchange: exchId,
                            date: tx.date instanceof Date ? tx.date : new Date(tx.date),
                            type: finalType,
                            coin: coin.toUpperCase(),
                            amount: amount,
                            raw: tx
                        });
                    }
                }
            }
            
            console.log(`ğŸ“Š Exchange TX per riconciliazione: ${reconcileData.exchangeTx.length}`);
            
            // Debug: mostra alcuni esempi
            if (reconcileData.exchangeTx.length > 0) {
                console.log('Sample exchange TX:', reconcileData.exchangeTx.slice(0, 5));
            }
            
            // 2. Carica transazioni Wallet (usa walletTransactions giÃ  scaricate!)
            
            // Prima carica da localStorage se non in memoria
            if (Object.keys(walletTransactions).length === 0) {
                loadWalletTransactions();
            }
            
            const walletAddresses = Object.keys(walletResults);
            if (walletAddresses.length === 0) {
                alert(`ğŸ“Š Dati caricati!\n\nâ€¢ ${reconcileData.exchangeTx.length} transazioni exchange (dai CSV)\n\nâš ï¸ Nessun wallet trovato! Vai su "Wallets" e scansiona almeno un indirizzo.`);
                updateReconcileSummary();
                renderReconcileData();
                return;
            }
            
            console.log(`ğŸ“Š Caricamento storia per ${walletAddresses.length} wallet...`);
            
            // Usa walletTransactions giÃ  scaricate
            let totalWalletTx = 0;
            for (const address of walletAddresses) {
                const addrLower = address.toLowerCase();
                const walletName = walletResults[address]?.name || address.slice(0, 8);
                const txData = walletTransactions[addrLower];
                
                if (!txData) {
                    console.log(`  âš ï¸ ${walletName}: nessuna transazione salvata (scansiona il wallet)`);
                    continue;
                }
                
                // Converti nativeTx in formato riconciliazione
                const chainSymbols = { eth: 'ETH', bsc: 'BNB', polygon: 'MATIC', arbitrum: 'ETH', base: 'ETH', cronos: 'CRO', pulse: 'PLS' };
                const chainNames = { eth: 'Ethereum', bsc: 'BSC', polygon: 'Polygon', arbitrum: 'Arbitrum', base: 'Base', cronos: 'Cronos', pulse: 'PulseChain' };
                
                for (const tx of (txData.nativeTx || [])) {
                    reconcileData.walletTx.push({
                        source: 'wallet',
                        wallet: walletName,
                        address: address,
                        chain: chainNames[tx.c] || tx.c,
                        date: new Date(tx.d),
                        type: tx.t === 'in' ? 'receive' : 'send',
                        coin: tx.s || chainSymbols[tx.c] || 'ETH',
                        amount: tx.a,
                        txHash: tx.h
                    });
                }
                
                // Converti tokenTx in formato riconciliazione
                for (const tx of (txData.tokenTx || [])) {
                    reconcileData.walletTx.push({
                        source: 'wallet',
                        wallet: walletName,
                        address: address,
                        chain: chainNames[tx.c] || tx.c,
                        date: new Date(tx.d),
                        type: tx.t === 'in' ? 'receive' : 'send',
                        coin: tx.s || 'UNKNOWN',
                        amount: tx.a,
                        txHash: tx.h
                    });
                }
                
                const txCount = (txData.nativeTx?.length || 0) + (txData.tokenTx?.length || 0);
                totalWalletTx += txCount;
                console.log(`  âœ… ${walletName}: ${txCount} transazioni caricate da cache`);
            }
            
            // Se non ci sono transazioni salvate, avvisa l'utente
            if (totalWalletTx === 0) {
                alert(`ğŸ“Š Dati caricati!\n\nâ€¢ ${reconcileData.exchangeTx.length} transazioni exchange\nâ€¢ 0 transazioni wallet\n\nâš ï¸ Scansiona i wallet dalla sezione "Wallets" per scaricare le transazioni!`);
            } else {
                alert(`âœ… Caricamento completato!\n\nâ€¢ ${reconcileData.exchangeTx.length} transazioni exchange\nâ€¢ ${totalWalletTx} transazioni wallet\n\nOra clicca "Esegui Riconciliazione" per trovare i match.`);
            }
            
            reconcileData.walletTx.sort((a, b) => b.date - a.date);
            console.log(`ğŸ“Š Wallet TX totali: ${reconcileData.walletTx.length}`);
            
            updateReconcileSummary();
            renderReconcileData();
            
            // Salva in localStorage
            saveReconcileToLocalStorage();
        }
        
        function runReconciliation() {
            console.log('ğŸ”— Esecuzione riconciliazione...');
            console.log('Exchange TX totali:', reconcileData.exchangeTx.length);
            console.log('Wallet TX totali:', reconcileData.walletTx.length);
            
            // Controllo dati mancanti
            if (reconcileData.exchangeTx.length === 0 && reconcileData.walletTx.length === 0) {
                alert('âš ï¸ Nessun dato da riconciliare!\n\n1. Vai su "Exchanges" e importa i CSV\n2. Vai su "Wallets" e scansiona i tuoi indirizzi\n3. Torna qui e clicca "Carica Dati (Exchange + Wallet)"\n4. Poi clicca "Esegui Riconciliazione"');
                return;
            }
            
            if (reconcileData.exchangeTx.length === 0) {
                alert('âš ï¸ Mancano le transazioni Exchange!\n\nVai su "ğŸ“Š Exchanges" e importa i CSV dei tuoi exchange.\n\nLe transazioni deposit/withdraw verranno lette automaticamente.');
                return;
            }
            
            if (reconcileData.walletTx.length === 0) {
                alert('âš ï¸ Mancano le transazioni Wallet!\n\nClicca "ğŸ“Š Carica Dati (Exchange + Wallet)" per scaricare la storia dei tuoi wallet da Moralis.');
                return;
            }
            
            // Debug: mostra sample dei tipi e coin
            const exchTypes = [...new Set(reconcileData.exchangeTx.map(t => t.type))];
            const walletTypes = [...new Set(reconcileData.walletTx.map(t => t.type))];
            const exchCoins = [...new Set(reconcileData.exchangeTx.map(t => t.coin))].slice(0, 20);
            const walletCoins = [...new Set(reconcileData.walletTx.map(t => t.coin))].slice(0, 20);
            console.log('Tipi exchange:', exchTypes);
            console.log('Tipi wallet:', walletTypes);
            console.log('Coin exchange:', exchCoins);
            console.log('Coin wallet:', walletCoins);
            
            // Debug: mostra sample transazioni
            if (reconcileData.exchangeTx.length > 0) {
                console.log('Sample exchange TX:', reconcileData.exchangeTx.slice(0, 3));
            }
            if (reconcileData.walletTx.length > 0) {
                console.log('Sample wallet TX:', reconcileData.walletTx.slice(0, 3));
            }
            
            reconcileData.matches = [];
            reconcileData.unmatchedExch = [...reconcileData.exchangeTx];
            reconcileData.unmatchedWallet = [...reconcileData.walletTx];
            
            // Algoritmo di matching
            const AMOUNT_TOLERANCE = 0.15; // 15% tolerance (per fee)
            const TIME_TOLERANCE = 72 * 60 * 60 * 1000; // 72 ore in ms
            
            // Normalizza tipo
            const isWithdraw = (type) => ['withdraw', 'withdrawal', 'send'].includes((type || '').toLowerCase());
            const isDeposit = (type) => ['deposit', 'receive', 'credit'].includes((type || '').toLowerCase());
            
            let debugMatchAttempts = 0;
            
            // Per ogni withdraw exchange, cerca deposit wallet
            for (let i = reconcileData.unmatchedExch.length - 1; i >= 0; i--) {
                const exchTx = reconcileData.unmatchedExch[i];
                
                if (!isWithdraw(exchTx.type)) continue;
                
                // Cerca un deposit wallet corrispondente
                for (let j = reconcileData.unmatchedWallet.length - 1; j >= 0; j--) {
                    const walletTx = reconcileData.unmatchedWallet[j];
                    
                    if (!isDeposit(walletTx.type)) continue;
                    
                    debugMatchAttempts++;
                    
                    // Stesso coin?
                    const exchCoin = (exchTx.coin || '').toUpperCase();
                    const walletCoin = (walletTx.coin || '').toUpperCase();
                    if (exchCoin !== walletCoin) continue;
                    
                    // Importo simile?
                    if (exchTx.amount <= 0 || walletTx.amount <= 0) continue;
                    const amountDiff = Math.abs(exchTx.amount - walletTx.amount) / Math.max(exchTx.amount, walletTx.amount);
                    if (amountDiff > AMOUNT_TOLERANCE) continue;
                    
                    // Data vicina?
                    const exchDate = exchTx.date instanceof Date ? exchTx.date : new Date(exchTx.date);
                    const walletDate = walletTx.date instanceof Date ? walletTx.date : new Date(walletTx.date);
                    if (isNaN(exchDate.getTime()) || isNaN(walletDate.getTime())) continue;
                    
                    const timeDiff = Math.abs(exchDate.getTime() - walletDate.getTime());
                    if (timeDiff > TIME_TOLERANCE) continue;
                    
                    // MATCH!
                    reconcileData.matches.push({
                        type: 'exchange_to_wallet',
                        exchange: exchTx,
                        wallet: walletTx,
                        confidence: 1 - amountDiff,
                        timeDiff: timeDiff / 1000 / 60 // minuti
                    });
                    
                    // Rimuovi dai non-riconciliati
                    reconcileData.unmatchedExch.splice(i, 1);
                    reconcileData.unmatchedWallet.splice(j, 1);
                    break;
                }
            }
            
            // Per ogni deposit exchange, cerca send wallet
            for (let i = reconcileData.unmatchedExch.length - 1; i >= 0; i--) {
                const exchTx = reconcileData.unmatchedExch[i];
                
                if (!isDeposit(exchTx.type)) continue;
                
                for (let j = reconcileData.unmatchedWallet.length - 1; j >= 0; j--) {
                    const walletTx = reconcileData.unmatchedWallet[j];
                    
                    if (!isWithdraw(walletTx.type)) continue;
                    
                    const exchCoin = (exchTx.coin || '').toUpperCase();
                    const walletCoin = (walletTx.coin || '').toUpperCase();
                    if (exchCoin !== walletCoin) continue;
                    
                    if (exchTx.amount <= 0 || walletTx.amount <= 0) continue;
                    const amountDiff = Math.abs(exchTx.amount - walletTx.amount) / Math.max(exchTx.amount, walletTx.amount);
                    if (amountDiff > AMOUNT_TOLERANCE) continue;
                    
                    const exchDate = exchTx.date instanceof Date ? exchTx.date : new Date(exchTx.date);
                    const walletDate = walletTx.date instanceof Date ? walletTx.date : new Date(walletTx.date);
                    if (isNaN(exchDate.getTime()) || isNaN(walletDate.getTime())) continue;
                    
                    const timeDiff = Math.abs(exchDate.getTime() - walletDate.getTime());
                    if (timeDiff > TIME_TOLERANCE) continue;
                    
                    reconcileData.matches.push({
                        type: 'wallet_to_exchange',
                        exchange: exchTx,
                        wallet: walletTx,
                        confidence: 1 - amountDiff,
                        timeDiff: timeDiff / 1000 / 60
                    });
                    
                    reconcileData.unmatchedExch.splice(i, 1);
                    reconcileData.unmatchedWallet.splice(j, 1);
                    break;
                }
            }
            
            console.log(`âœ… Match trovati: ${reconcileData.matches.length}`);
            console.log(`âš ï¸ Exchange non riconciliati: ${reconcileData.unmatchedExch.length}`);
            console.log(`âš ï¸ Wallet non riconciliati: ${reconcileData.unmatchedWallet.length}`);
            console.log(`ğŸ” Tentativi di match: ${debugMatchAttempts}`);
            
            updateReconcileSummary();
            renderReconcileData();
            
            // Salva i risultati in localStorage
            saveReconcileToLocalStorage();
            
            // Alert con risultati
            alert(`âœ… Riconciliazione completata!\n\nâ€¢ Match trovati: ${reconcileData.matches.length}\nâ€¢ Exchange non riconciliati: ${reconcileData.unmatchedExch.length}\nâ€¢ Wallet non riconciliati: ${reconcileData.unmatchedWallet.length}\n\nControlla i risultati sotto.`);
        }
        
        function updateReconcileSummary() {
            document.getElementById('reconcileExchCount').textContent = reconcileData.exchangeTx.length;
            document.getElementById('reconcileWalletCount').textContent = reconcileData.walletTx.length;
            document.getElementById('reconcileMatchCount').textContent = reconcileData.matches.length;
            document.getElementById('reconcileUnmatchedCount').textContent = 
                reconcileData.unmatchedExch.length + reconcileData.unmatchedWallet.length;
            
            document.getElementById('matchCountBadge').textContent = reconcileData.matches.length;
            document.getElementById('unmatchedCountBadge').textContent = 
                reconcileData.unmatchedExch.length + reconcileData.unmatchedWallet.length;
        }
        
        function filterReconcileYear(year) {
            reconcileData.currentYearFilter = year;
            
            // Aggiorna bottoni
            document.querySelectorAll('.reconcile-year-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.year === year) btn.classList.add('active');
            });
            
            renderReconcileData();
        }
        
        function renderReconcileData() {
            const year = reconcileData.currentYearFilter;
            
            // Filtra per anno
            const filterByYear = (tx) => {
                if (year === 'all') return true;
                const txYear = tx.date ? tx.date.getFullYear().toString() : '';
                return txYear === year;
            };
            
            // Render Matches
            const matchesContainer = document.getElementById('reconcileMatches');
            const filteredMatches = reconcileData.matches.filter(m => 
                filterByYear(m.exchange) || filterByYear(m.wallet)
            );
            
            if (filteredMatches.length === 0) {
                matchesContainer.innerHTML = '<div style="color:var(--text-secondary);text-align:center;padding:40px;">Nessun match trovato</div>';
            } else {
                matchesContainer.innerHTML = filteredMatches.map(m => `
                    <div style="display:flex;align-items:center;padding:12px;border-bottom:1px solid var(--border);gap:12px;">
                        <div style="flex:1;background:#f3ba2f22;padding:8px;border-radius:6px;">
                            <div style="font-size:11px;color:#f3ba2f;">ğŸ¦ ${m.exchange.exchange.toUpperCase()}</div>
                            <div style="font-weight:600;">${m.exchange.type === 'withdraw' ? 'ğŸ“¤' : 'ğŸ“¥'} ${m.exchange.amount.toFixed(6)} ${m.exchange.coin}</div>
                            <div style="font-size:11px;color:var(--text-secondary);">${m.exchange.date.toLocaleString('it-IT')}</div>
                        </div>
                        <div style="font-size:24px;color:var(--green);">â†”ï¸</div>
                        <div style="flex:1;background:var(--accent)22;padding:8px;border-radius:6px;">
                            <div style="font-size:11px;color:var(--accent);">ğŸ‘› Wallet</div>
                            <div style="font-weight:600;">${m.wallet.type === 'receive' ? 'ğŸ“¥' : 'ğŸ“¤'} ${m.wallet.amount.toFixed(6)} ${m.wallet.coin}</div>
                            <div style="font-size:11px;color:var(--text-secondary);">${m.wallet.date.toLocaleString('it-IT')}</div>
                        </div>
                        <div style="text-align:center;padding:0 8px;">
                            <div style="color:var(--green);font-weight:600;">${Math.round(m.confidence * 100)}%</div>
                            <div style="font-size:10px;color:var(--text-secondary);">${Math.round(m.timeDiff)} min</div>
                        </div>
                    </div>
                `).join('');
            }
            
            // Render Unmatched Exchange
            const unmatchedExchContainer = document.getElementById('unmatchedExchange');
            const filteredUnmatchedExch = reconcileData.unmatchedExch.filter(filterByYear);
            
            if (filteredUnmatchedExch.length === 0) {
                unmatchedExchContainer.innerHTML = '<div style="color:var(--text-secondary);text-align:center;padding:20px;">âœ… Tutto riconciliato</div>';
            } else {
                unmatchedExchContainer.innerHTML = filteredUnmatchedExch.map(tx => `
                    <div style="padding:8px;border-bottom:1px solid var(--border);">
                        <div style="display:flex;justify-content:space-between;">
                            <span style="color:#f3ba2f;">${tx.exchange}</span>
                            <span>${tx.type === 'withdraw' ? 'ğŸ“¤' : 'ğŸ“¥'} ${tx.amount.toFixed(4)} ${tx.coin}</span>
                        </div>
                        <div style="color:var(--text-secondary);font-size:11px;">${tx.date.toLocaleString('it-IT')}</div>
                    </div>
                `).join('');
            }
            
            // Render Unmatched Wallet
            const unmatchedWalletContainer = document.getElementById('unmatchedWallet');
            const filteredUnmatchedWallet = reconcileData.unmatchedWallet.filter(filterByYear);
            
            if (filteredUnmatchedWallet.length === 0) {
                unmatchedWalletContainer.innerHTML = '<div style="color:var(--text-secondary);text-align:center;padding:20px;">âœ… Tutto riconciliato</div>';
            } else {
                unmatchedWalletContainer.innerHTML = filteredUnmatchedWallet.map(tx => `
                    <div style="padding:8px;border-bottom:1px solid var(--border);">
                        <div style="display:flex;justify-content:space-between;">
                            <span>${tx.type === 'receive' ? 'ğŸ“¥' : 'ğŸ“¤'} ${tx.amount.toFixed(4)} ${tx.coin}</span>
                        </div>
                        <div style="color:var(--text-secondary);font-size:11px;">${tx.date.toLocaleString('it-IT')}</div>
                    </div>
                `).join('');
            }
        }
        
        function resetReconciliationData() {
            if (!confirm('Sei sicuro di voler cancellare tutti i dati di riconciliazione?')) return;
            
            reconcileData.exchangeTx = [];
            reconcileData.walletTx = [];
            reconcileData.matches = [];
            reconcileData.unmatchedExch = [];
            reconcileData.unmatchedWallet = [];
            
            // Cancella anche da localStorage
            localStorage.removeItem('reconcileData');
            
            updateReconcileSummary();
            renderReconcileData();
            
            alert('âœ… Dati riconciliazione cancellati!');
        }
        
        function saveReconcileToLocalStorage() {
            try {
                // Salva tutti i dati della riconciliazione (inclusi i match!)
                const dataToSave = {
                    exchangeTx: reconcileData.exchangeTx.map(tx => ({
                        ...tx,
                        date: tx.date instanceof Date ? tx.date.toISOString() : tx.date,
                        raw: undefined // Rimuovi oggetti complessi
                    })),
                    walletTx: reconcileData.walletTx.map(tx => ({
                        ...tx,
                        date: tx.date instanceof Date ? tx.date.toISOString() : tx.date
                    })),
                    matches: reconcileData.matches.map(m => ({
                        type: m.type,
                        confidence: m.confidence,
                        timeDiff: m.timeDiff,
                        exchange: m.exchange ? {
                            ...m.exchange,
                            date: m.exchange.date instanceof Date ? m.exchange.date.toISOString() : m.exchange.date,
                            raw: undefined
                        } : null,
                        wallet: m.wallet ? {
                            ...m.wallet,
                            date: m.wallet.date instanceof Date ? m.wallet.date.toISOString() : m.wallet.date
                        } : null
                    })),
                    unmatchedExch: reconcileData.unmatchedExch.map(tx => ({
                        ...tx,
                        date: tx.date instanceof Date ? tx.date.toISOString() : tx.date,
                        raw: undefined
                    })),
                    unmatchedWallet: reconcileData.unmatchedWallet.map(tx => ({
                        ...tx,
                        date: tx.date instanceof Date ? tx.date.toISOString() : tx.date
                    })),
                    savedAt: new Date().toISOString()
                };
                localStorage.setItem('reconcileData', JSON.stringify(dataToSave));
                console.log(`ğŸ’¾ Riconciliazione salvata: ${reconcileData.matches.length} match`);
            } catch (e) {
                console.warn('Errore salvataggio localStorage:', e);
            }
        }
        
        function loadReconcileFromLocalStorage() {
            try {
                const saved = localStorage.getItem('reconcileData');
                if (!saved) return false;
                
                const data = JSON.parse(saved);
                
                reconcileData.exchangeTx = (data.exchangeTx || []).map(tx => ({
                    ...tx,
                    date: new Date(tx.date)
                }));
                reconcileData.walletTx = (data.walletTx || []).map(tx => ({
                    ...tx,
                    date: new Date(tx.date)
                }));
                reconcileData.matches = (data.matches || []).map(m => ({
                    ...m,
                    exchange: m.exchange ? { ...m.exchange, date: new Date(m.exchange.date) } : null,
                    wallet: m.wallet ? { ...m.wallet, date: new Date(m.wallet.date) } : null
                }));
                reconcileData.unmatchedExch = (data.unmatchedExch || []).map(tx => ({
                    ...tx,
                    date: new Date(tx.date)
                }));
                reconcileData.unmatchedWallet = (data.unmatchedWallet || []).map(tx => ({
                    ...tx,
                    date: new Date(tx.date)
                }));
                
                console.log(`ğŸ“‚ Caricati da localStorage: ${reconcileData.exchangeTx.length} exchange, ${reconcileData.walletTx.length} wallet, ${reconcileData.matches.length} match`);
                return true;
            } catch (e) {
                console.warn('Errore caricamento localStorage:', e);
                return false;
            }
        }
        
        // ==================== NFT FUNCTIONS ====================
        async function scanAllNFTs() {
            const walletAddresses = Object.keys(walletResults);
            if (walletAddresses.length === 0) {
                alert('âš ï¸ Nessun wallet trovato!\nVai su "Wallets" e scansiona almeno un indirizzo.');
                return;
            }
            
            const moralisKey = getMoralisKey();
            if (!moralisKey) {
                alert('âš ï¸ Configura la Moralis API key in "API Connect" per scansionare gli NFT!');
                return;
            }
            
            document.getElementById('nftGrid').innerHTML = '<div style="color:var(--text-secondary);text-align:center;padding:40px;grid-column:1/-1;">â³ Scansione NFT in corso...</div>';
            
            nftData = [];
            
            // Chain da scansionare (EVM)
            const evmChains = [
                { key: 'eth', id: '0x1', name: 'Ethereum' },
                { key: 'polygon', id: '0x89', name: 'Polygon' },
                { key: 'bsc', id: '0x38', name: 'BSC' },
                { key: 'arbitrum', id: '0xa4b1', name: 'Arbitrum' },
                { key: 'base', id: '0x2105', name: 'Base' }
            ];
            
            for (const address of walletAddresses) {
                const walletName = walletResults[address]?.name || address.slice(0, 8);
                console.log(`ğŸ–¼ï¸ Scansione NFT per ${walletName}...`);
                
                // Determina se Ã¨ EVM o Solana
                if (address.startsWith('0x')) {
                    // EVM - scansiona tutte le chain
                    for (const chain of evmChains) {
                        try {
                            const nfts = await fetchNFTsFromMoralis(address, chain.id, chain.name, walletName);
                            if (nfts && nfts.length > 0) {
                                nftData.push(...nfts);
                                console.log(`  âœ… ${chain.name}: ${nfts.length} NFT`);
                            }
                        } catch (e) {
                            console.warn(`  âš ï¸ Errore ${chain.name}:`, e);
                        }
                    }
                } else if (address.length > 30) {
                    // Solana
                    try {
                        const nfts = await fetchNFTsFromHelius(address, walletName);
                        if (nfts && nfts.length > 0) {
                            nftData.push(...nfts);
                            console.log(`  âœ… Solana: ${nfts.length} NFT`);
                        }
                    } catch (e) {
                        console.warn('  âš ï¸ Errore Solana:', e);
                    }
                }
            }
            
            // Carica prezzi di acquisto da localStorage
            loadNFTPurchasePrices();
            
            // Aggiorna UI
            updateNFTSummary();
            renderNFTGrid();
            saveNFTDataToLocalStorage();
            
            alert(`âœ… Scansione completata!\n\nTrovati ${nftData.length} NFT`);
        }
        
        async function fetchNFTsFromMoralis(address, chainId, chainName, walletName, retryCount = 0) {
            const moralisKey = getMoralisKey();
            if (!moralisKey) return [];
            
            try {
                const url = `https://deep-index.moralis.io/api/v2.2/${address}/nft?chain=${chainId}&format=decimal&media_items=true`;
                const response = await fetch(url, {
                    headers: { 'X-API-Key': moralisKey }
                });
                
                // Rate limit handling
                if (response.status === 429 || response.status === 400) {
                    if (rotateMoralisKey('rate limit') && retryCount < moralisKeys.length) {
                        return fetchNFTsFromMoralis(address, chainId, chainName, walletName, retryCount + 1);
                    }
                    return [];
                }
                
                if (!response.ok) return [];
                
                const data = await response.json();
                const nfts = [];
                
                for (const nft of (data.result || [])) {
                    // Parse metadata
                    let metadata = {};
                    try {
                        if (nft.metadata) {
                            metadata = typeof nft.metadata === 'string' ? JSON.parse(nft.metadata) : nft.metadata;
                        }
                    } catch (e) {}
                    
                    // Get image
                    let image = metadata.image || nft.token_uri || '';
                    if (image.startsWith('ipfs://')) {
                        image = image.replace('ipfs://', 'https://ipfs.io/ipfs/');
                    }
                    
                    nfts.push({
                        tokenId: nft.token_id,
                        name: metadata.name || nft.name || `#${nft.token_id}`,
                        collection: nft.name || 'Unknown Collection',
                        image: image,
                        chain: chainName,
                        chainKey: chainId,
                        contract: nft.token_address,
                        wallet: walletName,
                        floorPrice: 0, // TODO: fetch floor price
                        floorPriceUSD: 0
                    });
                }
                
                return nfts;
            } catch (e) {
                console.error('Moralis NFT error:', e);
                return [];
            }
        }
        
        async function fetchNFTsFromHelius(address, walletName) {
            if (!apiKeys.helius) return [];
            
            try {
                const url = `https://api.helius.xyz/v0/addresses/${address}/nfts?api-key=${apiKeys.helius}`;
                const response = await fetch(url);
                
                if (!response.ok) return [];
                
                const data = await response.json();
                const nfts = [];
                
                for (const nft of (data.nfts || data || [])) {
                    nfts.push({
                        tokenId: nft.mint || nft.id,
                        name: nft.name || 'Solana NFT',
                        collection: nft.collectionName || nft.collection?.name || 'Unknown',
                        image: nft.image || nft.content?.links?.image || '',
                        chain: 'Solana',
                        chainKey: 'solana',
                        contract: nft.mint || nft.id,
                        wallet: walletName,
                        floorPrice: 0,
                        floorPriceUSD: 0
                    });
                }
                
                return nfts;
            } catch (e) {
                console.error('Helius NFT error:', e);
                return [];
            }
        }
        
        function renderNFTGrid(filterChain = 'all') {
            const grid = document.getElementById('nftGrid');
            
            let filteredNFTs = nftData;
            if (filterChain !== 'all') {
                filteredNFTs = nftData.filter(nft => nft.chainKey === filterChain || nft.chain.toLowerCase() === filterChain);
            }
            
            if (filteredNFTs.length === 0) {
                grid.innerHTML = '<div style="color:var(--text-secondary);text-align:center;padding:40px;grid-column:1/-1;">Nessun NFT trovato.</div>';
                return;
            }
            
            let html = '';
            for (const nft of filteredNFTs) {
                const nftKey = `${nft.contract}_${nft.tokenId}`;
                const purchasePrice = nftPurchasePrices[nftKey] || 0;
                const currentValue = nft.floorPriceUSD || 0;
                const pl = currentValue - purchasePrice;
                const plColor = pl >= 0 ? 'var(--green)' : 'var(--red)';
                
                html += `
                <div class="card" style="padding:0;overflow:hidden;">
                    <div style="height:200px;background:var(--bg-primary);display:flex;align-items:center;justify-content:center;overflow:hidden;">
                        ${nft.image ? 
                            `<img src="${nft.image}" alt="${nft.name}" style="max-width:100%;max-height:100%;object-fit:contain;" onerror="this.parentElement.innerHTML='ğŸ–¼ï¸'">` : 
                            '<span style="font-size:48px;">ğŸ–¼ï¸</span>'
                        }
                    </div>
                    <div style="padding:12px;">
                        <div style="font-weight:600;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${nft.name}</div>
                        <div style="font-size:12px;color:var(--text-secondary);margin-bottom:8px;">${nft.collection}</div>
                        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
                            <span style="font-size:11px;padding:4px 8px;background:var(--bg-primary);border-radius:4px;">${nft.chain}</span>
                            <span style="font-size:11px;color:var(--text-secondary);">${nft.wallet}</span>
                        </div>
                        <div style="border-top:1px solid var(--bg-primary);padding-top:8px;margin-top:8px;">
                            <div style="display:flex;justify-content:space-between;font-size:12px;margin-bottom:4px;">
                                <span>Costo:</span>
                                <input type="number" value="${purchasePrice}" 
                                    style="width:80px;background:var(--bg-primary);border:none;color:var(--text-primary);text-align:right;padding:2px 6px;border-radius:4px;"
                                    onchange="setNFTPurchasePrice('${nftKey}', this.value)"
                                    placeholder="â‚¬0">
                            </div>
                            ${purchasePrice > 0 ? `
                            <div style="display:flex;justify-content:space-between;font-size:12px;">
                                <span>P/L:</span>
                                <span style="color:${plColor};font-weight:600;">â‚¬${pl.toFixed(2)}</span>
                            </div>` : ''}
                        </div>
                    </div>
                </div>`;
            }
            
            grid.innerHTML = html;
        }
        
        function filterNFTsByChain() {
            const filter = document.getElementById('nftChainFilter').value;
            renderNFTGrid(filter);
        }
        
        function setNFTPurchasePrice(nftKey, price) {
            nftPurchasePrices[nftKey] = parseFloat(price) || 0;
            localStorage.setItem('cryptofolio_nft_prices', JSON.stringify(nftPurchasePrices));
            updateNFTSummary();
            console.log(`ğŸ’¾ NFT ${nftKey}: costo â‚¬${price}`);
        }
        
        function loadNFTPurchasePrices() {
            try {
                const saved = localStorage.getItem('cryptofolio_nft_prices');
                if (saved) {
                    nftPurchasePrices = JSON.parse(saved);
                }
            } catch (e) {}
        }
        
        function updateNFTSummary() {
            const totalCount = nftData.length;
            let totalValue = 0;
            let totalCost = 0;
            
            for (const nft of nftData) {
                const nftKey = `${nft.contract}_${nft.tokenId}`;
                totalValue += nft.floorPriceUSD || 0;
                totalCost += nftPurchasePrices[nftKey] || 0;
            }
            
            const pl = totalValue - totalCost;
            const plColor = pl >= 0 ? 'var(--green)' : 'var(--red)';
            
            document.getElementById('nftTotalCount').textContent = totalCount;
            document.getElementById('nftTotalValue').textContent = 'â‚¬' + totalValue.toFixed(0);
            document.getElementById('nftTotalCost').textContent = 'â‚¬' + totalCost.toFixed(0);
            document.getElementById('nftTotalPL').textContent = 'â‚¬' + pl.toFixed(0);
            document.getElementById('nftTotalPL').style.color = plColor;
            document.getElementById('nftCount').textContent = totalCount;
        }
        
        function saveNFTDataToLocalStorage() {
            try {
                localStorage.setItem('cryptofolio_nfts', JSON.stringify(nftData));
            } catch (e) {}
        }
        
        function loadNFTDataFromLocalStorage() {
            try {
                const saved = localStorage.getItem('cryptofolio_nfts');
                if (saved) {
                    nftData = JSON.parse(saved);
                    loadNFTPurchasePrices();
                    updateNFTSummary();
                }
            } catch (e) {}
        }
        
        function exportReconciliationReport() {
            let report = '=== REPORT RICONCILIAZIONE ===\n';
            report += `Data: ${new Date().toLocaleString('it-IT')}\n\n`;
            
            report += `ğŸ“Š RIEPILOGO\n`;
            report += `Transazioni Exchange: ${reconcileData.exchangeTx.length}\n`;
            report += `Transazioni Wallet: ${reconcileData.walletTx.length}\n`;
            report += `Match trovati: ${reconcileData.matches.length}\n`;
            report += `Non riconciliati: ${reconcileData.unmatchedExch.length + reconcileData.unmatchedWallet.length}\n\n`;
            
            report += `âœ… MATCH TROVATI\n`;
            for (const m of reconcileData.matches) {
                report += `${m.exchange.date.toISOString().split('T')[0]} | ${m.exchange.exchange} ${m.exchange.type} ${m.exchange.amount} ${m.exchange.coin} â†” Wallet ${m.wallet.type} | ${Math.round(m.confidence*100)}%\n`;
            }
            
            report += `\nâš ï¸ EXCHANGE NON RICONCILIATI\n`;
            for (const tx of reconcileData.unmatchedExch) {
                report += `${tx.date.toISOString().split('T')[0]} | ${tx.exchange} | ${tx.type} ${tx.amount} ${tx.coin}\n`;
            }
            
            report += `\nâš ï¸ WALLET NON RICONCILIATI\n`;
            for (const tx of reconcileData.unmatchedWallet) {
                report += `${tx.date.toISOString().split('T')[0]} | ${tx.type} ${tx.amount} ${tx.coin}\n`;
            }
            
            // Download
            const blob = new Blob([report], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `riconciliazione_${new Date().toISOString().split('T')[0]}.txt`;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        init();
    </script>
    
    <!-- Modal Binance API -->
    <div id="binanceApiModal" class="modal-overlay" onclick="if(event.target===this)closeBinanceApiModal()">
        <div class="modal-content">
            <div class="modal-header">
                <h3><img src="https://assets.coingecko.com/markets/images/52/small/binance.jpg" style="width:28px;height:28px;border-radius:6px;"> Binance Tax API</h3>
                <button class="modal-close" onclick="closeBinanceApiModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="server-status-box">
                    <span class="server-status-label">ğŸ–¥ï¸ Server Locale</span>
                    <span id="modalServerStatus" class="server-status-badge server-off">OFFLINE</span>
                </div>
                
                <div class="form-group">
                    <label class="form-label">API Key</label>
                    <input type="text" id="modalApiKey" class="form-input" placeholder="Incolla la tua API Key...">
                </div>
                
                <div class="form-group">
                    <label class="form-label">Secret Key</label>
                    <input type="password" id="modalSecretKey" class="form-input" placeholder="Incolla la tua Secret Key...">
                </div>
                
                <a href="https://www.binance.com/it/my/settings/api-management" target="_blank" class="api-help-link">
                    ğŸ“‹ Come creare API Report Fiscale su Binance â†’
                </a>
                
                <div id="modalProgress" class="progress-container">
                    <div class="progress-bar-bg">
                        <div id="modalProgressBar" class="progress-bar-fill"></div>
                    </div>
                    <div id="modalProgressText" class="progress-text">Preparazione...</div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="checkModalServerStatus()">ğŸ”„ Check Server</button>
                <button class="btn btn-primary" onclick="downloadFromModal()" style="background:#f3ba2f;color:#000;">ğŸ“¥ Scarica Storico</button>
            </div>
        </div>
    </div>
    
    <!-- BITGET API MODAL -->
    <div id="bitgetApiModal" class="modal-overlay" onclick="if(event.target===this)closeBitgetApiModal()">
        <div class="modal-content">
            <div class="modal-header">
                <h3><img src="https://assets.coingecko.com/markets/images/540/small/bitget.jpg" style="width:28px;height:28px;border-radius:6px;"> Bitget API</h3>
                <button class="modal-close" onclick="closeBitgetApiModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="server-status-box">
                    <span class="server-status-label">ğŸ–¥ï¸ Server Locale</span>
                    <span id="bitgetModalServerStatus" class="server-status-badge server-off">OFFLINE</span>
                </div>
                
                <div class="form-group">
                    <label class="form-label">API Key</label>
                    <input type="text" id="bitgetModalApiKey" class="form-input" placeholder="Incolla la tua API Key...">
                </div>
                
                <div class="form-group">
                    <label class="form-label">Secret Key</label>
                    <input type="password" id="bitgetModalSecretKey" class="form-input" placeholder="Incolla la tua Secret Key...">
                </div>
                
                <div class="form-group">
                    <label class="form-label">Passphrase</label>
                    <input type="password" id="bitgetModalPassphrase" class="form-input" placeholder="Incolla la tua Passphrase...">
                </div>
                
                <a href="https://www.bitget.com/account/newapi" target="_blank" class="api-help-link">
                    ğŸ“‹ Come creare API su Bitget â†’
                </a>
                
                <div id="bitgetModalProgress" class="progress-container">
                    <div class="progress-bar-bg">
                        <div id="bitgetModalProgressBar" class="progress-bar-fill"></div>
                    </div>
                    <div id="bitgetModalProgressText" class="progress-text">Preparazione...</div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="checkBitgetServerStatus()">ğŸ”„ Check Server</button>
                <button class="btn btn-primary" onclick="downloadFromBitgetModal()" style="background:#00f0ff;color:#000;">ğŸ“¥ Scarica Storico</button>
            </div>
        </div>
    </div>
    
    <!-- BITPANDA API MODAL -->
    <div id="bitpandaApiModal" class="modal-overlay" onclick="if(event.target===this)closeBitpandaApiModal()">
        <div class="modal-content">
            <div class="modal-header">
                <h3><img src="https://assets.coingecko.com/markets/images/237/small/bitpanda.jpg" style="width:28px;height:28px;border-radius:6px;"> Bitpanda API</h3>
                <button class="modal-close" onclick="closeBitpandaApiModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div style="background:var(--bg-primary);padding:12px;border-radius:8px;margin-bottom:16px;font-size:13px;">
                    <strong>â„¹ï¸ Nota:</strong> Bitpanda API Ã¨ semplice - serve solo l'API Key!<br>
                    <span style="color:var(--text-secondary);">Scope richiesti: <strong>Transaction</strong> + <strong>Trading</strong></span>
                </div>
                
                <div class="form-group">
                    <label class="form-label">API Key</label>
                    <input type="password" id="bitpandaModalApiKey" class="form-input" placeholder="Incolla la tua Bitpanda API Key...">
                </div>
                
                <a href="https://web.bitpanda.com/apikey" target="_blank" class="api-help-link">
                    ğŸ“‹ Come creare API su Bitpanda â†’
                </a>
                
                <div style="background:var(--yellow);color:#000;padding:10px;border-radius:8px;margin:16px 0;font-size:12px;">
                    âš ï¸ <strong>CORS:</strong> Se vedi errore "CORS bloccato", Bitpanda non permette chiamate dirette dal browser. Usa l'import CSV in alternativa.
                </div>
                
                <div id="bitpandaModalProgress" class="progress-container">
                    <div class="progress-bar-bg">
                        <div id="bitpandaModalProgressBar" class="progress-bar-fill"></div>
                    </div>
                    <div id="bitpandaModalProgressText" class="progress-text">Preparazione...</div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeBitpandaApiModal()">Annulla</button>
                <button class="btn btn-primary" onclick="downloadFromBitpandaModal()" style="background:#08b289;color:#fff;">ğŸ“¥ Scarica Storico</button>
            </div>
        </div>
    </div>
</body>
</html>
