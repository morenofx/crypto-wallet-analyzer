<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CryptoFolio v5.0 - Smart Reconciliation</title>
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <script>
        const firebaseConfig = {
            apiKey: "AIzaSyDAmtceQc0m-KQC7xGmu0IH1cR4tnI8oCQ",
            authDomain: "moreno-crypto-tools.firebaseapp.com",
            projectId: "moreno-crypto-tools",
            storageBucket: "moreno-crypto-tools.firebasestorage.app",
            messagingSenderId: "875997322481",
            appId: "1:875997322481:web:1a012bec2aff2cb5205d50"
        };
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();
    </script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --bg-primary: #0f0f1a;
            --bg-secondary: #1a1a2e;
            --bg-card: #16213e;
            --text-primary: #ffffff;
            --text-secondary: #a0a0a0;
            --accent: #6c5ce7;
            --accent-light: #a29bfe;
            --green: #00cec9;
            --red: #ff6b6b;
            --border: #2d2d44;
        }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: var(--bg-primary); color: var(--text-primary); min-height: 100vh; }
        .app-container { display: flex; min-height: 100vh; }
        .sidebar { width: 240px; background: var(--bg-secondary); padding: 20px; display: flex; flex-direction: column; border-right: 1px solid var(--border); }
        .logo { display: flex; align-items: center; gap: 12px; margin-bottom: 40px; }
        .logo-icon { width: 40px; height: 40px; background: linear-gradient(135deg, var(--accent), var(--accent-light)); border-radius: 10px; display: flex; align-items: center; justify-content: center; font-size: 20px; }
        .logo-text { font-size: 20px; font-weight: 700; }
        .nav-section { margin-bottom: 30px; }
        .nav-label { font-size: 11px; color: var(--text-secondary); margin-bottom: 12px; text-transform: uppercase; letter-spacing: 1px; }
        .nav-item { display: flex; align-items: center; gap: 12px; padding: 12px 16px; border-radius: 8px; cursor: pointer; transition: all 0.2s; margin-bottom: 4px; }
        .nav-item:hover { background: var(--bg-card); }
        .nav-item.active { background: var(--accent); }
        .nav-item .icon { font-size: 18px; }
        .nav-item .badge { margin-left: auto; background: var(--accent); padding: 2px 8px; border-radius: 10px; font-size: 11px; }
        .nav-item.active .badge { background: rgba(255,255,255,0.2); }
        .sidebar-footer { margin-top: auto; padding-top: 20px; border-top: 1px solid var(--border); }
        .version { font-size: 12px; color: var(--text-secondary); }
        .main-content { flex: 1; padding: 30px; overflow-y: auto; }
        .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 30px; }
        .header h1 { font-size: 28px; font-weight: 600; }
        .header-actions { display: flex; gap: 12px; align-items: center; }
        .btn { padding: 10px 20px; border-radius: 8px; border: none; cursor: pointer; font-size: 14px; font-weight: 500; transition: all 0.2s; }
        .btn-primary { background: var(--accent); color: white; }
        .btn-primary:hover { background: var(--accent-light); }
        .btn-secondary { background: var(--bg-card); color: var(--text-primary); border: 1px solid var(--border); }
        .stats-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px; margin-bottom: 30px; }
        .stat-card { background: var(--bg-card); padding: 24px; border-radius: 16px; border: 1px solid var(--border); }
        .stat-label { font-size: 13px; color: var(--text-secondary); margin-bottom: 8px; }
        .stat-value { font-size: 28px; font-weight: 700; color: var(--green); }
        .stat-change { font-size: 13px; margin-top: 4px; }
        .content-grid { display: grid; grid-template-columns: 2fr 1fr; gap: 20px; }
        .card { background: var(--bg-card); border-radius: 16px; padding: 24px; border: 1px solid var(--border); }
        .card-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
        .card-title { font-size: 18px; font-weight: 600; }
        .holdings-table { width: 100%; border-collapse: collapse; table-layout: fixed; }
        .holdings-table th { text-align: left; padding: 12px 8px; color: var(--text-secondary); font-size: 12px; text-transform: uppercase; border-bottom: 1px solid var(--border); font-weight: 500; letter-spacing: 0.5px; }
        .holdings-table th:nth-child(1) { width: 40%; text-align: left; }
        .holdings-table th:nth-child(2) { width: 20%; text-align: right; }
        .holdings-table th:nth-child(3) { width: 18%; text-align: right; }
        .holdings-table th:nth-child(4) { width: 22%; text-align: right; }
        .holdings-table td { padding: 16px 8px; border-bottom: 1px solid var(--border); vertical-align: middle; }
        .holdings-table td:nth-child(2), .holdings-table td:nth-child(3), .holdings-table td:nth-child(4) { text-align: right; }
        .holdings-table tr:hover { background: rgba(255,255,255,0.02); }
        
        /* Tabella transazioni exchange */
        .tx-table { width: 100%; border-collapse: collapse; table-layout: auto; }
        .tx-table th { padding: 10px 12px; color: var(--text-secondary); font-size: 11px; text-transform: uppercase; border-bottom: 1px solid var(--border); font-weight: 600; letter-spacing: 0.5px; }
        .tx-table td { padding: 12px; border-bottom: 1px solid rgba(255,255,255,0.05); vertical-align: middle; }
        .tx-table tr:hover { background: rgba(255,255,255,0.02); }
        .tx-badge { display: inline-flex; align-items: center; gap: 5px; padding: 5px 10px; border-radius: 6px; font-size: 12px; font-weight: 600; white-space: nowrap; }
        
        .token-cell { display: flex; align-items: center; gap: 12px; }
        .token-icon { width: 40px; height: 40px; border-radius: 50%; background: var(--bg-secondary); display: flex; align-items: center; justify-content: center; font-weight: 600; font-size: 12px; overflow: hidden; flex-shrink: 0; }
        .token-icon img { width: 100%; height: 100%; object-fit: cover; }
        .token-info .symbol { font-weight: 600; font-size: 14px; }
        .token-info .name { font-size: 12px; color: var(--text-secondary); margin-top: 2px; }
        .text-right { text-align: right; }
        .text-mono { font-family: 'SF Mono', Monaco, monospace; font-size: 13px; }
        .text-secondary { color: var(--text-secondary); }
        .wallet-input-section { background: var(--bg-card); padding: 20px; border-radius: 16px; margin-bottom: 20px; border: 1px solid var(--border); }
        .input-row { display: flex; gap: 16px; margin-bottom: 16px; }
        .input-group { flex: 1; }
        .input-group label { display: block; font-size: 12px; color: var(--text-secondary); margin-bottom: 8px; }
        .input-group input { width: 100%; padding: 12px; background: var(--bg-primary); border: 1px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 14px; }
        .input-group input:focus { outline: none; border-color: var(--accent); }
        .chain-selector { display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 16px; }
        .chain-btn { padding: 8px 14px; border-radius: 8px; border: 1px solid var(--border); background: var(--bg-primary); color: var(--text-secondary); cursor: pointer; font-size: 13px; transition: all 0.2s; display: flex; align-items: center; gap: 6px; }
        .chain-btn:hover { border-color: var(--accent); }
        .chain-btn.active { background: var(--accent); color: white; border-color: var(--accent); }
        .chain-dot { width: 8px; height: 8px; border-radius: 50%; }
        .status-log { background: var(--bg-primary); border-radius: 8px; padding: 12px; max-height: 150px; overflow-y: auto; font-family: 'SF Mono', Monaco, monospace; font-size: 12px; }
        .log-line { padding: 4px 0; }
        .log-line.success { color: var(--green); }
        .log-line.error { color: var(--red); }
        .log-line.info { color: var(--text-secondary); }
        .empty-state { text-align: center; padding: 40px; color: var(--text-secondary); }
        .empty-state .icon { font-size: 48px; margin-bottom: 16px; }
        .verify-link { display: inline-flex; align-items: center; gap: 6px; color: var(--accent-light); font-size: 13px; text-decoration: none; }
        .chain-badge { display: inline-block; font-size: 9px; padding: 2px 6px; border-radius: 4px; margin-left: 6px; font-weight: 600; text-transform: uppercase; }
        .blacklist-item { display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg-primary); border-radius: 8px; margin-bottom: 8px; }
        .btn-restore { background: var(--green); color: white; border: none; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 12px; }
        .hide-btn { background: transparent; border: none; color: var(--text-secondary); cursor: pointer; font-size: 10px; padding: 2px 6px; border-radius: 4px; margin-right: 8px; opacity: 0.5; }
        .hide-btn:hover { background: var(--red); color: white; opacity: 1; }
        .api-status { padding: 6px 12px; border-radius: 6px; font-size: 11px; font-weight: 600; }
        .api-status[id$="Status"] { background: var(--red); color: white; }
        .api-on { background: var(--green) !important; color: #000 !important; }
        
        /* Modal Styles */
        .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center; z-index: 1000; opacity: 0; visibility: hidden; transition: all 0.3s ease; }
        .modal-overlay.active { opacity: 1; visibility: visible; }
        .modal-content { background: var(--bg-card); border-radius: 16px; padding: 0; width: 90%; max-width: 480px; border: 1px solid var(--border); transform: scale(0.9); transition: transform 0.3s ease; box-shadow: 0 20px 60px rgba(0,0,0,0.5); }
        .modal-overlay.active .modal-content { transform: scale(1); }
        .modal-header { display: flex; align-items: center; justify-content: space-between; padding: 20px 24px; border-bottom: 1px solid var(--border); background: linear-gradient(135deg, rgba(243,186,47,0.15), rgba(243,186,47,0.05)); border-radius: 16px 16px 0 0; }
        .modal-header h3 { font-size: 18px; font-weight: 600; display: flex; align-items: center; gap: 10px; }
        .modal-close { background: none; border: none; color: var(--text-secondary); font-size: 24px; cursor: pointer; padding: 4px; line-height: 1; transition: color 0.2s; }
        .modal-close:hover { color: var(--red); }
        .modal-body { padding: 24px; }
        .modal-footer { padding: 16px 24px; border-top: 1px solid var(--border); display: flex; justify-content: flex-end; gap: 12px; }
        .form-group { margin-bottom: 16px; }
        .form-label { display: block; font-size: 12px; color: var(--text-secondary); margin-bottom: 6px; font-weight: 500; }
        .form-input { width: 100%; padding: 12px 14px; background: var(--bg-primary); border: 1px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 14px; transition: border-color 0.2s; }
        .form-input:focus { outline: none; border-color: var(--accent); }
        .form-input::placeholder { color: var(--text-secondary); }
        .server-status-box { display: flex; align-items: center; justify-content: space-between; padding: 12px 16px; background: var(--bg-primary); border-radius: 8px; margin-bottom: 20px; }
        .server-status-label { font-size: 13px; color: var(--text-secondary); }
        .server-status-badge { font-size: 11px; font-weight: 600; padding: 4px 10px; border-radius: 20px; }
        .server-off { background: var(--red); color: #fff; }
        .server-on { background: var(--green); color: #000; }
        .api-help-link { display: block; text-align: center; font-size: 12px; color: var(--accent-light); margin-top: 16px; }
        .api-help-link:hover { text-decoration: underline; }
        .progress-container { margin-top: 20px; display: none; }
        .progress-bar-bg { background: var(--bg-primary); border-radius: 6px; height: 8px; overflow: hidden; }
        .progress-bar-fill { background: linear-gradient(90deg, #f3ba2f, #f0b90b); height: 100%; width: 0%; transition: width 0.3s ease; }
        .progress-text { font-size: 12px; color: var(--text-secondary); margin-top: 8px; text-align: center; }
        @keyframes spin { to { transform: rotate(360deg); } }
        @keyframes pulse { 
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="sidebar">
            <div class="logo"><div class="logo-icon">üìä</div><span class="logo-text">CryptoFolio</span></div>
            <div class="nav-section">
                <div class="nav-label">Menu</div>
                <div class="nav-item active" onclick="showView('dashboard')"><span class="icon">üìà</span><span>Dashboard</span></div>
                <div class="nav-item" onclick="showView('wallets')"><span class="icon">üëõ</span><span>Wallets</span><span class="badge" id="walletCount">0</span></div>
                <div class="nav-item" onclick="showView('nft')"><span class="icon">üñºÔ∏è</span><span>NFT</span><span class="badge" id="nftCount">0</span></div>
                <div class="nav-item" onclick="showView('exchanges')"><span class="icon">üè¶</span><span>Exchanges</span><span class="badge" id="exchangeCount">0</span></div>
                <div class="nav-item" onclick="showView('reconcile')"><span class="icon">üîó</span><span>Riconciliazione</span></div>
                <div class="nav-item" onclick="showView('tax')"><span class="icon">üìã</span><span>Tax Report</span></div>
                <div class="nav-item" onclick="showView('api')"><span class="icon">üîå</span><span>API Connect</span><span class="badge" id="apiCount">0</span></div>
            </div>
            <div class="nav-section">
                <div class="nav-label">Settings</div>
                <div class="nav-item" onclick="toggleBlacklist()"><span class="icon">üö´</span><span>Token Nascosti</span><span class="badge" id="blacklistCount">0</span></div>
                <div class="nav-item" onclick="forceSyncFirebase()"><span class="icon">‚òÅÔ∏è</span><span>Force Sync</span></div>
                <div class="nav-item" onclick="clearWalletResults()"><span class="icon">üóëÔ∏è</span><span>Reset Scan</span></div>
            </div>
            <div class="sidebar-footer">
                <div style="display:flex;align-items:center;gap:8px;margin-bottom:8px;">
                    <span class="sync-dot" id="syncDot" style="width:8px;height:8px;border-radius:50%;background:var(--green);"></span>
                    <span id="syncStatus" style="font-size:11px;color:var(--text-secondary);">Connesso</span>
                </div>
                <div class="version">v5.0 - Smart Reconciliation</div>
            </div>
        </div>
        
        <!-- DASHBOARD -->
        <div class="main-content" id="dashboardView">
            <div class="header"><h1>Dashboard</h1><div class="header-actions"><span id="lastUpdate" style="font-size:13px;color:var(--text-secondary);"></span><button class="btn btn-secondary" onclick="scanAllWallets()" style="margin-right:8px;">üìä Scan All</button><button class="btn btn-primary" onclick="scanWallet()">üîç Scan</button></div></div>
            
            <div class="wallet-input-section">
                <div class="input-row">
                    <div class="input-group" style="flex:2;">
                        <label>Wallet</label>
                        <div style="display:flex;gap:8px;">
                            <select id="walletSelect" onchange="onWalletSelect()" style="flex:1;padding:12px;background:var(--bg-primary);border:1px solid var(--border);border-radius:8px;color:var(--text-primary);font-size:14px;">
                                <option value="">-- Seleziona o inserisci --</option>
                            </select>
                            <input type="text" id="walletAddress" placeholder="0x... o seleziona sopra" autocomplete="off" style="flex:2;">
                        </div>
                    </div>
                    <div class="input-group"><label>API Key <a href="#" onclick="showView('api');return false;" style="color:var(--accent-light);font-size:11px;margin-left:8px;">‚Üí Configura in API Connect</a></label><input type="text" id="apiKey" placeholder="Configura in API Connect..." autocomplete="off" readonly onclick="showView('api')" style="cursor:pointer;"></div>
                </div>
                <label style="display:block;font-size:12px;color:var(--text-secondary);margin-bottom:8px;">Chains</label>
                <div class="chain-selector" id="chainSelector"></div>
                <div class="status-log" id="statusLog"><div class="log-line info">üëã Configura le API in <strong>API Connect</strong>, seleziona un wallet e clicca "Scan"</div></div>
            </div>
            
            <div class="stats-grid">
                <div class="stat-card"><div class="stat-label">üí∞ Portfolio Value</div><div class="stat-value" id="totalEUR">‚Ç¨0,00</div><div class="stat-change text-secondary" id="totalUSD">$0,00 USD</div></div>
                <div class="stat-card"><div class="stat-label">ü™ô Assets</div><div class="stat-value" id="tokenCount">0</div><div class="stat-change text-secondary">tokens</div></div>
                <div class="stat-card"><div class="stat-label">üëõ Wallets</div><div class="stat-value" id="scannedWallets">0</div><div class="stat-change text-secondary" id="chainNames">-</div></div>
                <div class="stat-card" style="cursor:pointer;" onclick="showView('exchanges')"><div class="stat-label">üè¶ Exchanges</div><div class="stat-value" id="exchangeTotalEUR" style="color:#f3ba2f;">‚Ç¨0,00</div><div class="stat-change text-secondary" id="exchangeNames">Binance</div></div>
                <div class="stat-card"><div class="stat-label">üí± EUR/USD</div><div class="stat-value" id="eurUsdRate">0.849</div><div class="stat-change text-secondary">rate</div></div>
            </div>
            
            <div class="content-grid">
                <div class="card"><div class="card-header"><div class="card-title">Holdings</div></div><div id="holdingsContent"><div class="empty-state"><div class="icon">üëõ</div><h3>Nessun dato</h3></div></div></div>
                <div class="card"><div class="card-header"><div class="card-title">Allocation</div></div><canvas id="allocationChart"></canvas></div>
            </div>
            
            <div class="card" id="blacklistPanel" style="display:none;margin-top:20px;"><div class="card-header"><div class="card-title">üö´ Token Nascosti</div><button class="btn btn-secondary" onclick="clearBlacklist()" style="font-size:12px;padding:6px 12px;">üóëÔ∏è Svuota</button></div><div id="blacklistContent"></div></div>
        </div>
        
        <!-- WALLETS -->
        <div class="main-content" id="walletsView" style="display:none;">
            <div class="header"><h1>üëõ Gestione Wallets</h1></div>
            
            <div class="card" style="margin-bottom:20px;">
                <div class="card-header"><div class="card-title">‚ûï Aggiungi Wallet</div></div>
                <div class="input-row">
                    <div class="input-group"><label>Nome (es. "Main", "Trading", "Cold")</label><input type="text" id="newWalletName" placeholder="Nome wallet..." autocomplete="off"></div>
                    <div class="input-group" style="flex:2;"><label>Indirizzo (EVM o Solana)</label><input type="text" id="newWalletAddress" placeholder="0x... o indirizzo Solana" autocomplete="off"></div>
                </div>
                <button class="btn btn-primary" onclick="addWallet()" style="margin-top:12px;">üíæ Salva Wallet</button>
            </div>
            
            <div class="card">
                <div class="card-header"><div class="card-title">üìã Wallets Salvati</div></div>
                <div id="walletsList"></div>
            </div>
        </div>
        
        <!-- WALLET DETAIL -->
        <div class="main-content" id="walletDetailView" style="display:none;">
            <div class="header">
                <div style="display:flex;align-items:center;gap:16px;">
                    <button class="btn btn-secondary" onclick="showView('wallets')" style="padding:8px 12px;">‚Üê Indietro</button>
                    <h1 id="detailWalletName">Wallet</h1>
                </div>
                <div class="header-actions">
                    <button class="btn btn-primary" onclick="scanDetailWallet()">üîç Scan</button>
                </div>
            </div>
            
            <div class="card" style="margin-bottom:20px;">
                <div style="display:flex;align-items:center;gap:16px;">
                    <div style="width:64px;height:64px;border-radius:16px;background:linear-gradient(135deg,var(--accent),var(--accent-light));display:flex;align-items:center;justify-content:center;font-size:28px;">üëõ</div>
                    <div style="flex:1;">
                        <div style="font-size:13px;color:var(--text-secondary);">Indirizzo</div>
                        <div id="detailWalletAddress" style="font-family:monospace;font-size:14px;word-break:break-all;"></div>
                        <div id="detailScanDate" style="font-size:12px;color:var(--text-secondary);margin-top:6px;"></div>
                    </div>
                    <button class="btn btn-secondary" onclick="copyDetailAddress()" style="margin-left:auto;padding:8px 12px;">üìã Copia</button>
                </div>
            </div>
            
            <div class="stats-grid" style="grid-template-columns:repeat(4,1fr);">
                <div class="stat-card"><div class="stat-label">üí∞ Totale</div><div class="stat-value" id="detailTotal">‚Ç¨0,00</div></div>
                <div class="stat-card"><div class="stat-label">‚õìÔ∏è Chains</div><div class="stat-value" id="detailChainCount">0</div></div>
                <div class="stat-card"><div class="stat-label">ü™ô Token</div><div class="stat-value" id="detailTokenCount">0</div></div>
                <div class="stat-card"><div class="stat-label">üìú Transazioni</div><div class="stat-value" id="detailTxCount">0</div></div>
            </div>
            
            <!-- Tab Selector -->
            <div style="display:flex;gap:8px;margin:20px 0;">
                <button class="btn btn-primary" id="tabTokensBtn" onclick="showWalletTab('tokens')">ü™ô Token</button>
                <button class="btn btn-secondary" id="tabTxBtn" onclick="showWalletTab('transactions')">üìú Transazioni</button>
            </div>
            
            <div id="detailChainsContent"></div>
            <div id="detailTxContent" style="display:none;"></div>
        </div>
        
        <!-- TAX REPORT -->
        <div class="main-content" id="taxView" style="display:none;">
            <div class="header"><h1>üìã Tax Report - Quadro RW</h1><div class="header-actions"><button class="btn" onclick="clearTaxReport()" style="margin-right:8px;background:var(--bg-secondary);">üóëÔ∏è Reset</button><button class="btn btn-secondary" onclick="printTaxReport()" style="margin-right:8px;">üñ®Ô∏è Stampa PDF</button><button class="btn" onclick="fetchMissingPrices()" style="margin-right:8px;background:var(--green);color:#000;">üí∞ Fetch Prezzi</button><button class="btn" onclick="runAutoPilot()" style="margin-right:8px;background:linear-gradient(135deg,#f093fb 0%,#f5576c 100%);color:#fff;font-weight:bold;">üöÄ Auto-Pilot</button><button class="btn" onclick="openGlobalAIAnalysis()" style="margin-right:8px;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);color:#fff;">ü§ñ Analisi AI</button><button class="btn btn-primary" onclick="calculateTaxReportAll()">üßÆ Calcola</button></div></div>
            
            <div class="card" style="margin-bottom:20px;">
                <p style="color:var(--text-secondary);font-size:14px;line-height:1.6;">
                    Il <strong>Quadro RW</strong> richiede il valore al <strong>31 dicembre</strong> di ogni anno fiscale. Soglia: <strong>‚Ç¨15.000</strong>.<br>
                    Calcola il valore aggregato di <strong>wallet + exchange</strong>.
                </p>
                <div id="taxWalletsList" style="margin-top:12px;"></div>
            </div>
            
            <!-- GENERATORE QUADRO RW -->
            <div class="card" style="margin-bottom:20px;border:2px solid var(--accent);">
                <div class="card-header">
                    <div class="card-title">üìÑ Genera Quadro RW</div>
                </div>
                <div style="display:flex;flex-wrap:wrap;gap:16px;align-items:flex-end;">
                    <div class="input-group" style="flex:1;min-width:150px;">
                        <label>Anno Fiscale</label>
                        <select id="rwYearSelect" class="form-input" style="padding:10px;">
                            <option value="2021">2021</option>
                            <option value="2022">2022</option>
                            <option value="2023">2023</option>
                            <option value="2024">2024</option>
                            <option value="2025" selected>2025</option>
                        </select>
                    </div>
                    <button class="btn btn-primary" onclick="generateQuadroRW()" style="height:42px;">
                        üìã Genera Report
                    </button>
                    <button class="btn" onclick="generateQuadroRWWithAI()" style="height:42px;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);color:#fff;">
                        ü§ñ Genera con AI
                    </button>
                    <button class="btn btn-secondary" onclick="printQuadroRW()" style="height:42px;">
                        üñ®Ô∏è Stampa Anno
                    </button>
                </div>
            </div>
            
            <!-- QUADRO RW GENERATO -->
            <div id="quadroRWContainer" class="card" style="display:none;margin-bottom:20px;">
                <div class="card-header">
                    <div class="card-title" id="quadroRWTitle">üìÑ Quadro RW - Anno 2025</div>
                    <div style="display:flex;gap:8px;">
                        <button class="btn btn-secondary" onclick="exportQuadroRWCSV()" style="padding:6px 12px;font-size:12px;">üì• CSV</button>
                        <button class="btn btn-secondary" onclick="copyQuadroRW()" style="padding:6px 12px;font-size:12px;">üìã Copia</button>
                    </div>
                </div>
                <div id="quadroRWContent"></div>
            </div>
            
            <!-- EXCHANGE VALUES -->
            <div class="card" style="margin-bottom:20px;">
                <div class="card-header">
                    <div class="card-title">üè¶ Valori Exchange (31/12)</div>
                    <button class="btn btn-primary" onclick="saveExchangeValues()" style="padding:8px 16px;">üíæ Salva</button>
                </div>
                <p style="color:var(--text-secondary);font-size:13px;margin-bottom:16px;">Inserisci il valore totale degli exchange al 31 dicembre di ogni anno (in EUR). Questi valori verranno sommati ai wallet.</p>
                <div style="display:grid;grid-template-columns:repeat(6,1fr);gap:12px;">
                    <div class="input-group">
                        <label>2021</label>
                        <input type="number" id="exchange2021" placeholder="‚Ç¨" step="0.01" style="text-align:right;">
                    </div>
                    <div class="input-group">
                        <label>2022</label>
                        <input type="number" id="exchange2022" placeholder="‚Ç¨" step="0.01" style="text-align:right;">
                    </div>
                    <div class="input-group">
                        <label>2023</label>
                        <input type="number" id="exchange2023" placeholder="‚Ç¨" step="0.01" style="text-align:right;">
                    </div>
                    <div class="input-group">
                        <label>2024</label>
                        <input type="number" id="exchange2024" placeholder="‚Ç¨" step="0.01" style="text-align:right;">
                    </div>
                    <div class="input-group">
                        <label>2025</label>
                        <input type="number" id="exchange2025" placeholder="‚Ç¨" step="0.01" style="text-align:right;">
                    </div>
                    <div class="input-group">
                        <label>2026</label>
                        <input type="number" id="exchange2026" placeholder="‚Ç¨" step="0.01" style="text-align:right;">
                    </div>
                </div>
                <div style="margin-top:12px;font-size:12px;color:var(--text-secondary);">
                    üí° Puoi recuperare questi valori da OKIPO, Binance Tax Report, o i tuoi record personali.
                </div>
            </div>
            
            <div class="card"><div class="card-header"><div class="card-title">üìä Totale Portfolio per Anno (31/12)</div></div><div id="taxReportContent"><div class="empty-state"><div class="icon">üëÜ</div><h3>Clicca "Calcola Tutti" per iniziare</h3></div></div></div>
            <div class="card" id="taxDetailCard" style="display:none;margin-top:20px;"><div class="card-header"><div class="card-title">üìù Dettaglio Token per Wallet</div></div><div id="taxDetailContent"></div></div>
            
            <!-- STORICO QUADRI RW -->
            <div class="card" style="margin-top:20px;">
                <div class="card-header">
                    <div class="card-title">üìö Storico Quadri RW Generati</div>
                </div>
                <div id="rwHistoryList">
                    <div class="empty-state" style="padding:20px;">
                        <div style="color:var(--text-secondary);">Nessun Quadro RW generato ancora.<br>Seleziona un anno e clicca "Genera Report".</div>
                    </div>
                </div>
            </div>
            
            <!-- COST BASIS SUMMARY -->
            <div class="card" style="margin-top:20px;">
                <div class="card-header">
                    <div class="card-title">üí∞ Cost Basis - Storico Acquisti</div>
                    <div style="display:flex;gap:8px;">
                        <select id="costBasisMethod" class="form-input" style="padding:6px 10px;font-size:12px;width:auto;">
                            <option value="CMP">Costo Medio (CMP)</option>
                            <option value="FIFO">FIFO</option>
                            <option value="LIFO">LIFO</option>
                        </select>
                        <button class="btn btn-secondary" onclick="refreshCostBasisUI()" style="padding:6px 12px;font-size:12px;">üîÑ Aggiorna</button>
                        <button class="btn" onclick="runReconciliator()" style="padding:6px 12px;font-size:12px;background:var(--yellow);color:#000;">üîç Verifica</button>
                        <button class="btn" onclick="clearCostBasis()" style="padding:6px 12px;font-size:12px;background:var(--red);">üóëÔ∏è Reset</button>
                    </div>
                </div>
                <p style="color:var(--text-secondary);font-size:13px;margin-bottom:16px;">
                    Prezzo medio di acquisto per ogni token. <strong>Dal 2026:</strong> 33% su tutto, 26% solo su EUR stablecoin (MiCAR).
                </p>
                <div id="costBasisContent">
                    <div class="empty-state" style="padding:20px;">
                        <div style="color:var(--text-secondary);">Importa CSV da Binance o Bitpanda per calcolare il cost basis automaticamente.</div>
                    </div>
                </div>
                <div id="reconciliatorResults" style="display:none;margin-top:16px;"></div>
            </div>
        </div>
        
        <!-- API CONNECT -->
        <div class="main-content" id="apiView" style="display:none;">
            <div class="header"><h1>üîå API Connect</h1></div>
            
            <div class="card" style="margin-bottom:20px;">
                <p style="color:var(--text-secondary);font-size:14px;line-height:1.6;">
                    Configura le API per accedere ai dati blockchain. <strong>Moralis</strong> √® consigliato per scan veloci, <strong>Etherscan</strong> per il Tax Report storico.
                </p>
            </div>
            
            <!-- MORALIS -->
            <div class="card" style="margin-bottom:20px;">
                <div class="card-header">
                    <div class="card-title" style="display:flex;align-items:center;gap:12px;">
                        <span style="width:40px;height:40px;background:#21BF96;border-radius:10px;display:flex;align-items:center;justify-content:center;font-size:20px;">üü¢</span>
                        <div>
                            <div>Moralis</div>
                            <div style="font-size:12px;color:var(--text-secondary);font-weight:normal;">Scan veloce ‚Ä¢ Balance diretti ‚Ä¢ Multi-chain</div>
                        </div>
                    </div>
                    <span class="api-status" id="moralisStatus">OFF</span>
                </div>
                <div class="input-row" style="margin-top:16px;">
                    <div class="input-group" style="flex:3;">
                        <label>API Keys <span style="font-weight:normal;color:var(--text-secondary);">(1 per riga per cascata)</span> <a href="https://admin.moralis.io/api-keys" target="_blank" style="color:var(--accent);font-size:11px;margin-left:8px;">‚Üí Ottieni gratis</a></label>
                        <textarea id="moralisKey" rows="3" placeholder="eyJhbGci... (prima key)&#10;eyJhbGci... (seconda key)&#10;eyJhbGci... (terza key)" autocomplete="off" style="resize:vertical;min-height:60px;"></textarea>
                    </div>
                    <div class="input-group" style="flex:0;align-self:flex-end;">
                        <button class="btn btn-primary" onclick="saveMoralisKey()">üíæ Salva</button>
                    </div>
                </div>
                <div style="margin-top:12px;padding:12px;background:var(--bg-primary);border-radius:8px;font-size:12px;">
                    <strong>Chains supportate:</strong> Ethereum, BSC, Polygon, Arbitrum, Optimism, Base, Cronos<br>
                    <strong>Limite free:</strong> 25 req/sec, 10.000/giorno per account<br>
                    <strong>üí° Multi-account:</strong> Inserisci pi√π keys (1 per riga) - quando una raggiunge il limite, passa alla successiva!
                </div>
            </div>
            
            <!-- ETHERSCAN -->
            <div class="card" style="margin-bottom:20px;">
                <div class="card-header">
                    <div class="card-title" style="display:flex;align-items:center;gap:12px;">
                        <span style="width:40px;height:40px;background:#21325B;border-radius:10px;display:flex;align-items:center;justify-content:center;font-size:20px;">üîµ</span>
                        <div>
                            <div>Etherscan</div>
                            <div style="font-size:12px;color:var(--text-secondary);font-weight:normal;">Tax Report ‚Ä¢ Storico transazioni ‚Ä¢ Multi-chain V2</div>
                        </div>
                    </div>
                    <span class="api-status" id="etherscanStatus">OFF</span>
                </div>
                <div class="input-row" style="margin-top:16px;">
                    <div class="input-group" style="flex:3;">
                        <label>API Key <a href="https://etherscan.io/myapikey" target="_blank" style="color:var(--accent);font-size:11px;margin-left:8px;">‚Üí Ottieni gratis</a></label>
                        <input type="password" id="etherscanKey" placeholder="ABCDEF..." autocomplete="off">
                    </div>
                    <div class="input-group" style="flex:0;align-self:flex-end;">
                        <button class="btn btn-primary" onclick="saveEtherscanKey()">üíæ Salva</button>
                    </div>
                </div>
                <div style="margin-top:12px;padding:12px;background:var(--bg-primary);border-radius:8px;font-size:12px;">
                    <strong>Chains supportate:</strong> Ethereum, BSC, Polygon, Arbitrum, Optimism, Base (API V2)<br>
                    <strong>Limite free:</strong> 5 req/sec, 100.000/giorno
                </div>
            </div>
            
            <!-- PULSESCAN -->
            <div class="card" style="margin-bottom:20px;">
                <div class="card-header">
                    <div class="card-title" style="display:flex;align-items:center;gap:12px;">
                        <span style="width:40px;height:40px;background:#00ff00;border-radius:10px;display:flex;align-items:center;justify-content:center;font-size:20px;">üíö</span>
                        <div>
                            <div>PulseChain</div>
                            <div style="font-size:12px;color:var(--text-secondary);font-weight:normal;">PulseScan API ‚Ä¢ Gratuito ‚Ä¢ No API key richiesta</div>
                        </div>
                    </div>
                    <span class="api-status" style="background:var(--green);color:#000;">AUTO</span>
                </div>
                <div style="margin-top:12px;padding:12px;background:var(--bg-primary);border-radius:8px;font-size:12px;">
                    <strong>Endpoint:</strong> api.scan.pulsechain.com<br>
                    <strong>Note:</strong> Nessuna configurazione necessaria, funziona automaticamente
                </div>
            </div>
            
            <!-- SOLANA / HELIUS -->
            <div class="card" style="margin-bottom:20px;">
                <div class="card-header">
                    <div class="card-title" style="display:flex;align-items:center;gap:12px;">
                        <span style="width:40px;height:40px;background:#9945ff;border-radius:10px;display:flex;align-items:center;justify-content:center;font-size:20px;">üü£</span>
                        <div>
                            <div>Solana (Helius)</div>
                            <div style="font-size:12px;color:var(--text-secondary);font-weight:normal;">API Veloce ‚Ä¢ Token SPL ‚Ä¢ NFT</div>
                        </div>
                    </div>
                    <span class="api-status" id="heliusStatus">OFF</span>
                </div>
                <div class="input-row" style="margin-top:16px;">
                    <div class="input-group" style="flex:3;">
                        <label>API Key <a href="https://www.helius.dev/" target="_blank" style="color:var(--accent);font-size:11px;margin-left:8px;">‚Üí Ottieni gratis</a></label>
                        <input type="password" id="heliusKey" placeholder="xxx-xxx-xxx..." autocomplete="off">
                    </div>
                    <div class="input-group" style="flex:0;align-self:flex-end;">
                        <button class="btn btn-primary" onclick="saveHeliusKey()">üíæ Salva</button>
                    </div>
                </div>
                <div style="margin-top:12px;padding:12px;background:var(--bg-primary);border-radius:8px;font-size:12px;">
                    <strong>Endpoint:</strong> api.helius.xyz<br>
                    <strong>Limite free:</strong> 30 req/sec, 500.000/mese
                </div>
            </div>
            
            <!-- BINANCE API STORICO -->
            <!-- API STATUS SUMMARY -->
            <div class="card">
                <div class="card-header"><div class="card-title">üìä Riepilogo API</div></div>
                <div id="apiSummary" style="display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:12px;"></div>
            </div>
        </div>
        
        <!-- NFT -->
        <div class="main-content" id="nftView" style="display:none;">
            <div class="header"><h1>üñºÔ∏è NFT Portfolio</h1><div class="header-actions"><button class="btn btn-primary" onclick="scanAllNFTs()">üîç Scansiona NFT</button></div></div>
            
            <div class="card" style="margin-bottom:20px;">
                <p style="color:var(--text-secondary);font-size:14px;line-height:1.6;">
                    Visualizza i tuoi <strong>NFT</strong> su tutte le chain EVM e Solana.<br>
                    Puoi inserire il <strong>prezzo di acquisto</strong> per calcolare guadagni/perdite.
                </p>
            </div>
            
            <!-- RIEPILOGO NFT -->
            <div class="card" style="margin-bottom:20px;">
                <div class="card-header"><div class="card-title">üìä Riepilogo</div></div>
                <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:16px;">
                    <div style="background:var(--bg-primary);padding:16px;border-radius:8px;text-align:center;">
                        <div style="font-size:12px;color:var(--text-secondary);">NFT Totali</div>
                        <div id="nftTotalCount" style="font-size:24px;font-weight:700;color:var(--accent);">0</div>
                    </div>
                    <div style="background:var(--bg-primary);padding:16px;border-radius:8px;text-align:center;">
                        <div style="font-size:12px;color:var(--text-secondary);">Valore Stimato</div>
                        <div id="nftTotalValue" style="font-size:24px;font-weight:700;color:var(--green);">‚Ç¨0</div>
                    </div>
                    <div style="background:var(--bg-primary);padding:16px;border-radius:8px;text-align:center;">
                        <div style="font-size:12px;color:var(--text-secondary);">Costo Acquisto</div>
                        <div id="nftTotalCost" style="font-size:24px;font-weight:700;color:var(--text-secondary);">‚Ç¨0</div>
                    </div>
                    <div style="background:var(--bg-primary);padding:16px;border-radius:8px;text-align:center;">
                        <div style="font-size:12px;color:var(--text-secondary);">P/L</div>
                        <div id="nftTotalPL" style="font-size:24px;font-weight:700;">‚Ç¨0</div>
                    </div>
                </div>
            </div>
            
            <!-- LISTA NFT -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">üñºÔ∏è I Tuoi NFT</div>
                    <div style="display:flex;gap:8px;">
                        <select id="nftChainFilter" onchange="filterNFTsByChain()" style="background:var(--bg-primary);color:var(--text-primary);border:none;padding:8px 12px;border-radius:6px;">
                            <option value="all">Tutte le chain</option>
                            <option value="eth">Ethereum</option>
                            <option value="polygon">Polygon</option>
                            <option value="bsc">BSC</option>
                            <option value="arbitrum">Arbitrum</option>
                            <option value="base">Base</option>
                            <option value="solana">Solana</option>
                        </select>
                    </div>
                </div>
                <div id="nftGrid" style="display:grid;grid-template-columns:repeat(auto-fill,minmax(280px,1fr));gap:16px;padding:16px 0;">
                    <div style="color:var(--text-secondary);text-align:center;padding:40px;grid-column:1/-1;">
                        Nessun NFT trovato. Clicca "üîç Scansiona NFT" per cercare i tuoi NFT.
                    </div>
                </div>
            </div>
        </div>
        
        <!-- EXCHANGES -->
        <div class="main-content" id="exchangesView" style="display:none;">
            <div class="header"><h1>üè¶ Exchanges</h1><div class="header-actions"><button class="btn" onclick="runCompleteAnalysis()" style="margin-right:8px;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);color:#fff;font-weight:bold;padding:10px 20px;">ü§ñ Analizza Tutto</button><button class="btn btn-secondary" onclick="clearAllExchangeData()" style="margin-right:8px;">üóëÔ∏è Reset</button><button class="btn btn-primary" onclick="recalculateAllExchanges()">üßÆ Ricalcola</button></div></div>
            
            <!-- CALL TO ACTION - Analisi Automatica -->
            <div id="analysisCTA" class="card" style="margin-bottom:20px;background:linear-gradient(135deg,rgba(102,126,234,0.15),rgba(118,75,162,0.15));border:2px solid rgba(102,126,234,0.3);">
                <div style="display:flex;align-items:center;justify-content:space-between;flex-wrap:wrap;gap:16px;">
                    <div style="flex:1;min-width:200px;">
                        <div style="font-size:18px;font-weight:700;margin-bottom:6px;">ü§ñ Analisi Automatica con AI</div>
                        <div style="font-size:13px;color:var(--text-secondary);">
                            Dopo aver importato tutti i dati, clicca per: recuperare prezzi storici, riconciliare trasferimenti, risolvere discrepanze e calcolare il cost basis automaticamente.
                        </div>
                    </div>
                    <button class="btn" onclick="runCompleteAnalysis()" style="background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);color:#fff;font-weight:bold;padding:14px 28px;font-size:15px;white-space:nowrap;">
                        üöÄ Avvia Analisi Completa
                    </button>
                </div>
            </div>
            
            <!-- TOTALE EXCHANGES -->
            <div class="card" style="margin-bottom:20px;background:linear-gradient(135deg,rgba(243,186,47,0.1),rgba(0,230,118,0.1));">
                <div class="card-header"><div class="card-title">üìä Totale Exchange per Anno (31/12)</div></div>
                <div id="exchangeTotalsGrid" style="display:grid;grid-template-columns:repeat(6,1fr);gap:12px;margin-top:12px;">
                    <div style="background:var(--bg-primary);border-radius:8px;padding:16px;text-align:center;">
                        <div style="font-size:12px;color:var(--text-secondary);">2021</div>
                        <div id="exchTotal2021" style="font-size:18px;font-weight:700;color:var(--green);">‚Ç¨0</div>
                    </div>
                    <div style="background:var(--bg-primary);border-radius:8px;padding:16px;text-align:center;">
                        <div style="font-size:12px;color:var(--text-secondary);">2022</div>
                        <div id="exchTotal2022" style="font-size:18px;font-weight:700;color:var(--green);">‚Ç¨0</div>
                    </div>
                    <div style="background:var(--bg-primary);border-radius:8px;padding:16px;text-align:center;">
                        <div style="font-size:12px;color:var(--text-secondary);">2023</div>
                        <div id="exchTotal2023" style="font-size:18px;font-weight:700;color:var(--green);">‚Ç¨0</div>
                    </div>
                    <div style="background:var(--bg-primary);border-radius:8px;padding:16px;text-align:center;">
                        <div style="font-size:12px;color:var(--text-secondary);">2024</div>
                        <div id="exchTotal2024" style="font-size:18px;font-weight:700;color:var(--green);">‚Ç¨0</div>
                    </div>
                    <div style="background:var(--bg-primary);border-radius:8px;padding:16px;text-align:center;">
                        <div style="font-size:12px;color:var(--text-secondary);">2025</div>
                        <div id="exchTotal2025" style="font-size:18px;font-weight:700;color:var(--green);">‚Ç¨0</div>
                    </div>
                    <div style="background:var(--bg-primary);border-radius:8px;padding:16px;text-align:center;">
                        <div style="font-size:12px;color:var(--text-secondary);">2026</div>
                        <div id="exchTotal2026" style="font-size:18px;font-weight:700;color:var(--green);">‚Ç¨0</div>
                    </div>
                </div>
            </div>
            
            <!-- EXCHANGE GRID - Card compatte -->
            <div id="exchangeGrid" style="display:grid;grid-template-columns:repeat(auto-fill,minmax(200px,1fr));gap:16px;"></div>
        </div>
        
        <!-- EXCHANGE DETAIL VIEW -->
        <div class="main-content" id="exchangeDetailView" style="display:none;">
            <div class="header">
                <div style="display:flex;align-items:center;gap:16px;">
                    <button class="btn btn-secondary" onclick="showView('exchanges')" style="padding:8px 12px;">‚Üê Indietro</button>
                    <h1 id="exchDetailName">Exchange</h1>
                </div>
                <div class="header-actions">
                    <button class="btn btn-secondary" onclick="clearCurrentExchangeData()" style="margin-right:8px;">üóëÔ∏è Reset</button>
                    <button class="btn btn-primary" id="exchDetailScanBtn" onclick="scanCurrentExchange()">üîÑ Aggiorna</button>
                </div>
            </div>
            
            <!-- Info Exchange -->
            <div class="card" style="margin-bottom:20px;">
                <div style="display:flex;align-items:center;gap:16px;">
                    <div id="exchDetailLogo" style="width:64px;height:64px;border-radius:16px;display:flex;align-items:center;justify-content:center;font-size:28px;"></div>
                    <div style="flex:1;">
                        <div id="exchDetailStatus" style="font-size:13px;color:var(--text-secondary);"></div>
                        <div id="exchDetailLastUpdate" style="font-size:12px;color:var(--text-secondary);margin-top:6px;"></div>
                    </div>
                </div>
            </div>
            
            <!-- Totali per Anno -->
            <div class="card" style="margin-bottom:20px;">
                <div class="card-header"><div class="card-title">üí∞ Valore al 31/12</div></div>
                <div id="exchDetailYearGrid" style="display:grid;grid-template-columns:repeat(6,1fr);gap:12px;margin-top:12px;"></div>
            </div>
            
            <!-- Azioni -->
            <div class="card" style="margin-bottom:20px;">
                <div class="card-header"><div class="card-title">‚ö° Azioni</div></div>
                <div style="display:flex;flex-wrap:wrap;gap:12px;margin-top:12px;">
                    <!-- Exchange API (dinamico) -->
                    <div id="exchDetailApiSection" style="display:none;">
                        <button id="exchDetailApiBtn" class="btn" onclick="openExchangeApiModal()" style="background:#f3ba2f;color:#000;">
                            üîó Connetti API
                        </button>
                        <span id="exchDetailServerStatus" style="margin-left:8px;font-size:12px;"></span>
                    </div>
                    
                    <!-- CSV Import -->
                    <div id="exchDetailCsvSection">
                        <input type="file" id="exchDetailFileInput" accept=".csv,.zip" multiple style="display:none;" onchange="handleExchDetailFileSelect(event)">
                        <button class="btn btn-secondary" onclick="document.getElementById('exchDetailFileInput').click()">
                            üìÅ Importa CSV/ZIP
                        </button>
                    </div>
                    
                    <!-- AI Analysis -->
                    <div>
                        <button class="btn" onclick="openAIAnalysisModal()" style="background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);color:#fff;">
                            ü§ñ Analizza con AI
                        </button>
                    </div>
                    
                    <!-- Dropzone -->
                    <div id="exchDetailDropzone" 
                         style="flex:1;min-width:200px;border:2px dashed var(--border);border-radius:8px;padding:20px;text-align:center;color:var(--text-secondary);cursor:pointer;"
                         ondrop="handleExchDetailDrop(event)" 
                         ondragover="event.preventDefault();this.style.borderColor='var(--accent)';this.style.background='rgba(108,92,231,0.1)'"
                         ondragleave="this.style.borderColor='var(--border)';this.style.background='transparent'"
                         onclick="document.getElementById('exchDetailFileInput').click()">
                        üì• Trascina CSV o ZIP qui
                    </div>
                </div>
                
                <!-- Progress -->
                <div id="exchDetailProgress" style="display:none;margin-top:16px;">
                    <div style="background:var(--bg-primary);border-radius:4px;height:8px;overflow:hidden;">
                        <div id="exchDetailProgressBar" style="background:var(--accent);height:100%;width:0%;transition:width 0.3s;"></div>
                    </div>
                    <div id="exchDetailProgressText" style="font-size:12px;color:var(--text-secondary);margin-top:8px;text-align:center;"></div>
                </div>
            </div>
            
            <!-- Saldi Reali (per Binance) -->
            <div id="exchDetailBalancesSection" class="card" style="margin-bottom:20px;display:none;">
                <div class="card-header">
                    <div class="card-title">üíé Saldi Reali</div>
                    <button class="btn btn-secondary" onclick="showAllExchBalances()" style="padding:6px 12px;font-size:12px;">üëÅÔ∏è Vedi tutti</button>
                </div>
                <div id="exchDetailBalances" style="display:grid;grid-template-columns:repeat(auto-fill,minmax(150px,1fr));gap:12px;margin-top:12px;"></div>
            </div>
            
            <!-- ‚ö†Ô∏è Sezione Discrepanze -->
            <div id="exchDetailDiscrepancies" class="card" style="margin-bottom:20px;display:none;border:2px solid var(--yellow);">
                <div class="card-header" style="background:rgba(243,186,47,0.1);">
                    <div class="card-title" style="color:var(--yellow);">‚ö†Ô∏è Discrepanze Rilevate (<span id="discrepancyCount">0</span>)</div>
                    <div style="display:flex;gap:8px;">
                        <button class="btn" onclick="analyzeDiscrepanciesWithAI()" style="padding:6px 12px;font-size:12px;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);color:#fff;">ü§ñ Analizza con AI</button>
                        <button class="btn btn-secondary" onclick="refreshDiscrepancies()" style="padding:6px 12px;font-size:12px;">üîÑ Aggiorna</button>
                        <button class="btn" onclick="resolveAllDiscrepancies()" style="padding:6px 12px;font-size:12px;background:var(--green);color:#000;">‚úÖ Risolvi Tutte</button>
                    </div>
                </div>
                <div id="discrepancyList" style="margin-top:12px;"></div>
                <div style="margin-top:12px;padding:12px;background:var(--bg-primary);border-radius:8px;font-size:12px;color:var(--text-secondary);">
                    üí° <strong>Cause comuni:</strong> Staking rewards, Airdrop, Referral bonus, Dust ‚Üí BNB conversion, Fork tokens
                </div>
            </div>
            
            <!-- Transazioni -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">üìú Transazioni (<span id="exchDetailTxCount">0</span>)</div>
                    <div style="display:flex;gap:8px;align-items:center;">
                        <select id="exchDetailTxYear" onchange="filterExchDetailTx()" style="padding:6px 10px;background:var(--bg-primary);border:1px solid var(--border);border-radius:6px;color:var(--text-primary);font-size:12px;">
                            <option value="">Tutti gli anni</option>
                            <option value="2021">2021</option>
                            <option value="2022">2022</option>
                            <option value="2023">2023</option>
                            <option value="2024">2024</option>
                            <option value="2025">2025</option>
                            <option value="2026">2026</option>
                        </select>
                        <select id="exchDetailTxType" onchange="filterExchDetailTx()" style="padding:6px 10px;background:var(--bg-primary);border:1px solid var(--border);border-radius:6px;color:var(--text-primary);font-size:12px;">
                            <option value="">Tutti i tipi</option>
                            <option value="buy">üõí Buy</option>
                            <option value="sell">üí∞ Sell</option>
                            <option value="deposit">üì• Deposit</option>
                            <option value="withdrawal">üì§ Withdrawal</option>
                            <option value="trade">üìä Trade</option>
                            <option value="convert">üîÑ Convert</option>
                            <option value="staking">ü•© Staking</option>
                            <option value="interest">üí∞ Interest</option>
                        </select>
                        <button class="btn" onclick="fetchTransactionPrices()" style="padding:6px 12px;font-size:12px;background:var(--green);color:#000;">üí∞ Fetch Prezzi</button>
                        <button class="btn btn-secondary" onclick="showDiscrepancyReport(currentDetailExchange)" style="padding:6px 12px;font-size:12px;" title="Verifica discrepanze saldi">üîç Verifica</button>
                        <button class="btn btn-secondary" onclick="showAddManualTxModal(currentDetailExchange)" style="padding:6px 12px;font-size:12px;" title="Aggiungi transazione manuale">‚ûï TX</button>
                        <button class="btn btn-secondary" onclick="exportExchDetailTx()" style="padding:6px 12px;font-size:12px;">üì• CSV</button>
                    </div>
                </div>
                <div style="overflow-x:auto;margin-top:12px;">
                    <table class="tx-table">
                        <thead>
                            <tr>
                                <th style="text-align:left;">Data</th>
                                <th style="text-align:left;">Tipo</th>
                                <th style="text-align:center;">Coin</th>
                                <th style="text-align:right;">Importo</th>
                                <th style="text-align:right;">Valore ‚Ç¨</th>
                            </tr>
                        </thead>
                        <tbody id="exchDetailTxTable">
                            <tr><td colspan="5" style="text-align:center;padding:40px;color:var(--text-secondary);">
                                Importa transazioni con CSV o API
                            </td></tr>
                        </tbody>
                    </table>
                </div>
                <div id="exchDetailTxPagination" style="display:flex;justify-content:center;gap:8px;margin-top:16px;"></div>
            </div>
        </div>
        
        <!-- RICONCILIAZIONE VIEW -->
        <div class="main-content" id="reconcileView" style="display:none;">
            <div class="header">
                <h1>üîó Riconciliazione Smart v2.0</h1>
                <div class="header-actions">
                    <button class="btn btn-secondary" onclick="exportReconciliationReport()">üìÑ Export Report</button>
                    <button class="btn btn-primary" onclick="runSmartReconciliation()">‚ñ∂Ô∏è Esegui Riconciliazione</button>
                </div>
            </div>
        
        <!-- INFO BOX -->
        <div class="card" style="margin-bottom:20px;background:linear-gradient(135deg, rgba(108,92,231,0.1), rgba(108,92,231,0.05));border-color:var(--accent);">
            <p style="color:var(--text-primary);font-size:14px;line-height:1.8;margin-bottom:12px;">
                <strong>üéØ Matching a 3 Livelli:</strong>
            </p>
            <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:12px;margin-bottom:16px;">
                <div style="background:rgba(0,0,0,0.2);padding:12px;border-radius:8px;border-left:3px solid var(--green);">
                    <div style="font-weight:600;color:var(--green);">üîí Livello 1: TxHash</div>
                    <div style="font-size:12px;color:var(--text-secondary);">Match per hash transazione (100% sicuro)</div>
                </div>
                <div style="background:rgba(0,0,0,0.2);padding:12px;border-radius:8px;border-left:3px solid var(--accent);">
                    <div style="font-weight:600;color:var(--accent);">‚úì Livello 2: Esatto</div>
                    <div style="font-size:12px;color:var(--text-secondary);">Stesso importo ¬±0.1%, entro 2 ore</div>
                </div>
                <div style="background:rgba(0,0,0,0.2);padding:12px;border-radius:8px;border-left:3px solid #f59e0b;">
                    <div style="font-weight:600;color:#f59e0b;">~ Livello 3: Fuzzy</div>
                    <div style="font-size:12px;color:var(--text-secondary);">Importo ¬±5%, entro 24h (conferma manuale)</div>
                </div>
            </div>
            <div style="display:flex;gap:12px;flex-wrap:wrap;">
                <button class="btn btn-secondary" onclick="loadReconciliationData()">üìä Carica Dati</button>
                <button class="btn btn-secondary" onclick="resetReconciliationData()" style="background:var(--red);">üóëÔ∏è Reset</button>
            </div>
        </div>
        
        <!-- STATS GRID -->
        <div style="display:grid;grid-template-columns:repeat(5,1fr);gap:16px;margin-bottom:20px;">
            <div class="card" style="text-align:center;padding:20px;border-top:3px solid #f3ba2f;">
                <div style="font-size:12px;color:var(--text-secondary);margin-bottom:4px;">TX Exchange</div>
                <div id="reconcileExchCount" style="font-size:28px;font-weight:700;color:#f3ba2f;">0</div>
            </div>
            <div class="card" style="text-align:center;padding:20px;border-top:3px solid var(--accent);">
                <div style="font-size:12px;color:var(--text-secondary);margin-bottom:4px;">TX Wallet</div>
                <div id="reconcileWalletCount" style="font-size:28px;font-weight:700;color:var(--accent);">0</div>
            </div>
            <div class="card" style="text-align:center;padding:20px;border-top:3px solid var(--green);">
                <div style="font-size:12px;color:var(--text-secondary);margin-bottom:4px;">Match Confermati</div>
                <div id="reconcileMatchCount" style="font-size:28px;font-weight:700;color:var(--green);">0</div>
            </div>
            <div class="card" style="text-align:center;padding:20px;border-top:3px solid #f59e0b;">
                <div style="font-size:12px;color:var(--text-secondary);margin-bottom:4px;">Da Verificare</div>
                <div id="reconcilePendingCount" style="font-size:28px;font-weight:700;color:#f59e0b;">0</div>
            </div>
            <div class="card" style="text-align:center;padding:20px;border-top:3px solid var(--red);">
                <div style="font-size:12px;color:var(--text-secondary);margin-bottom:4px;">Non Riconciliati</div>
                <div id="reconcileUnmatchedCount" style="font-size:28px;font-weight:700;color:var(--red);">0</div>
            </div>
        </div>
        
        <!-- TABS -->
        <div style="display:flex;gap:4px;padding:4px;background:var(--bg-secondary);border-radius:12px;margin-bottom:20px;">
            <button class="btn btn-secondary reconcile-tab active" data-tab="matches" onclick="showReconcileTab('matches')" style="flex:1;">
                ‚úÖ Match Confermati <span id="matchCountBadge" style="background:rgba(0,206,201,0.2);color:var(--green);padding:2px 8px;border-radius:10px;font-size:11px;margin-left:6px;">0</span>
            </button>
            <button class="btn btn-secondary reconcile-tab" data-tab="pending" onclick="showReconcileTab('pending')" style="flex:1;">
                ‚è≥ Da Verificare <span id="pendingCountBadge" style="background:rgba(245,158,11,0.2);color:#f59e0b;padding:2px 8px;border-radius:10px;font-size:11px;margin-left:6px;">0</span>
            </button>
            <button class="btn btn-secondary reconcile-tab" data-tab="unmatched" onclick="showReconcileTab('unmatched')" style="flex:1;">
                ‚ùì Non Riconciliati <span id="unmatchedCountBadge" style="background:rgba(239,68,68,0.2);color:var(--red);padding:2px 8px;border-radius:10px;font-size:11px;margin-left:6px;">0</span>
            </button>
            <button class="btn btn-secondary reconcile-tab" data-tab="log" onclick="showReconcileTab('log')" style="flex:1;">
                üìù Log
            </button>
        </div>
        
        <!-- TAB: MATCH CONFERMATI -->
        <div class="card reconcile-tab-content" id="reconcileTabMatches" style="margin-bottom:20px;">
            <div class="card-header">
                <div class="card-title">‚úÖ Trasferimenti Riconciliati</div>
                <div style="display:flex;gap:8px;">
                    <select id="matchTypeFilter" onchange="filterMatches()" style="padding:8px 12px;background:var(--bg-primary);border:1px solid var(--border);border-radius:8px;color:var(--text-primary);font-size:12px;">
                        <option value="all">Tutti i tipi</option>
                        <option value="txhash">üîí TxHash</option>
                        <option value="exact">‚úì Esatti</option>
                        <option value="fuzzy">~ Fuzzy</option>
                    </select>
                    <select id="matchYearFilter" onchange="filterMatches()" style="padding:8px 12px;background:var(--bg-primary);border:1px solid var(--border);border-radius:8px;color:var(--text-primary);font-size:12px;">
                        <option value="all">Tutti gli anni</option>
                        <option value="2021">2021</option>
                        <option value="2022">2022</option>
                        <option value="2023">2023</option>
                        <option value="2024">2024</option>
                        <option value="2025">2025</option>
                    </select>
                </div>
            </div>
            <div id="reconcileMatches" style="max-height:500px;overflow-y:auto;">
                <div style="color:var(--text-secondary);text-align:center;padding:60px;">
                    <div style="font-size:48px;margin-bottom:16px;opacity:0.5;">üîó</div>
                    <div style="font-size:16px;font-weight:600;margin-bottom:8px;">Nessun match trovato</div>
                    <div style="font-size:13px;">Clicca "Carica Dati" e poi "Esegui Riconciliazione"</div>
                </div>
            </div>
        </div>
        
        <!-- TAB: DA VERIFICARE -->
        <div class="card reconcile-tab-content" id="reconcileTabPending" style="margin-bottom:20px;display:none;">
            <div class="card-header">
                <div class="card-title">‚è≥ Match da Confermare (Fuzzy)</div>
                <div style="display:flex;gap:8px;">
                    <button class="btn btn-secondary" onclick="confirmAllPendingMatches()" style="background:var(--green);color:#000;">‚úÖ Conferma Tutti</button>
                    <button class="btn btn-secondary" onclick="rejectAllPendingMatches()" style="background:var(--red);">‚ùå Rifiuta Tutti</button>
                </div>
            </div>
            <div id="reconcilePending" style="max-height:500px;overflow-y:auto;">
                <div style="color:var(--text-secondary);text-align:center;padding:60px;">
                    <div style="font-size:48px;margin-bottom:16px;opacity:0.5;">‚ú®</div>
                    <div style="font-size:16px;font-weight:600;margin-bottom:8px;">Nessun match in attesa</div>
                    <div style="font-size:13px;">I match fuzzy appariranno qui per la tua conferma</div>
                </div>
            </div>
        </div>
        
        <!-- TAB: NON RICONCILIATI -->
        <div class="card reconcile-tab-content" id="reconcileTabUnmatched" style="margin-bottom:20px;display:none;">
            <div class="card-header">
                <div class="card-title">‚ùì Transazioni Non Riconciliate</div>
            </div>
            <div style="display:grid;grid-template-columns:1fr 1fr;gap:20px;">
                <div>
                    <h4 style="margin-bottom:12px;color:#f3ba2f;font-size:14px;">üè¶ Exchange (senza match wallet)</h4>
                    <div id="unmatchedExchange" style="max-height:400px;overflow-y:auto;font-size:12px;background:var(--bg-primary);border-radius:8px;padding:12px;">
                        <div style="color:var(--text-secondary);text-align:center;padding:20px;">Nessuna transazione</div>
                    </div>
                </div>
                <div>
                    <h4 style="margin-bottom:12px;color:var(--accent);font-size:14px;">üëõ Wallet (senza match exchange)</h4>
                    <div id="unmatchedWallet" style="max-height:400px;overflow-y:auto;font-size:12px;background:var(--bg-primary);border-radius:8px;padding:12px;">
                        <div style="color:var(--text-secondary);text-align:center;padding:20px;">Nessuna transazione</div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- TAB: LOG -->
        <div class="card reconcile-tab-content" id="reconcileTabLog" style="display:none;">
            <div class="card-header">
                <div class="card-title">üìù Log Riconciliazione</div>
                <button class="btn btn-secondary" onclick="clearReconcileLog()">üóëÔ∏è Pulisci</button>
            </div>
            <div id="reconcileLog" style="background:var(--bg-primary);border-radius:8px;padding:16px;max-height:400px;overflow-y:auto;font-family:'SF Mono',Monaco,monospace;font-size:12px;line-height:1.8;">
                <div style="color:var(--text-secondary);">[System] Reconciliation Engine v2.0 pronto</div>
            </div>
        </div>
    </div>
    </div>
    
    <!-- Hidden elements per evitare errori JS -->
    <div style="display:none;">
        <input id="binanceApiKey"><input id="binanceSecretKey">
        <span id="binanceServerStatus"></span><span id="binanceSyncStatus"></span>
        <span id="binanceSpotTotal"></span><span id="binanceEarnTotal"></span>
        <span id="binanceStakingTotal"></span><span id="binanceTotalValue"></span>
        <span id="binanceLastUpdate"></span><div id="binanceBalances"></div>
        <div id="binanceTokensList"></div>
    </div>

    <script>
        // ==================== CONFIG ====================
        let EUR_USD = 0.849;
        let allocationChart = null;
        let lastScanResults = [];
        let walletResults = {}; // { walletAddress: { name: 'Main', results: [...], scannedAt: timestamp } }
        let walletTransactions = {}; // { walletAddress: { nativeTx: [], tokenTx: [], lastDownload: timestamp } }
        
        const CHAINS = {
            eth: { id: 1, name: 'Ethereum', symbol: 'ETH', explorer: 'etherscan.io', color: '#627eea', dex: 'ethereum', api: 'etherscan' },
            bsc: { id: 56, name: 'BSC', symbol: 'BNB', explorer: 'bscscan.com', color: '#f3ba2f', dex: 'bsc', api: 'etherscan' },
            polygon: { id: 137, name: 'Polygon', symbol: 'MATIC', explorer: 'polygonscan.com', color: '#8247e5', dex: 'polygon', api: 'etherscan' },
            arbitrum: { id: 42161, name: 'Arbitrum', symbol: 'ETH', explorer: 'arbiscan.io', color: '#28a0f0', dex: 'arbitrum', api: 'etherscan' },
            optimism: { id: 10, name: 'Optimism', symbol: 'ETH', explorer: 'optimistic.etherscan.io', color: '#ff0420', dex: 'optimism', api: 'etherscan' },
            base: { id: 8453, name: 'Base', symbol: 'ETH', explorer: 'basescan.org', color: '#0052ff', dex: 'base', api: 'etherscan' },
            cronos: { id: 25, name: 'Cronos', symbol: 'CRO', explorer: 'cronoscan.com', color: '#002D74', dex: 'cronos', api: 'etherscan' },
            pulse: { id: 369, name: 'PulseChain', symbol: 'PLS', explorer: 'scan.pulsechain.com', color: '#00ff00', dex: 'pulsechain', api: 'pulsescan' },
            solana: { id: 0, name: 'Solana', symbol: 'SOL', explorer: 'solscan.io', color: '#9945ff', dex: 'solana', api: 'solana' },
        };
        
        const NATIVE_PRICES = { ETH: 0, BNB: 0, MATIC: 0, PLS: 0, SOL: 0, CRO: 0 };
        
        const TOKEN_ICONS = {
            'ETH': 'https://assets.coingecko.com/coins/images/279/small/ethereum.png',
            'BNB': 'https://assets.coingecko.com/coins/images/825/small/bnb-icon2_2x.png',
            'MATIC': 'https://assets.coingecko.com/coins/images/4713/small/matic-token-icon.png',
            'SHIB': 'https://assets.coingecko.com/coins/images/11939/small/shiba.png',
            'BONE': 'https://assets.coingecko.com/coins/images/16916/small/bone_icon.png',
            'USDT': 'https://assets.coingecko.com/coins/images/325/small/tether.png',
            'USDC': 'https://assets.coingecko.com/coins/images/6319/small/usdc.png',
            'PLS': 'https://tokens.app.pulsex.com/images/tokens/0xA1077a294dDE1B09bB078844df40758a5D0f9a27.png',
            'SOL': 'https://assets.coingecko.com/coins/images/4128/small/solana.png',
            'CRO': 'https://assets.coingecko.com/coins/images/7310/small/cro_token_logo.png',
            'HEX': 'https://tokens.app.pulsex.com/images/tokens/0x2b591e99afE9f32eAA6214f7B7629768c40Eeb39.png',
            'PLSX': 'https://tokens.app.pulsex.com/images/tokens/0x95B303987A60C71504D99Aa1b13B4DA07b0790ab.png',
            'INC': 'https://tokens.app.pulsex.com/images/tokens/0x2fa878Ab3F87CC1C9737Fc071108F904c0B0C95d.png',
            'DAI': 'https://assets.coingecko.com/coins/images/9956/small/dai-multi-collateral-mcd.png',
            'WETH': 'https://assets.coingecko.com/coins/images/2518/small/weth.png',
        };
        
        const HISTORICAL_PRICES = {
            // Top coins
            'ethereum': { 2020: 737, 2021: 3769, 2022: 1196, 2023: 2282, 2024: 3337, 2025: 2950, 2026: 3200 },
            'bitcoin': { 2020: 29000, 2021: 47700, 2022: 16500, 2023: 42300, 2024: 93400, 2025: 100000, 2026: 105000 },
            'binancecoin': { 2020: 37, 2021: 526, 2022: 244, 2023: 311, 2024: 707, 2025: 680, 2026: 700 },
            'solana': { 2020: 1.5, 2021: 170, 2022: 9.5, 2023: 100, 2024: 190, 2025: 150, 2026: 180 },
            'ripple': { 2020: 0.22, 2021: 0.83, 2022: 0.35, 2023: 0.62, 2024: 2.08, 2025: 2.30, 2026: 2.50 },
            'cardano': { 2020: 0.18, 2021: 1.35, 2022: 0.25, 2023: 0.59, 2024: 0.88, 2025: 0.90, 2026: 1.00 },
            'dogecoin': { 2020: 0.005, 2021: 0.17, 2022: 0.07, 2023: 0.09, 2024: 0.32, 2025: 0.35, 2026: 0.40 },
            'polkadot': { 2020: 9.5, 2021: 27.8, 2022: 4.3, 2023: 7.9, 2024: 6.9, 2025: 7.0, 2026: 8.0 },
            'chainlink': { 2020: 11.5, 2021: 19.3, 2022: 5.7, 2023: 15.1, 2024: 14.8, 2025: 15.0, 2026: 16.0 },
            'avalanche-2': { 2020: 3.5, 2021: 109, 2022: 11.3, 2023: 40.5, 2024: 38.6, 2025: 40.0, 2026: 45.0 },
            'matic-network': { 2020: 0.02, 2021: 2.47, 2022: 0.75, 2023: 0.99, 2024: 0.46, 2025: 0.35, 2026: 0.40 },
            // Meme coins
            'shiba-inu': { 2020: 0, 2021: 0.0000338, 2022: 0.0000081, 2023: 0.0000091, 2024: 0.0000218, 2025: 0.000018, 2026: 0.00002 },
            'pepe': { 2020: 0, 2021: 0, 2022: 0, 2023: 0.0000014, 2024: 0.000018, 2025: 0.000015, 2026: 0.000018 },
            'bone-shibaswap': { 2020: 0, 2021: 1.71, 2022: 0.93, 2023: 0.47, 2024: 0.42, 2025: 0.08, 2026: 0.10 },
            // Layer 1
            'tron': { 2020: 0.027, 2021: 0.077, 2022: 0.054, 2023: 0.106, 2024: 0.26, 2025: 0.25, 2026: 0.28 },
            'the-open-network': { 2020: 0, 2021: 4.5, 2022: 1.8, 2023: 2.3, 2024: 5.8, 2025: 5.5, 2026: 6.0 },
            'algorand': { 2020: 0.35, 2021: 1.38, 2022: 0.17, 2023: 0.22, 2024: 0.34, 2025: 0.30, 2026: 0.35 },
            'eos': { 2020: 2.6, 2021: 2.8, 2022: 0.83, 2023: 0.84, 2024: 0.78, 2025: 0.70, 2026: 0.80 },
            'stellar': { 2020: 0.13, 2021: 0.27, 2022: 0.074, 2023: 0.13, 2024: 0.41, 2025: 0.40, 2026: 0.45 },
            'vechain': { 2020: 0.02, 2021: 0.085, 2022: 0.016, 2023: 0.027, 2024: 0.046, 2025: 0.04, 2026: 0.05 },
            'neo': { 2020: 14.5, 2021: 30.2, 2022: 6.5, 2023: 12.8, 2024: 14.2, 2025: 13.0, 2026: 15.0 },
            'cosmos': { 2020: 5.0, 2021: 44, 2022: 9.3, 2023: 10.5, 2024: 6.7, 2025: 7.0, 2026: 8.0 },
            // DeFi
            'uniswap': { 2020: 3.5, 2021: 17.5, 2022: 5.2, 2023: 6.3, 2024: 13.5, 2025: 14.0, 2026: 15.0 },
            'aave': { 2020: 89, 2021: 264, 2022: 51, 2023: 99, 2024: 330, 2025: 350, 2026: 370 },
            'pancakeswap-token': { 2020: 0, 2021: 12.7, 2022: 3.7, 2023: 2.4, 2024: 2.1, 2025: 2.0, 2026: 2.5 },
            '1inch': { 2020: 0, 2021: 2.9, 2022: 0.47, 2023: 0.42, 2024: 0.52, 2025: 0.50, 2026: 0.55 },
            // Terra/Luna
            'terra-luna': { 2020: 0.64, 2021: 93, 2022: 0.00017, 2023: 0.00012, 2024: 0.00012, 2025: 0.00004, 2026: 0.00004 },
            'terra-luna-2': { 2020: 0, 2021: 0, 2022: 2.5, 2023: 0.8, 2024: 0.45, 2025: 0.40, 2026: 0.45 },
            // Telegram/TON ecosystem
            'notcoin': { 2020: 0, 2021: 0, 2022: 0, 2023: 0, 2024: 0.008, 2025: 0.0005, 2026: 0.0005 },
            'dogs-2': { 2020: 0, 2021: 0, 2022: 0, 2023: 0, 2024: 0.0005, 2025: 0.00002, 2026: 0.00002 },
            'hamster-kombat': { 2020: 0, 2021: 0, 2022: 0, 2023: 0, 2024: 0.003, 2025: 0.002, 2026: 0.002 },
            'catizen': { 2020: 0, 2021: 0, 2022: 0, 2023: 0, 2024: 0.4, 2025: 0.3, 2026: 0.35 },
            // Exchange tokens
            'crypto-com-chain': { 2020: 0.06, 2021: 0.60, 2022: 0.057, 2023: 0.073, 2024: 0.12, 2025: 0.10, 2026: 0.12 },
            // Other
            'litecoin': { 2020: 125, 2021: 148, 2022: 70, 2023: 73, 2024: 103, 2025: 100, 2026: 110 },
            'osmosis': { 2020: 0, 2021: 10.5, 2022: 0.8, 2023: 0.5, 2024: 0.4, 2025: 0.35, 2026: 0.40 },
            'kusama': { 2020: 60, 2021: 368, 2022: 23, 2023: 33, 2024: 25, 2025: 22, 2026: 25 },
            'qtum': { 2020: 2.7, 2021: 13.1, 2022: 2.1, 2023: 3.2, 2024: 3.0, 2025: 2.8, 2026: 3.0 },
            'apecoin': { 2020: 0, 2021: 0, 2022: 3.5, 2023: 1.4, 2024: 1.2, 2025: 1.0, 2026: 1.2 },
            // PulseChain
            'pulsechain': { 2020: 0, 2021: 0, 2022: 0, 2023: 0.00005, 2024: 0.00003, 2025: 0.000014, 2026: 0.00002 },
            'hex': { 2020: 0.001, 2021: 0.15, 2022: 0.04, 2023: 0.006, 2024: 0.004, 2025: 0.003, 2026: 0.004 },
            'pulsex': { 2020: 0, 2021: 0, 2022: 0, 2023: 0.0001, 2024: 0.00005, 2025: 0.00001, 2026: 0.00002 },
            // Stablecoins
            'tether': { 2020: 1, 2021: 1, 2022: 1, 2023: 1, 2024: 1, 2025: 1, 2026: 1 },
            'usd-coin': { 2020: 1, 2021: 1, 2022: 1, 2023: 1, 2024: 1, 2025: 1, 2026: 1 },
            'dai': { 2020: 1, 2021: 1, 2022: 1, 2023: 1, 2024: 1, 2025: 1, 2026: 1 },
        };
        const YEAR_END_PRICES = HISTORICAL_PRICES; // Alias
        
        // ==================== CRYPTOCOMPARE PRICE API ====================
        
        // Timestamp 31/12 per ogni anno (23:59:59 UTC)
        const YEAR_END_TIMESTAMPS = {
            2020: 1609459199,
            2021: 1640995199,
            2022: 1672531199,
            2023: 1704067199,
            2024: 1735689599,
            2025: 1767225599,
            2026: 1798761599
        };
        
        // Cache prezzi CryptoCompare
        let cryptoComparePriceCache = JSON.parse(localStorage.getItem('cryptofolio_cc_prices') || '{}');
        
        function saveCryptoCompareCache() {
            localStorage.setItem('cryptofolio_cc_prices', JSON.stringify(cryptoComparePriceCache));
        }
        
        // Fetch prezzo storico da CryptoCompare
        async function fetchCryptoComparePrice(symbol, year) {
            const symUpper = symbol.toUpperCase();
            const cacheKey = `${symUpper}_${year}`;
            
            // Check cache (valida per sempre - prezzi storici non cambiano)
            if (cryptoComparePriceCache[cacheKey]) {
                return cryptoComparePriceCache[cacheKey];
            }
            
            const timestamp = YEAR_END_TIMESTAMPS[year];
            if (!timestamp) return null;
            
            try {
                const url = `https://min-api.cryptocompare.com/data/pricehistorical?fsym=${symUpper}&tsyms=EUR&ts=${timestamp}`;
                console.log(`üîç CryptoCompare: ${symUpper} @ 31/12/${year}...`);
                
                const response = await fetch(url);
                if (!response.ok) return null;
                
                const data = await response.json();
                
                if (data[symUpper] && data[symUpper].EUR) {
                    const price = data[symUpper].EUR;
                    cryptoComparePriceCache[cacheKey] = price;
                    saveCryptoCompareCache();
                    console.log(`  ‚úÖ ${symUpper} @ 31/12/${year}: ‚Ç¨${price}`);
                    return price;
                }
            } catch (err) {
                console.warn(`CryptoCompare error for ${symUpper}:`, err.message);
            }
            
            return null;
        }
        
        // Fetch prezzo attuale
        async function fetchCryptoCompareCurrentPrice(symbol) {
            const symUpper = symbol.toUpperCase();
            
            try {
                const url = `https://min-api.cryptocompare.com/data/price?fsym=${symUpper}&tsyms=EUR`;
                const response = await fetch(url);
                if (!response.ok) return null;
                
                const data = await response.json();
                if (data.EUR) {
                    return data.EUR;
                }
            } catch (err) {
                console.warn(`CryptoCompare current price error for ${symUpper}:`, err.message);
            }
            
            return null;
        }
        
        // Fetch prezzi multipli (batch)
        async function fetchCryptoComparePricesBatch(symbols, year) {
            const results = {};
            const uncached = [];
            
            // Check cache first
            for (const sym of symbols) {
                const symUpper = sym.toUpperCase();
                const cacheKey = `${symUpper}_${year}`;
                if (cryptoComparePriceCache[cacheKey]) {
                    results[symUpper] = cryptoComparePriceCache[cacheKey];
                } else {
                    uncached.push(symUpper);
                }
            }
            
            if (uncached.length === 0) return results;
            
            const timestamp = YEAR_END_TIMESTAMPS[year];
            if (!timestamp) return results;
            
            // Batch in gruppi di 50 (limite API)
            const batchSize = 50;
            for (let i = 0; i < uncached.length; i += batchSize) {
                const batch = uncached.slice(i, i + batchSize);
                const fsyms = batch.join(',');
                
                try {
                    const url = `https://min-api.cryptocompare.com/data/pricehistorical?fsym=${batch[0]}&tsyms=EUR&ts=${timestamp}`;
                    
                    // Per batch multipli, usa endpoint diverso
                    if (batch.length > 1) {
                        // Fetch one by one for historical (API limitation)
                        for (const sym of batch) {
                            const price = await fetchCryptoComparePrice(sym, year);
                            if (price) results[sym] = price;
                            // Rate limit: 50ms tra richieste
                            await new Promise(r => setTimeout(r, 50));
                        }
                    } else {
                        const price = await fetchCryptoComparePrice(batch[0], year);
                        if (price) results[batch[0]] = price;
                    }
                } catch (err) {
                    console.warn('Batch fetch error:', err);
                }
            }
            
            return results;
        }
        
        // Fetch prezzi attuali multipli (pi√π efficiente)
        async function fetchCryptoCompareCurrentPricesBatch(symbols) {
            const results = {};
            
            // Batch in gruppi di 50
            const batchSize = 50;
            for (let i = 0; i < symbols.length; i += batchSize) {
                const batch = symbols.slice(i, i + batchSize);
                const fsyms = batch.map(s => s.toUpperCase()).join(',');
                
                try {
                    const url = `https://min-api.cryptocompare.com/data/pricemulti?fsyms=${fsyms}&tsyms=EUR`;
                    console.log(`üîç CryptoCompare batch: ${batch.length} tokens...`);
                    
                    const response = await fetch(url);
                    if (!response.ok) continue;
                    
                    const data = await response.json();
                    
                    for (const [sym, prices] of Object.entries(data)) {
                        if (prices.EUR) {
                            results[sym] = prices.EUR;
                        }
                    }
                    
                    // Rate limit
                    if (i + batchSize < symbols.length) {
                        await new Promise(r => setTimeout(r, 200));
                    }
                } catch (err) {
                    console.warn('Batch current price error:', err);
                }
            }
            
            console.log(`‚úÖ CryptoCompare: ${Object.keys(results).length} prezzi ottenuti`);
            return results;
        }
        
        // ==================== END CRYPTOCOMPARE API ====================
        
        // ==================== SISTEMA PREZZI UNIFICATO ====================
        
        // Funzione UNICA per ottenere prezzo EUR
        // Priorit√†: 1. CryptoCompare (data) ‚Üí 2. CryptoCompare (anno) ‚Üí 3. CoinGecko ‚Üí 4. Stablecoin
        function getPriceEur(coin, dateOrYear) {
            const coinUpper = (coin || '').toUpperCase();
            if (!coinUpper) return 0;
            
            // Stablecoins - prezzo fisso
            const STABLECOINS = ['USDT', 'USDC', 'BUSD', 'DAI', 'TUSD', 'FDUSD', 'UST', 'USTC'];
            if (STABLECOINS.includes(coinUpper)) return EUR_USD;
            if (coinUpper === 'EUR') return 1;
            if (coinUpper === 'USD') return EUR_USD;
            
            // Skip token Earn (LD*)
            if (coinUpper.startsWith('LD')) return 0;
            
            let year, dateKey;
            
            if (typeof dateOrYear === 'number') {
                // √à un anno
                year = dateOrYear;
                dateKey = `${year}-12-31`;
            } else if (dateOrYear instanceof Date) {
                // √à una data
                year = dateOrYear.getFullYear();
                dateKey = dateOrYear.toISOString().slice(0, 10);
            } else if (typeof dateOrYear === 'string') {
                // Potrebbe essere ISO date o anno
                if (dateOrYear.length === 4) {
                    year = parseInt(dateOrYear);
                    dateKey = `${year}-12-31`;
                } else {
                    const d = new Date(dateOrYear);
                    year = d.getFullYear();
                    dateKey = d.toISOString().slice(0, 10);
                }
            } else {
                year = new Date().getFullYear();
                dateKey = new Date().toISOString().slice(0, 10);
            }
            
            // 1. CryptoCompare cache con data specifica
            const ccKeyDate = `${coinUpper}_${dateKey}`;
            if (cryptoComparePriceCache[ccKeyDate] && cryptoComparePriceCache[ccKeyDate] > 0) {
                return cryptoComparePriceCache[ccKeyDate];
            }
            
            // 2. CryptoCompare cache con anno (31/12)
            const ccKeyYear = `${coinUpper}_${year}`;
            if (cryptoComparePriceCache[ccKeyYear] && cryptoComparePriceCache[ccKeyYear] > 0) {
                return cryptoComparePriceCache[ccKeyYear];
            }
            
            // 3. CoinGecko hardcoded (fallback)
            const cgPrice = getHistoricalPrice(coinUpper, year);
            if (cgPrice && cgPrice > 0) {
                return cgPrice * EUR_USD; // CoinGecko √® in USD
            }
            
            // 4. CoinGecko real-time cache (per anno corrente)
            const currentYear = new Date().getFullYear();
            if (year >= currentYear - 1) {
                const cachedPrice = getCachedPrice ? getCachedPrice(coinUpper) : null;
                if (cachedPrice && cachedPrice > 0) {
                    return cachedPrice; // Gi√† in EUR
                }
            }
            
            return 0;
        }
        
        // Versione async che fetcha da CryptoCompare se non in cache
        async function getPriceEurAsync(coin, dateOrYear) {
            // Prima prova cache
            let price = getPriceEur(coin, dateOrYear);
            if (price > 0) return price;
            
            const coinUpper = (coin || '').toUpperCase();
            if (!coinUpper) return 0;
            
            // Fetch da CryptoCompare
            let year;
            if (typeof dateOrYear === 'number') {
                year = dateOrYear;
                price = await fetchCryptoComparePrice(coinUpper, year);
            } else if (dateOrYear instanceof Date || typeof dateOrYear === 'string') {
                const d = dateOrYear instanceof Date ? dateOrYear : new Date(dateOrYear);
                price = await fetchCryptoComparePriceForDate(coinUpper, d);
            }
            
            return price || 0;
        }
        
        // ==================== END SISTEMA PREZZI UNIFICATO ====================
        
        // ==================== SISTEMA TRANSAZIONI ARRICCHITE ====================
        
        // Struttura transazione "perfetta" per fisco italiano
        function createEnrichedTransaction(data) {
            const tx = {
                // Identificazione
                id: data.id || `TX_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`,
                timestamp: data.timestamp instanceof Date ? data.timestamp : new Date(data.timestamp || data.date),
                
                // Tipo operazione
                type: data.type || 'unknown', // buy, sell, transfer, swap, reward, staking, fee, deposit, withdrawal
                
                // Asset movimentati (per swap: BTC ‚Üí ETH)
                asset_in: data.asset_in || data.coin || null,   // Cosa ricevo
                asset_out: data.asset_out || null,              // Cosa do (EUR per buy, crypto per swap)
                amount_in: Math.abs(data.amount_in || data.amount || 0),
                amount_out: Math.abs(data.amount_out || 0),
                
                // Prezzi e valori
                price_eur: data.price_eur || 0,          // Prezzo unitario asset_in in EUR
                value_eur: data.value_eur || 0,          // Valore totale operazione in EUR
                fee_eur: data.fee_eur || 0,              // Commissione in EUR
                fee_asset: data.fee_asset || null,       // Asset usato per fee (BNB, EUR, etc)
                fee_amount: data.fee_amount || 0,        // Quantit√† fee
                
                // Cost Basis (prezzo di carico)
                cost_basis_eur: data.cost_basis_eur || 0, // Per acquisti: (amount √ó price) + fee
                
                // Riconciliazione
                tx_hash: data.tx_hash || null,           // Hash blockchain
                order_id: data.order_id || null,         // ID ordine exchange
                is_internal: data.is_internal || false,  // Transfer tra miei wallet
                linked_tx_id: data.linked_tx_id || null, // ID transazione collegata (transfer matching)
                is_taxable: data.is_taxable !== false,   // Default true, false per transfer interni
                
                // Metadati
                source: data.source || 'manual',         // binance, bitpanda, bitget, wallet, manual
                exchange: data.exchange || data.source || null,
                wallet: data.wallet || null,
                notes: data.notes || '',
                
                // Legacy compatibility
                coin: data.asset_in || data.coin || null,
                amount: data.amount_in || data.amount || 0,
                change: data.change || (data.type === 'sell' || data.type === 'withdrawal' ? -Math.abs(data.amount_in || data.amount || 0) : Math.abs(data.amount_in || data.amount || 0)),
                date: data.timestamp instanceof Date ? data.timestamp : new Date(data.timestamp || data.date),
                amountEur: data.value_eur || data.amountEur || 0
            };
            
            // Auto-calcola campi mancanti
            if (!tx.price_eur && tx.asset_in && tx.timestamp) {
                tx.price_eur = getPriceEur(tx.asset_in, tx.timestamp);
            }
            
            if (!tx.value_eur && tx.price_eur > 0 && tx.amount_in > 0) {
                tx.value_eur = tx.amount_in * tx.price_eur;
                tx.amountEur = tx.value_eur;
            }
            
            // Cost basis per acquisti
            if ((tx.type === 'buy' || tx.type === 'deposit') && tx.value_eur > 0) {
                tx.cost_basis_eur = tx.value_eur + tx.fee_eur;
            }
            
            // Determina se tassabile
            if (tx.type === 'transfer' || tx.is_internal) {
                tx.is_taxable = false;
            }
            
            return tx;
        }
        
        // Arricchisce array di transazioni esistenti
        function enrichTransactions(transactions, source) {
            if (!transactions || !Array.isArray(transactions)) return [];
            
            return transactions.map(tx => {
                // Se gi√† arricchita, ritorna come √®
                if (tx.id && tx.asset_in !== undefined && tx.cost_basis_eur !== undefined) {
                    return tx;
                }
                
                // Arricchisci
                return createEnrichedTransaction({
                    ...tx,
                    source: source || tx.source || 'unknown'
                });
            });
        }
        
        // Calcola cost basis automatico per una transazione
        async function calculateTransactionCostBasis(tx) {
            if (!tx.asset_in || tx.amount_in <= 0) return tx;
            
            // Fetch prezzo se non presente
            if (!tx.price_eur || tx.price_eur <= 0) {
                tx.price_eur = await getPriceEurAsync(tx.asset_in, tx.timestamp);
            }
            
            // Calcola valore
            if (tx.price_eur > 0) {
                tx.value_eur = tx.amount_in * tx.price_eur;
                tx.amountEur = tx.value_eur;
            }
            
            // Cost basis = valore + fee (per acquisti)
            if (tx.type === 'buy' || tx.type === 'deposit') {
                tx.cost_basis_eur = tx.value_eur + (tx.fee_eur || 0);
            }
            
            return tx;
        }
        
        // Batch enrich con fetch prezzi da CryptoCompare
        async function enrichTransactionsWithPrices(transactions, progressCallback) {
            const total = transactions.length;
            let processed = 0;
            
            // Raggruppa per coin+data per minimizzare API calls
            const priceRequests = new Map();
            
            for (const tx of transactions) {
                if (!tx.asset_in || tx.asset_in === 'EUR' || tx.asset_in === 'USD') continue;
                if (tx.price_eur && tx.price_eur > 0) continue;
                
                const date = tx.timestamp instanceof Date ? tx.timestamp : new Date(tx.timestamp);
                const dateKey = date.toISOString().slice(0, 10);
                const key = `${tx.asset_in.toUpperCase()}_${dateKey}`;
                
                if (!priceRequests.has(key)) {
                    priceRequests.set(key, { coin: tx.asset_in, date, dateKey });
                }
            }
            
            console.log(`üìä Fetching ${priceRequests.size} prezzi unici per ${total} transazioni...`);
            
            // Fetch prezzi mancanti
            let fetched = 0;
            for (const [key, info] of priceRequests) {
                // Skip se gi√† in cache
                if (cryptoComparePriceCache[key]) continue;
                
                const price = await fetchCryptoComparePriceForDate(info.coin, info.date);
                fetched++;
                
                if (progressCallback) {
                    progressCallback(fetched, priceRequests.size);
                }
                
                // Rate limit
                await new Promise(r => setTimeout(r, 60));
            }
            
            // Applica prezzi alle transazioni
            for (const tx of transactions) {
                if (!tx.asset_in || tx.price_eur > 0) continue;
                
                const date = tx.timestamp instanceof Date ? tx.timestamp : new Date(tx.timestamp);
                tx.price_eur = getPriceEur(tx.asset_in, date);
                
                if (tx.price_eur > 0 && tx.amount_in > 0) {
                    tx.value_eur = tx.amount_in * tx.price_eur;
                    tx.amountEur = tx.value_eur;
                    
                    if (tx.type === 'buy' || tx.type === 'deposit') {
                        tx.cost_basis_eur = tx.value_eur + (tx.fee_eur || 0);
                    }
                }
                
                processed++;
            }
            
            console.log(`‚úÖ Arricchite ${processed} transazioni con prezzi`);
            return transactions;
        }
        
        // Deduplicazione transazioni per TxHash o OrderID
        function deduplicateTransactions(transactions) {
            const seen = new Map();
            const duplicates = [];
            const unique = [];
            
            for (const tx of transactions) {
                // Chiave univoca: tx_hash > order_id > timestamp+coin+amount
                let key;
                if (tx.tx_hash) {
                    key = `hash_${tx.tx_hash}`;
                } else if (tx.order_id) {
                    key = `order_${tx.order_id}`;
                } else {
                    const ts = tx.timestamp instanceof Date ? tx.timestamp.getTime() : new Date(tx.timestamp).getTime();
                    key = `${ts}_${tx.asset_in || tx.coin}_${tx.amount_in || tx.amount}`;
                }
                
                if (seen.has(key)) {
                    duplicates.push(tx);
                    console.log(`‚ö†Ô∏è Duplicato trovato: ${key}`);
                } else {
                    seen.set(key, tx);
                    unique.push(tx);
                }
            }
            
            if (duplicates.length > 0) {
                console.log(`üîç Rimossi ${duplicates.length} duplicati su ${transactions.length} transazioni`);
            }
            
            return { unique, duplicates };
        }
        
        // Transfer Matching migliorato
        function matchInternalTransfers(transactions, windowMinutes = 30) {
            const windowMs = windowMinutes * 60 * 1000;
            const withdrawals = transactions.filter(tx => tx.type === 'withdrawal');
            const deposits = transactions.filter(tx => tx.type === 'deposit');
            
            let matched = 0;
            
            for (const withdrawal of withdrawals) {
                if (withdrawal.linked_tx_id) continue; // Gi√† matchato
                
                const wTime = withdrawal.timestamp instanceof Date ? withdrawal.timestamp.getTime() : new Date(withdrawal.timestamp).getTime();
                const wCoin = (withdrawal.asset_in || withdrawal.coin || '').toUpperCase();
                const wAmount = Math.abs(withdrawal.amount_in || withdrawal.amount || 0);
                
                // Cerca deposit corrispondente
                for (const deposit of deposits) {
                    if (deposit.linked_tx_id) continue;
                    
                    const dTime = deposit.timestamp instanceof Date ? deposit.timestamp.getTime() : new Date(deposit.timestamp).getTime();
                    const dCoin = (deposit.asset_in || deposit.coin || '').toUpperCase();
                    const dAmount = Math.abs(deposit.amount_in || deposit.amount || 0);
                    
                    // Match: stesso coin, quantit√† simile (¬±5%), tempo entro finestra
                    const timeDiff = Math.abs(dTime - wTime);
                    const amountDiff = Math.abs(wAmount - dAmount) / Math.max(wAmount, dAmount);
                    
                    if (wCoin === dCoin && 
                        timeDiff <= windowMs && 
                        amountDiff <= 0.05 && // Tolleranza 5% per fee di rete
                        deposit.source !== withdrawal.source) { // Diversi exchange/wallet
                        
                        // Match trovato!
                        withdrawal.linked_tx_id = deposit.id;
                        withdrawal.is_internal = true;
                        withdrawal.is_taxable = false;
                        withdrawal.type = 'transfer';
                        
                        deposit.linked_tx_id = withdrawal.id;
                        deposit.is_internal = true;
                        deposit.is_taxable = false;
                        deposit.type = 'transfer';
                        
                        // Il deposit eredita il cost basis del withdrawal
                        deposit.cost_basis_eur = withdrawal.cost_basis_eur || deposit.cost_basis_eur;
                        
                        matched++;
                        console.log(`üîó Transfer match: ${wCoin} ${wAmount.toFixed(4)} (${withdrawal.source} ‚Üí ${deposit.source})`);
                        break;
                    }
                }
            }
            
            console.log(`‚úÖ Matched ${matched} trasferimenti interni`);
            return transactions;
        }
        
        // Zero-Sum Check: verifica coerenza saldi
        function zeroSumCheck(transactions, realBalances) {
            const calculated = {};
            const issues = [];
            
            // Calcola saldi dalle transazioni
            for (const tx of transactions) {
                const coin = (tx.asset_in || tx.coin || '').toUpperCase();
                if (!coin || coin === 'EUR' || coin === 'USD') continue;
                
                if (!calculated[coin]) calculated[coin] = 0;
                calculated[coin] += tx.change || 0;
                
                if (Math.abs(calculated[coin]) < 0.00000001) {
                    calculated[coin] = 0;
                }
            }
            
            // Confronta con saldi reali
            if (realBalances) {
                for (const [coin, realAmount] of Object.entries(realBalances)) {
                    if (coin.startsWith('LD')) continue; // Skip Earn tokens
                    
                    const calcAmount = calculated[coin] || 0;
                    const diff = Math.abs(realAmount - calcAmount);
                    const diffPercent = realAmount > 0 ? (diff / realAmount) * 100 : 0;
                    
                    if (diffPercent > 1 && diff > 0.001) { // >1% differenza
                        issues.push({
                            coin,
                            calculated: calcAmount,
                            real: realAmount,
                            difference: realAmount - calcAmount,
                            percentDiff: diffPercent
                        });
                    }
                }
                
                // Check coin mancanti
                for (const coin of Object.keys(calculated)) {
                    if (calculated[coin] > 0.001 && !realBalances[coin]) {
                        issues.push({
                            coin,
                            calculated: calculated[coin],
                            real: 0,
                            difference: -calculated[coin],
                            percentDiff: 100,
                            note: 'Transazione mancante? Coin calcolato ma non presente nei saldi reali'
                        });
                    }
                }
            }
            
            if (issues.length > 0) {
                console.warn('‚ö†Ô∏è Zero-Sum Check - Discrepanze trovate:');
                for (const issue of issues) {
                    console.warn(`  ${issue.coin}: calcolato=${issue.calculated.toFixed(6)}, reale=${issue.real.toFixed(6)}, diff=${issue.difference.toFixed(6)} (${issue.percentDiff.toFixed(1)}%)`);
                }
            } else {
                console.log('‚úÖ Zero-Sum Check: tutti i saldi corrispondono');
            }
            
            return { calculated, issues, isValid: issues.length === 0 };
        }
        
        // ==================== END SISTEMA TRANSAZIONI ARRICCHITE ====================
        
        // ==================== GESTIONE DISCREPANZE ====================
        
        // Salva ultima verifica discrepanze
        let lastDiscrepancyCheck = null;
        
        // Mostra report discrepanze
        function showDiscrepancyReport(exchangeId) {
            const exchData = exchangeData[exchangeId];
            if (!exchData) {
                alert('Nessun dato per questo exchange');
                return;
            }
            
            const transactions = exchData.transactions || [];
            const realBalances = exchData.realBalances || {};
            
            if (Object.keys(realBalances).length === 0) {
                alert('‚ö†Ô∏è Nessun saldo reale disponibile.\n\nI saldi reali sono necessari per verificare le discrepanze.\n\nProva a re-importare via API.');
                return;
            }
            
            const check = zeroSumCheck(transactions, realBalances);
            lastDiscrepancyCheck = { exchangeId, check, timestamp: new Date() };
            
            if (check.isValid) {
                alert('‚úÖ Nessuna discrepanza!\n\nTutti i saldi calcolati corrispondono ai saldi reali.');
                return;
            }
            
            let report = `üîç REPORT DISCREPANZE - ${exchangeId.toUpperCase()}\n`;
            report += `${'‚ïê'.repeat(40)}\n\n`;
            
            for (const issue of check.issues) {
                const diff = issue.difference;
                const diffSign = diff > 0 ? '+' : '';
                const priceEur = getPriceEur(issue.coin, new Date().getFullYear());
                const diffValueEur = Math.abs(diff) * priceEur;
                
                report += `‚ùå ${issue.coin}\n`;
                report += `   Calcolato: ${issue.calculated.toFixed(6)}\n`;
                report += `   Reale:     ${issue.real.toFixed(6)}\n`;
                report += `   Differenza: ${diffSign}${diff.toFixed(6)}`;
                if (diffValueEur > 0.01) {
                    report += ` (~‚Ç¨${diffValueEur.toFixed(2)})`;
                }
                report += `\n`;
                
                if (issue.note) {
                    report += `   üìù ${issue.note}\n`;
                }
                
                // Suggerimento
                if (diff > 0) {
                    report += `   üí° Manca: deposito/acquisto/reward\n`;
                } else {
                    report += `   üí° Manca: prelievo/vendita/fee\n`;
                }
                report += `\n`;
            }
            
            report += `${'‚îÄ'.repeat(40)}\n`;
            report += `Totale discrepanze: ${check.issues.length}\n\n`;
            report += `üí° Per risolvere:\n`;
            report += `1. Verifica su ${exchangeId} se mancano operazioni\n`;
            report += `2. Controlla Earn/Staking rewards\n`;
            report += `3. Usa "Aggiungi TX Manuale" per compensare`;
            
            alert(report);
        }
        
        // Aggiungi transazione manuale per risolvere discrepanza
        function addManualTransaction(exchangeId, data) {
            const exchData = exchangeData[exchangeId];
            if (!exchData) {
                console.error('Exchange non trovato:', exchangeId);
                return null;
            }
            
            if (!exchData.transactions) {
                exchData.transactions = [];
            }
            
            // Crea transazione arricchita
            const tx = createEnrichedTransaction({
                timestamp: data.date || new Date(),
                type: data.type || 'deposit',
                asset_in: data.coin,
                amount_in: Math.abs(data.amount),
                price_eur: data.priceEur || getPriceEur(data.coin, data.date || new Date()),
                fee_eur: data.feeEur || 0,
                source: exchangeId,
                exchange: exchangeId,
                notes: data.notes || 'Transazione manuale - aggiustamento',
                change: data.amount // Positivo per deposito, negativo per prelievo
            });
            
            // Aggiungi alla lista
            exchData.transactions.push(tx);
            
            // Riordina per data
            exchData.transactions.sort((a, b) => {
                const dateA = a.timestamp || a.date;
                const dateB = b.timestamp || b.date;
                return new Date(dateA) - new Date(dateB);
            });
            
            // Ricalcola saldi
            recalculateExchangeBalances(exchangeId);
            
            // Salva
            saveExchangeDataToFirebase();
            
            console.log(`‚úÖ Transazione manuale aggiunta: ${tx.type} ${tx.amount_in} ${tx.asset_in}`);
            return tx;
        }
        
        // Ricalcola saldi da transazioni
        function recalculateExchangeBalances(exchangeId) {
            const exchData = exchangeData[exchangeId];
            if (!exchData || !exchData.transactions) return;
            
            const balances = {};
            const yearEndSnapshots = {};
            const years = [2021, 2022, 2023, 2024, 2025, 2026];
            let yearIndex = 0;
            
            // Ordina transazioni
            const sortedTx = [...exchData.transactions].sort((a, b) => {
                const dateA = a.timestamp || a.date;
                const dateB = b.timestamp || b.date;
                return new Date(dateA) - new Date(dateB);
            });
            
            for (const tx of sortedTx) {
                const coin = tx.asset_in || tx.coin;
                if (!coin) continue;
                
                if (!balances[coin]) balances[coin] = 0;
                balances[coin] += tx.change || 0;
                if (Math.abs(balances[coin]) < 0.00000001) balances[coin] = 0;
                
                const txDate = tx.timestamp || tx.date;
                const txDateTime = txDate instanceof Date ? txDate : new Date(txDate);
                
                while (yearIndex < years.length && txDateTime > new Date(years[yearIndex], 11, 31, 23, 59, 59)) {
                    yearEndSnapshots[years[yearIndex]] = { ...balances };
                    yearIndex++;
                }
            }
            
            // Completa anni rimanenti
            for (let i = yearIndex; i < years.length; i++) {
                yearEndSnapshots[years[i]] = { ...balances };
            }
            
            // Usa saldi reali per 2025/2026 se disponibili
            if (exchData.realBalances && Object.keys(exchData.realBalances).length > 0) {
                yearEndSnapshots[2025] = { ...exchData.realBalances };
                yearEndSnapshots[2026] = { ...exchData.realBalances };
            }
            
            // Ricalcola totali EUR
            const yearTotals = {};
            for (const year of years) {
                let totalEur = 0;
                const snapshot = yearEndSnapshots[year] || {};
                for (const [coin, amount] of Object.entries(snapshot)) {
                    if (!amount || amount <= 0 || coin.startsWith('LD')) continue;
                    const priceEur = getPriceEur(coin, year);
                    if (priceEur && !isNaN(priceEur)) {
                        totalEur += amount * priceEur;
                    }
                }
                yearTotals[year] = Math.round(totalEur * 100) / 100;
            }
            
            // Aggiorna
            exchData.balances = yearEndSnapshots;
            exchData.totals = yearTotals;
            exchData.transactionCount = sortedTx.length;
            
            // Refresh UI
            initExchangeGrid();
            updateExchangeTotals();
        }
        
        // Risolvi discrepanza automaticamente
        function resolveDiscrepancy(exchangeId, coin, difference) {
            const type = difference > 0 ? 'deposit' : 'withdrawal';
            const amount = difference; // Positivo per deposit, negativo per withdrawal
            
            const confirmed = confirm(
                `üîß Risolvere discrepanza ${coin}?\n\n` +
                `Verr√† aggiunta una transazione:\n` +
                `‚Ä¢ Tipo: ${type === 'deposit' ? 'üì• Deposito' : 'üì§ Prelievo'}\n` +
                `‚Ä¢ Coin: ${coin}\n` +
                `‚Ä¢ Quantit√†: ${Math.abs(difference).toFixed(6)}\n` +
                `‚Ä¢ Data: oggi\n` +
                `‚Ä¢ Note: "Aggiustamento automatico"\n\n` +
                `Continuare?`
            );
            
            if (!confirmed) return;
            
            addManualTransaction(exchangeId, {
                date: new Date(),
                type: type,
                coin: coin,
                amount: amount,
                notes: `Aggiustamento automatico - discrepanza ${Math.abs(difference).toFixed(6)} ${coin}`
            });
            
            alert(`‚úÖ Discrepanza ${coin} risolta!\n\nTransazione aggiunta.`);
            
            // Ri-verifica
            showDiscrepancyReport(exchangeId);
        }
        
        // UI per aggiungere transazione manuale
        function showAddManualTxModal(exchangeId) {
            const coin = prompt('Coin (es. BTC, ETH, NOT):');
            if (!coin) return;
            
            const amountStr = prompt(`Quantit√† ${coin.toUpperCase()}:\n(positivo = deposito, negativo = prelievo)`);
            if (!amountStr) return;
            const amount = parseFloat(amountStr);
            if (isNaN(amount) || amount === 0) {
                alert('Quantit√† non valida');
                return;
            }
            
            const type = amount > 0 ? 'deposit' : 'withdrawal';
            const dateStr = prompt('Data (YYYY-MM-DD) o lascia vuoto per oggi:');
            const date = dateStr ? new Date(dateStr) : new Date();
            
            const notes = prompt('Note (opzionale):') || '';
            
            // Conferma
            const priceEur = getPriceEur(coin.toUpperCase(), date);
            const valueEur = Math.abs(amount) * priceEur;
            
            const confirmed = confirm(
                `üìù Conferma transazione manuale:\n\n` +
                `‚Ä¢ Tipo: ${type === 'deposit' ? 'üì• Deposito' : 'üì§ Prelievo'}\n` +
                `‚Ä¢ Coin: ${coin.toUpperCase()}\n` +
                `‚Ä¢ Quantit√†: ${Math.abs(amount)}\n` +
                `‚Ä¢ Data: ${date.toLocaleDateString('it-IT')}\n` +
                `‚Ä¢ Valore: ~‚Ç¨${valueEur.toFixed(2)}\n` +
                `‚Ä¢ Note: ${notes || '(nessuna)'}\n\n` +
                `Aggiungere?`
            );
            
            if (!confirmed) return;
            
            addManualTransaction(exchangeId, {
                date,
                type,
                coin: coin.toUpperCase(),
                amount,
                notes
            });
            
            alert('‚úÖ Transazione aggiunta!');
            
            // Refresh dettaglio
            if (currentDetailExchange === exchangeId) {
                openExchangeDetail(exchangeId);
            }
        }
        
        // ==================== END GESTIONE DISCREPANZE ====================
        
        // ==================== UI DISCREPANZE ====================
        
        // Renderizza sezione discrepanze
        function renderDiscrepanciesSection(exchangeId) {
            const section = document.getElementById('exchDetailDiscrepancies');
            const countEl = document.getElementById('discrepancyCount');
            const listEl = document.getElementById('discrepancyList');
            
            if (!section || !listEl) return;
            
            const exchData = exchangeData[exchangeId];
            if (!exchData) {
                section.style.display = 'none';
                return;
            }
            
            // Usa discrepanze salvate o calcola nuove
            let issues = exchData.discrepancies || [];
            
            // Se non ci sono discrepanze salvate ma ci sono saldi reali, calcola
            if (issues.length === 0 && exchData.realBalances && Object.keys(exchData.realBalances).length > 0) {
                const check = zeroSumCheck(exchData.transactions || [], exchData.realBalances);
                issues = check.issues || [];
                // Salva per persistenza
                exchData.discrepancies = issues;
            }
            
            if (issues.length === 0) {
                section.style.display = 'none';
                return;
            }
            
            // Mostra sezione
            section.style.display = 'block';
            countEl.textContent = issues.length;
            
            // Renderizza lista
            let html = '<div style="display:grid;gap:12px;">';
            
            for (const issue of issues) {
                const diff = issue.difference;
                const diffSign = diff > 0 ? '+' : '';
                const priceEur = getPriceEur(issue.coin, new Date().getFullYear());
                const diffValueEur = Math.abs(diff) * priceEur;
                const isSignificant = diffValueEur > 1;
                
                const bgColor = isSignificant ? 'rgba(255,107,107,0.1)' : 'rgba(243,186,47,0.1)';
                const borderColor = isSignificant ? 'var(--red)' : 'var(--yellow)';
                
                html += `
                <div style="display:flex;align-items:center;justify-content:space-between;padding:12px;background:${bgColor};border-left:3px solid ${borderColor};border-radius:0 8px 8px 0;">
                    <div style="flex:1;">
                        <div style="display:flex;align-items:center;gap:8px;">
                            <span style="font-weight:700;font-size:16px;">${issue.coin}</span>
                            ${isSignificant ? '<span style="background:var(--red);color:#fff;padding:2px 6px;border-radius:4px;font-size:10px;">IMPORTANTE</span>' : ''}
                        </div>
                        <div style="display:flex;gap:16px;margin-top:6px;font-size:12px;color:var(--text-secondary);">
                            <span>Calcolato: <strong>${issue.calculated.toFixed(6)}</strong></span>
                            <span>Reale: <strong>${issue.real.toFixed(6)}</strong></span>
                        </div>
                        <div style="margin-top:4px;font-size:13px;">
                            Diff: <span style="color:${diff > 0 ? 'var(--green)' : 'var(--red)'};">${diffSign}${diff.toFixed(6)}</span>
                            ${diffValueEur > 0.01 ? `<span style="color:var(--text-secondary);"> (~‚Ç¨${diffValueEur.toFixed(2)})</span>` : ''}
                        </div>
                        <div style="margin-top:4px;font-size:11px;color:var(--text-secondary);">
                            üí° ${diff > 0 ? 'Manca: deposito, reward, airdrop' : 'Manca: prelievo, fee, vendita'}
                        </div>
                    </div>
                    <div style="display:flex;gap:8px;">
                        <button class="btn btn-secondary" onclick="resolveDiscrepancy('${exchangeId}', '${issue.coin}', ${diff})" 
                                style="padding:6px 12px;font-size:11px;" title="Aggiungi transazione per risolvere">
                            üîß Risolvi
                        </button>
                    </div>
                </div>`;
            }
            
            html += '</div>';
            listEl.innerHTML = html;
        }
        
        // Aggiorna discrepanze
        function refreshDiscrepancies() {
            if (!currentDetailExchange) return;
            
            const exchData = exchangeData[currentDetailExchange];
            if (!exchData || !exchData.realBalances) {
                alert('‚ö†Ô∏è Nessun saldo reale disponibile.\n\nRe-importa via API per ottenere i saldi reali.');
                return;
            }
            
            // Ricalcola
            const check = zeroSumCheck(exchData.transactions || [], exchData.realBalances);
            exchData.discrepancies = check.issues || [];
            
            // Salva
            saveExchangeDataToFirebase();
            
            // Refresh UI
            renderDiscrepanciesSection(currentDetailExchange);
            
            if (check.isValid) {
                alert('‚úÖ Nessuna discrepanza!\n\nTutti i saldi corrispondono.');
            }
        }
        
        // Risolvi tutte le discrepanze
        function resolveAllDiscrepancies() {
            if (!currentDetailExchange) return;
            
            const exchData = exchangeData[currentDetailExchange];
            const issues = exchData?.discrepancies || [];
            
            if (issues.length === 0) {
                alert('‚úÖ Nessuna discrepanza da risolvere!');
                return;
            }
            
            // Calcola valore totale
            let totalValueEur = 0;
            for (const issue of issues) {
                const priceEur = getPriceEur(issue.coin, new Date().getFullYear());
                totalValueEur += Math.abs(issue.difference) * priceEur;
            }
            
            const confirmed = confirm(
                `üîß Risolvere TUTTE le ${issues.length} discrepanze?\n\n` +
                `Verranno aggiunte ${issues.length} transazioni di aggiustamento.\n` +
                `Valore totale: ~‚Ç¨${totalValueEur.toFixed(2)}\n\n` +
                `‚ö†Ô∏è Queste transazioni saranno marcate come "Aggiustamento automatico".\n\n` +
                `Continuare?`
            );
            
            if (!confirmed) return;
            
            let resolved = 0;
            for (const issue of issues) {
                addManualTransaction(currentDetailExchange, {
                    date: new Date(),
                    type: issue.difference > 0 ? 'deposit' : 'withdrawal',
                    coin: issue.coin,
                    amount: issue.difference,
                    notes: `Aggiustamento automatico - discrepanza ${Math.abs(issue.difference).toFixed(6)} ${issue.coin}`
                });
                resolved++;
            }
            
            // Pulisci discrepanze
            exchData.discrepancies = [];
            saveExchangeDataToFirebase();
            
            // Refresh UI
            renderDiscrepanciesSection(currentDetailExchange);
            filterExchDetailTx();
            
            alert(`‚úÖ Risolte ${resolved} discrepanze!\n\nLe transazioni sono state aggiunte.`);
        }
        
        // ==================== END UI DISCREPANZE ====================
        
        // ==================== AI ANALISI DISCREPANZE ====================
        
        // Analizza discrepanze con AI
        async function analyzeDiscrepanciesWithAI() {
            if (!currentDetailExchange) return;
            
            const exchData = exchangeData[currentDetailExchange];
            const issues = exchData?.discrepancies || [];
            
            if (issues.length === 0) {
                alert('‚úÖ Nessuna discrepanza da analizzare!');
                return;
            }
            
            // Prepara contesto per AI
            const transactions = exchData.transactions || [];
            const realBalances = exchData.realBalances || {};
            
            // Analizza pattern per ogni discrepanza
            const analysisData = [];
            
            for (const issue of issues) {
                const coin = issue.coin;
                const coinTx = transactions.filter(tx => 
                    (tx.asset_in || tx.coin)?.toUpperCase() === coin.toUpperCase()
                );
                
                // Trova pattern
                const deposits = coinTx.filter(tx => tx.type === 'deposit' || tx.change > 0);
                const withdrawals = coinTx.filter(tx => tx.type === 'withdrawal' || tx.change < 0);
                const rewards = coinTx.filter(tx => tx.type === 'staking' || tx.type === 'interest' || tx.type === 'reward');
                
                // Date range
                const dates = coinTx.map(tx => new Date(tx.timestamp || tx.date)).sort((a, b) => a - b);
                const firstTx = dates[0];
                const lastTx = dates[dates.length - 1];
                
                // Prezzo attuale
                const priceEur = getPriceEur(coin, new Date().getFullYear());
                const diffValueEur = Math.abs(issue.difference) * priceEur;
                
                analysisData.push({
                    coin,
                    difference: issue.difference,
                    diffValueEur,
                    calculated: issue.calculated,
                    real: issue.real,
                    totalTx: coinTx.length,
                    deposits: deposits.length,
                    withdrawals: withdrawals.length,
                    rewards: rewards.length,
                    firstTx: firstTx?.toISOString().slice(0, 10),
                    lastTx: lastTx?.toISOString().slice(0, 10)
                });
            }
            
            // Costruisci prompt per AI
            const prompt = buildDiscrepancyAnalysisPrompt(currentDetailExchange, analysisData, realBalances);
            
            // Mostra modal con analisi
            showAIDiscrepancyModal(prompt, analysisData);
        }
        
        // Costruisce prompt per analisi AI
        function buildDiscrepancyAnalysisPrompt(exchangeId, analysisData, realBalances) {
            let prompt = `Sei un esperto fiscalista crypto italiano. Analizza queste discrepanze su ${exchangeId.toUpperCase()} e suggerisci come risolverle.\n\n`;
            
            prompt += `## DISCREPANZE RILEVATE\n\n`;
            
            for (const data of analysisData) {
                prompt += `### ${data.coin}\n`;
                prompt += `- Saldo calcolato: ${data.calculated.toFixed(6)}\n`;
                prompt += `- Saldo reale: ${data.real.toFixed(6)}\n`;
                prompt += `- Differenza: ${data.difference > 0 ? '+' : ''}${data.difference.toFixed(6)} (~‚Ç¨${data.diffValueEur.toFixed(2)})\n`;
                prompt += `- Transazioni trovate: ${data.totalTx} (${data.deposits} depositi, ${data.withdrawals} prelievi, ${data.rewards} rewards)\n`;
                prompt += `- Periodo: ${data.firstTx || 'N/A'} ‚Üí ${data.lastTx || 'N/A'}\n\n`;
            }
            
            prompt += `## RICHIESTA\n\n`;
            prompt += `Per ogni discrepanza:\n`;
            prompt += `1. Identifica la CAUSA pi√π probabile (staking reward, airdrop, referral, dust conversion, fork, ecc.)\n`;
            prompt += `2. Suggerisci il TIPO di transazione da aggiungere (deposit, withdrawal, reward, ecc.)\n`;
            prompt += `3. Suggerisci la DATA pi√π probabile\n`;
            prompt += `4. Indica se √® FISCALMENTE RILEVANTE (va dichiarata come reddito?)\n\n`;
            
            prompt += `Rispondi in formato strutturato per ogni coin.`;
            
            return prompt;
        }
        
        // Modal per analisi AI discrepanze
        function showAIDiscrepancyModal(prompt, analysisData) {
            // Crea modal
            let modal = document.getElementById('aiDiscrepancyModal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'aiDiscrepancyModal';
                modal.className = 'modal';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width:800px;max-height:90vh;overflow-y:auto;">
                        <div class="modal-header">
                            <h2>ü§ñ Analisi AI Discrepanze</h2>
                            <button class="modal-close" onclick="document.getElementById('aiDiscrepancyModal').classList.remove('active')">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div id="aiDiscrepancyContent"></div>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
            }
            
            const content = document.getElementById('aiDiscrepancyContent');
            
            // Mostra riepilogo discrepanze
            let html = `<div style="margin-bottom:20px;">`;
            html += `<h3 style="margin-bottom:12px;">üìä Riepilogo Discrepanze</h3>`;
            html += `<div style="display:grid;gap:12px;">`;
            
            for (const data of analysisData) {
                const isPositive = data.difference > 0;
                const color = isPositive ? 'var(--green)' : 'var(--red)';
                const icon = isPositive ? 'üì•' : 'üì§';
                
                html += `
                <div style="background:var(--bg-primary);padding:12px;border-radius:8px;border-left:3px solid ${color};">
                    <div style="display:flex;justify-content:space-between;align-items:center;">
                        <span style="font-weight:700;font-size:16px;">${icon} ${data.coin}</span>
                        <span style="color:${color};font-weight:600;">${data.difference > 0 ? '+' : ''}${data.difference.toFixed(6)} (~‚Ç¨${data.diffValueEur.toFixed(2)})</span>
                    </div>
                    <div style="font-size:12px;color:var(--text-secondary);margin-top:4px;">
                        ${data.totalTx} tx | ${data.deposits} dep | ${data.withdrawals} with | ${data.rewards} rewards
                    </div>
                </div>`;
            }
            
            html += `</div></div>`;
            
            // Analisi AI automatica
            html += `<div style="margin-bottom:20px;">`;
            html += `<h3 style="margin-bottom:12px;">üîç Analisi Automatica</h3>`;
            html += `<div id="aiAutoAnalysis" style="background:var(--bg-primary);padding:16px;border-radius:8px;">`;
            
            // Analisi euristica per ogni discrepanza
            for (const data of analysisData) {
                const analysis = analyzeDiscrepancyHeuristic(data);
                html += `
                <div style="margin-bottom:16px;padding-bottom:16px;border-bottom:1px solid var(--border);">
                    <div style="font-weight:700;margin-bottom:8px;">${data.coin}</div>
                    <div style="display:grid;gap:8px;font-size:13px;">
                        <div>üéØ <strong>Causa probabile:</strong> ${analysis.cause}</div>
                        <div>üìù <strong>Tipo transazione:</strong> ${analysis.txType}</div>
                        <div>üìÖ <strong>Data suggerita:</strong> ${analysis.suggestedDate}</div>
                        <div>üí∂ <strong>Rilevanza fiscale:</strong> ${analysis.fiscalRelevance}</div>
                    </div>
                    <button class="btn" onclick="applyAISuggestion('${currentDetailExchange}', '${data.coin}', ${data.difference}, '${analysis.txType}', '${analysis.cause}')" 
                            style="margin-top:12px;padding:8px 16px;background:var(--green);color:#000;">
                        ‚úÖ Applica Suggerimento
                    </button>
                </div>`;
            }
            
            html += `</div></div>`;
            
            // Bottone risolvi tutte con AI
            html += `
            <div style="display:flex;gap:12px;justify-content:center;margin-top:20px;">
                <button class="btn" onclick="applyAllAISuggestions()" style="padding:12px 24px;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);color:#fff;font-size:14px;">
                    ü§ñ Applica Tutti i Suggerimenti AI
                </button>
                <button class="btn btn-secondary" onclick="document.getElementById('aiDiscrepancyModal').classList.remove('active')" style="padding:12px 24px;">
                    Chiudi
                </button>
            </div>`;
            
            content.innerHTML = html;
            modal.classList.add('active');
        }
        
        // Analisi euristica delle discrepanze
        function analyzeDiscrepancyHeuristic(data) {
            const { coin, difference, diffValueEur, deposits, withdrawals, rewards, lastTx } = data;
            const isPositive = difference > 0;
            const amount = Math.abs(difference);
            
            let cause, txType, suggestedDate, fiscalRelevance;
            
            if (isPositive) {
                // Manca un deposito/entrata
                
                // Staking rewards sono comuni per BNB, DOT, ADA, SOL, ATOM
                const stakingCoins = ['BNB', 'DOT', 'ADA', 'SOL', 'ATOM', 'MATIC', 'AVAX', 'NEAR', 'FTM', 'ONE'];
                
                // Airdrop comuni
                const airdropCoins = ['NOT', 'DOGS', 'HMSTR', 'CATI', 'ARB', 'OP', 'BLUR', 'APT', 'SUI'];
                
                // Dust conversion (piccole quantit√†)
                const isDust = amount < 0.01 && diffValueEur < 1;
                
                if (isDust && coin === 'BNB') {
                    cause = 'üßπ Dust ‚Üí BNB conversion (Binance converte automaticamente)';
                    txType = 'reward';
                    fiscalRelevance = '‚ö™ Trascurabile (<‚Ç¨1)';
                } else if (airdropCoins.includes(coin.toUpperCase())) {
                    cause = 'üéÅ Airdrop (token distribuito gratuitamente)';
                    txType = 'deposit';
                    fiscalRelevance = 'üü° Reddito diverso - va dichiarato al valore di ricezione';
                } else if (stakingCoins.includes(coin.toUpperCase()) || rewards > 0) {
                    cause = 'ü•© Staking/Earn rewards';
                    txType = 'staking';
                    fiscalRelevance = 'üü° Reddito diverso - va dichiarato';
                } else if (coin === 'BNB' && diffValueEur < 5) {
                    cause = 'üí∞ Cashback/Referral bonus';
                    txType = 'reward';
                    fiscalRelevance = 'üü° Reddito diverso';
                } else {
                    cause = 'üì• Deposito non tracciato (transfer da altro wallet?)';
                    txType = 'deposit';
                    fiscalRelevance = '‚ö™ No (solo spostamento se da proprio wallet)';
                }
            } else {
                // Manca un prelievo/uscita
                
                if (Math.abs(diffValueEur) < 1) {
                    cause = 'üí∏ Fee di rete non tracciata';
                    txType = 'fee';
                    fiscalRelevance = '‚ö™ Deducibile da plusvalenze';
                } else if (coin === 'BNB') {
                    cause = 'üí∏ Fee pagate in BNB per transazioni';
                    txType = 'fee';
                    fiscalRelevance = '‚ö™ Deducibile';
                } else {
                    cause = 'üì§ Prelievo non tracciato (transfer verso altro wallet?)';
                    txType = 'withdrawal';
                    fiscalRelevance = '‚ö™ No (se spostamento interno)';
                }
            }
            
            // Data suggerita: ultima transazione o oggi
            suggestedDate = lastTx || new Date().toISOString().slice(0, 10);
            
            return { cause, txType, suggestedDate, fiscalRelevance };
        }
        
        // Applica singolo suggerimento AI
        function applyAISuggestion(exchangeId, coin, difference, txType, cause) {
            const confirmed = confirm(
                `ü§ñ Applicare suggerimento AI?\n\n` +
                `Coin: ${coin}\n` +
                `Tipo: ${txType}\n` +
                `Quantit√†: ${Math.abs(difference).toFixed(6)}\n` +
                `Causa: ${cause}\n\n` +
                `Verr√† aggiunta una transazione di aggiustamento.`
            );
            
            if (!confirmed) return;
            
            addManualTransaction(exchangeId, {
                date: new Date(),
                type: txType,
                coin: coin,
                amount: difference,
                notes: `AI: ${cause}`
            });
            
            // Aggiorna discrepanze
            const exchData = exchangeData[exchangeId];
            if (exchData) {
                exchData.discrepancies = exchData.discrepancies?.filter(d => d.coin !== coin) || [];
                saveExchangeDataToFirebase();
            }
            
            // Refresh
            renderDiscrepanciesSection(exchangeId);
            filterExchDetailTx();
            
            // Chiudi modal se non ci sono pi√π discrepanze
            if (!exchData.discrepancies || exchData.discrepancies.length === 0) {
                document.getElementById('aiDiscrepancyModal')?.classList.remove('active');
                alert('‚úÖ Tutte le discrepanze risolte!');
            }
        }
        
        // Applica tutti i suggerimenti AI
        function applyAllAISuggestions() {
            if (!currentDetailExchange) return;
            
            const exchData = exchangeData[currentDetailExchange];
            const issues = exchData?.discrepancies || [];
            
            if (issues.length === 0) {
                alert('‚úÖ Nessuna discrepanza da risolvere!');
                return;
            }
            
            const confirmed = confirm(
                `ü§ñ Applicare TUTTI i ${issues.length} suggerimenti AI?\n\n` +
                `Verranno aggiunte ${issues.length} transazioni di aggiustamento ` +
                `basate sull'analisi automatica.\n\n` +
                `Continuare?`
            );
            
            if (!confirmed) return;
            
            let resolved = 0;
            
            for (const issue of issues) {
                const data = {
                    coin: issue.coin,
                    difference: issue.difference,
                    diffValueEur: Math.abs(issue.difference) * getPriceEur(issue.coin, new Date().getFullYear()),
                    deposits: 0,
                    withdrawals: 0,
                    rewards: 0,
                    lastTx: new Date().toISOString().slice(0, 10)
                };
                
                const analysis = analyzeDiscrepancyHeuristic(data);
                
                addManualTransaction(currentDetailExchange, {
                    date: new Date(),
                    type: analysis.txType,
                    coin: issue.coin,
                    amount: issue.difference,
                    notes: `AI: ${analysis.cause}`
                });
                
                resolved++;
            }
            
            // Pulisci discrepanze
            exchData.discrepancies = [];
            saveExchangeDataToFirebase();
            
            // Refresh UI
            renderDiscrepanciesSection(currentDetailExchange);
            filterExchDetailTx();
            
            // Chiudi modal
            document.getElementById('aiDiscrepancyModal')?.classList.remove('active');
            
            alert(`‚úÖ Risolte ${resolved} discrepanze con AI!\n\nLe transazioni sono state aggiunte con note sulla causa probabile.`);
        }
        
        // ==================== END AI ANALISI DISCREPANZE ====================
        
        // ==================== ü§ñ ANALISI COMPLETA AUTOMATICA ====================
        
        // Stato analisi globale
        let analysisInProgress = false;
        let analysisLog = [];
        
        // Funzione principale: FA TUTTO!
        async function runCompleteAnalysis() {
            if (analysisInProgress) {
                alert('‚ö†Ô∏è Analisi gi√† in corso...');
                return;
            }
            
            analysisInProgress = true;
            analysisLog = [];
            
            // Mostra modal progress
            showAnalysisProgressModal();
            
            try {
                const startTime = Date.now();
                
                // ========== STEP 1: Raccolta Dati ==========
                await updateAnalysisStep(1, 'Raccolta dati da tutti gli exchange e wallet...');
                
                // üîë IMPORTANTE: Carica wallet da localStorage!
                loadWalletTransactions();
                
                // üîß Ripara tipi transazioni esistenti
                for (const exchId of Object.keys(exchangeData)) {
                    const exchData = exchangeData[exchId];
                    if (!exchData?.transactions) continue;
                    
                    for (const tx of exchData.transactions) {
                        // Inferisci tipo se mancante o generico
                        if (!tx.type || tx.type === 'unknown' || tx.type === '') {
                            const change = tx.change || 0;
                            if (change > 0) tx.type = 'deposit';
                            else if (change < 0) tx.type = 'withdrawal';
                        }
                    }
                }
                
                const exchanges = Object.keys(exchangeData).filter(id => 
                    exchangeData[id]?.transactions?.length > 0 || 
                    exchangeData[id]?.realBalances
                );
                
                // üÜï Includi anche i Wallet!
                const walletAddresses = Object.keys(walletTransactions || {});
                const hasWallets = walletAddresses.length > 0;
                
                logAnalysis(`üîç Debug: walletTransactions keys = ${walletAddresses.length}`);
                
                if (exchanges.length === 0 && !hasWallets) {
                    throw new Error('Nessun dato trovato. Importa prima exchange o wallet!');
                }
                
                logAnalysis(`üìä Trovati ${exchanges.length} exchange con dati: ${exchanges.join(', ') || 'nessuno'}`);
                
                let totalTransactions = 0;
                for (const exchId of exchanges) {
                    const count = exchangeData[exchId]?.transactions?.length || 0;
                    totalTransactions += count;
                    logAnalysis(`   ‚Ä¢ ${exchId}: ${count} transazioni`);
                }
                
                // Conta transazioni wallet
                let walletTxCount = 0;
                if (hasWallets) {
                    logAnalysis(`üì± Trovati ${walletAddresses.length} wallet:`);
                    for (const addr of walletAddresses) {
                        const wData = walletTransactions[addr];
                        const count = (wData?.nativeTx?.length || 0) + (wData?.tokenTx?.length || 0);
                        walletTxCount += count;
                        logAnalysis(`   ‚Ä¢ ${addr.slice(0, 8)}...${addr.slice(-6)}: ${count} tx`);
                    }
                    totalTransactions += walletTxCount;
                }
                
                logAnalysis(`\nüìà Totale: ${totalTransactions} transazioni`);
                
                // ========== STEP 2: Converti Wallet in formato Exchange ==========
                if (hasWallets) {
                    await updateAnalysisStep(2, 'Conversione wallet in formato exchange...');
                    
                    for (const addr of walletAddresses) {
                        const walletId = `wallet_${addr.slice(0, 8)}`;
                        const wData = walletTransactions[addr];
                        
                        // Converti transazioni wallet in formato exchange
                        const convertedTx = [];
                        
                        // Native transactions
                        for (const tx of (wData?.nativeTx || [])) {
                            convertedTx.push(createEnrichedTransaction({
                                timestamp: new Date(tx.block_timestamp || tx.timestamp),
                                type: tx.from_address?.toLowerCase() === addr.toLowerCase() ? 'withdrawal' : 'deposit',
                                asset_in: tx.token_symbol || 'ETH',
                                amount_in: parseFloat(tx.value) / Math.pow(10, tx.token_decimals || 18),
                                tx_hash: tx.transaction_hash || tx.hash,
                                source: walletId,
                                exchange: walletId,
                                change: tx.from_address?.toLowerCase() === addr.toLowerCase() 
                                    ? -parseFloat(tx.value) / Math.pow(10, tx.token_decimals || 18)
                                    : parseFloat(tx.value) / Math.pow(10, tx.token_decimals || 18)
                            }));
                        }
                        
                        // Token transactions
                        for (const tx of (wData?.tokenTx || [])) {
                            convertedTx.push(createEnrichedTransaction({
                                timestamp: new Date(tx.block_timestamp || tx.timestamp),
                                type: tx.from_address?.toLowerCase() === addr.toLowerCase() ? 'withdrawal' : 'deposit',
                                asset_in: tx.token_symbol || 'UNKNOWN',
                                amount_in: parseFloat(tx.value) / Math.pow(10, tx.token_decimals || 18),
                                tx_hash: tx.transaction_hash || tx.hash,
                                source: walletId,
                                exchange: walletId,
                                change: tx.from_address?.toLowerCase() === addr.toLowerCase() 
                                    ? -parseFloat(tx.value) / Math.pow(10, tx.token_decimals || 18)
                                    : parseFloat(tx.value) / Math.pow(10, tx.token_decimals || 18)
                            }));
                        }
                        
                        // Salva come pseudo-exchange
                        if (convertedTx.length > 0) {
                            exchangeData[walletId] = {
                                transactions: convertedTx,
                                isWallet: true,
                                walletAddress: addr,
                                source: 'wallet'
                            };
                            exchanges.push(walletId);
                            logAnalysis(`   ‚úÖ ${walletId}: ${convertedTx.length} tx convertite`);
                        }
                    }
                } else {
                    // Skip step 2 se nessun wallet
                    const step2El = document.getElementById('analysisStep2');
                    if (step2El) {
                        step2El.innerHTML = '‚è≠Ô∏è 2. Conversione wallet (nessun wallet)';
                        step2El.style.opacity = '0.5';
                    }
                    logAnalysis(`‚è≠Ô∏è Step 2 skippato (nessun wallet)`);
                }
                
                // ========== STEP 3: Fetch Prezzi Storici ==========
                await updateAnalysisStep(3, 'Recupero prezzi storici da CryptoCompare...');
                
                let pricesFetched = 0;
                let pricesTotal = 0;
                
                for (const exchId of exchanges) {
                    const transactions = exchangeData[exchId]?.transactions || [];
                    
                    // Trova prezzi mancanti
                    const missingPrices = new Map();
                    
                    for (const tx of transactions) {
                        const coin = (tx.asset_in || tx.coin || '').toUpperCase();
                        if (!coin || coin === 'EUR' || coin === 'USD' || coin.startsWith('LD')) continue;
                        
                        const txDate = tx.timestamp || tx.date;
                        const d = txDate instanceof Date ? txDate : new Date(txDate);
                        const dateKey = d.toISOString().slice(0, 10);
                        const cacheKey = `${coin}_${dateKey}`;
                        
                        if (!cryptoComparePriceCache[cacheKey] && !missingPrices.has(cacheKey)) {
                            missingPrices.set(cacheKey, { coin, date: d });
                        }
                    }
                    
                    pricesTotal += missingPrices.size;
                    
                    // Fetch prezzi mancanti
                    let fetched = 0;
                    for (const [key, info] of missingPrices) {
                        const price = await fetchCryptoComparePriceForDate(info.coin, info.date);
                        if (price && price > 0) {
                            fetched++;
                            pricesFetched++;
                        }
                        
                        // Update progress ogni 10
                        if (fetched % 10 === 0) {
                            updateAnalysisProgress(2, `Prezzi: ${pricesFetched}/${pricesTotal}...`);
                        }
                        
                        await new Promise(r => setTimeout(r, 50)); // Rate limit
                    }
                }
                
                logAnalysis(`üí∞ Recuperati ${pricesFetched} prezzi storici`);
                
                // ========== STEP 4: Arricchimento Transazioni ==========
                await updateAnalysisStep(4, 'Arricchimento transazioni con prezzi e cost basis...');
                
                let enriched = 0;
                
                for (const exchId of exchanges) {
                    const transactions = exchangeData[exchId]?.transactions || [];
                    
                    for (const tx of transactions) {
                        const coin = tx.asset_in || tx.coin;
                        if (!coin) continue;
                        
                        const txDate = tx.timestamp || tx.date;
                        
                        // Calcola prezzo se mancante
                        if (!tx.price_eur || tx.price_eur <= 0) {
                            tx.price_eur = getPriceEur(coin, txDate);
                        }
                        
                        // Calcola valore
                        if (tx.price_eur > 0 && (tx.amount_in || tx.amount) > 0) {
                            const amount = tx.amount_in || tx.amount;
                            tx.value_eur = amount * tx.price_eur;
                            tx.amountEur = tx.value_eur;
                            
                            // Cost basis per acquisti
                            if (tx.type === 'buy' || tx.type === 'deposit') {
                                tx.cost_basis_eur = tx.value_eur + (tx.fee_eur || 0);
                            }
                            
                            enriched++;
                        }
                    }
                }
                
                logAnalysis(`üìù Arricchite ${enriched} transazioni con prezzi`);
                
                // ========== STEP 5: Transfer Matching ==========
                await updateAnalysisStep(5, 'Riconciliazione trasferimenti tra exchange/wallet...');
                
                // Raccogli tutte le transazioni
                const allTransactions = [];
                for (const exchId of exchanges) {
                    const transactions = exchangeData[exchId]?.transactions || [];
                    for (const tx of transactions) {
                        allTransactions.push({ ...tx, _source: exchId });
                    }
                }
                
                // Debug: conta per exchange e tipo
                const bySource = {};
                for (const tx of allTransactions) {
                    const source = tx._source;
                    if (!bySource[source]) bySource[source] = { total: 0, withdrawal: 0, deposit: 0 };
                    bySource[source].total++;
                    if (tx.type === 'withdrawal' || tx.type === 'withdraw') bySource[source].withdrawal++;
                    if (tx.type === 'deposit') bySource[source].deposit++;
                }
                
                logAnalysis(`üìä Transazioni per source:`);
                for (const [src, counts] of Object.entries(bySource)) {
                    logAnalysis(`   ‚Ä¢ ${src}: ${counts.total} totali (${counts.withdrawal} withdraw, ${counts.deposit} deposit)`);
                }
                
                // Match transfers cross-exchange
                const matched = matchCrossExchangeTransfers(allTransactions);
                logAnalysis(`üîó Matchati ${matched} trasferimenti interni`);
                
                // ========== STEP 6: Risoluzione Discrepanze ==========
                await updateAnalysisStep(6, 'Analisi e risoluzione discrepanze...');
                
                let discrepanciesResolved = 0;
                let totalDiscrepancies = 0;
                
                for (const exchId of exchanges) {
                    const exchData = exchangeData[exchId];
                    if (!exchData?.realBalances || Object.keys(exchData.realBalances).length === 0) continue;
                    
                    // Calcola discrepanze
                    const check = zeroSumCheck(exchData.transactions || [], exchData.realBalances);
                    
                    if (check.issues && check.issues.length > 0) {
                        totalDiscrepancies += check.issues.length;
                        
                        // Risolvi automaticamente
                        for (const issue of check.issues) {
                            const analysis = analyzeDiscrepancyHeuristic({
                                coin: issue.coin,
                                difference: issue.difference,
                                diffValueEur: Math.abs(issue.difference) * getPriceEur(issue.coin, new Date().getFullYear()),
                                deposits: 0, withdrawals: 0, rewards: 0,
                                lastTx: new Date().toISOString().slice(0, 10)
                            });
                            
                            // Aggiungi transazione di aggiustamento
                            addManualTransaction(exchId, {
                                date: new Date(),
                                type: analysis.txType,
                                coin: issue.coin,
                                amount: issue.difference,
                                notes: `ü§ñ Auto: ${analysis.cause}`
                            });
                            
                            discrepanciesResolved++;
                            logAnalysis(`   ‚úÖ ${exchId}/${issue.coin}: ${analysis.cause}`);
                        }
                        
                        // Pulisci discrepanze
                        exchData.discrepancies = [];
                    }
                }
                
                logAnalysis(`üîß Risolte ${discrepanciesResolved}/${totalDiscrepancies} discrepanze`);
                
                // ========== STEP 7: Ricalcolo Totali ==========
                await updateAnalysisStep(7, 'Ricalcolo totali per anno...');
                
                for (const exchId of exchanges) {
                    recalculateExchangeBalances(exchId);
                }
                
                logAnalysis(`üìä Totali ricalcolati per ${exchanges.length} exchange/wallet`);
                
                // ========== STEP 8: Aggiornamento Cost Basis ==========
                await updateAnalysisStep(8, 'Aggiornamento registro cost basis...');
                
                // Ricostruisci cost basis da tutte le transazioni
                let lotsCreated = 0;
                
                for (const exchId of exchanges) {
                    const result = extractCostBasisFromTransactions(exchId);
                    lotsCreated += result?.lots || 0;
                }
                
                logAnalysis(`üì¶ Creati ${lotsCreated} lotti cost basis`);
                
                // ========== STEP 9: Salvataggio ==========
                await updateAnalysisStep(9, 'Salvataggio dati...');
                
                saveExchangeDataToFirebase();
                saveCostBasisLots();
                
                // ========== COMPLETATO ==========
                const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
                
                logAnalysis(`\n‚úÖ ANALISI COMPLETATA in ${elapsed}s`);
                logAnalysis(`${'‚îÄ'.repeat(40)}`);
                logAnalysis(`üìä ${totalTransactions} transazioni elaborate`);
                logAnalysis(`üí∞ ${pricesFetched} prezzi recuperati`);
                logAnalysis(`üîó ${matched} transfer matchati`);
                logAnalysis(`üîß ${discrepanciesResolved} discrepanze risolte`);
                logAnalysis(`üì¶ ${lotsCreated} lotti cost basis`);
                
                // Mostra risultato finale
                showAnalysisComplete({
                    exchanges: exchanges.length,
                    transactions: totalTransactions,
                    pricesFetched,
                    transfersMatched: matched,
                    discrepanciesResolved,
                    lotsCreated,
                    elapsed
                });
                
                // Refresh UI
                initExchangeGrid();
                updateExchangeTotals();
                
            } catch (error) {
                console.error('Analisi error:', error);
                logAnalysis(`\n‚ùå ERRORE: ${error.message}`);
                showAnalysisError(error.message);
            } finally {
                analysisInProgress = false;
            }
        }
        
        // Match trasferimenti cross-exchange
        function matchCrossExchangeTransfers(allTransactions) {
            const windowMs = 2 * 60 * 60 * 1000; // 2 ore (aumentato da 1 ora)
            let matched = 0;
            
            // Debug: conta per tipo
            const typeCounts = {};
            for (const tx of allTransactions) {
                const type = tx.type || 'unknown';
                typeCounts[type] = (typeCounts[type] || 0) + 1;
            }
            console.log('üìä Transazioni per tipo:', typeCounts);
            
            const withdrawals = allTransactions.filter(tx => 
                (tx.type === 'withdrawal' || tx.type === 'withdraw') && !tx.is_internal && !tx.linked_tx_id
            );
            
            const deposits = allTransactions.filter(tx => 
                tx.type === 'deposit' && !tx.is_internal && !tx.linked_tx_id
            );
            
            console.log(`üîç Transfer Matching: ${withdrawals.length} withdrawals, ${deposits.length} deposits`);
            
            // Debug: mostra primi 5 withdrawal e deposit
            if (withdrawals.length > 0) {
                console.log('üì§ Sample withdrawals:', withdrawals.slice(0, 5).map(w => ({
                    source: w._source,
                    coin: w.asset_in || w.coin,
                    amount: w.amount_in || w.amount,
                    date: w.timestamp || w.date
                })));
            }
            if (deposits.length > 0) {
                console.log('üì• Sample deposits:', deposits.slice(0, 5).map(d => ({
                    source: d._source,
                    coin: d.asset_in || d.coin,
                    amount: d.amount_in || d.amount,
                    date: d.timestamp || d.date
                })));
            }
            
            for (const w of withdrawals) {
                const wTime = (w.timestamp || w.date) instanceof Date 
                    ? (w.timestamp || w.date).getTime() 
                    : new Date(w.timestamp || w.date).getTime();
                const wCoin = (w.asset_in || w.coin || '').toUpperCase();
                const wAmount = Math.abs(w.amount_in || w.amount || 0);
                
                for (const d of deposits) {
                    if (d.linked_tx_id) continue;
                    if (d._source === w._source) continue; // Stesso exchange
                    
                    const dTime = (d.timestamp || d.date) instanceof Date 
                        ? (d.timestamp || d.date).getTime() 
                        : new Date(d.timestamp || d.date).getTime();
                    const dCoin = (d.asset_in || d.coin || '').toUpperCase();
                    const dAmount = Math.abs(d.amount_in || d.amount || 0);
                    
                    const timeDiff = Math.abs(dTime - wTime);
                    const amountDiff = Math.abs(wAmount - dAmount) / Math.max(wAmount, dAmount, 0.0001);
                    
                    // Debug: log near matches
                    if (wCoin === dCoin && timeDiff <= windowMs * 2) {
                        console.log(`üîé Potential match: ${wCoin} ${wAmount} (${w._source}) ‚Üî ${dAmount} (${d._source}) | timeDiff=${Math.round(timeDiff/60000)}min | amountDiff=${(amountDiff*100).toFixed(1)}%`);
                    }
                    
                    if (wCoin === dCoin && timeDiff <= windowMs && amountDiff <= 0.10) { // Aumentato tolleranza a 10%
                        w.linked_tx_id = d.id;
                        w.is_internal = true;
                        w.type = 'transfer';
                        
                        d.linked_tx_id = w.id;
                        d.is_internal = true;
                        d.type = 'transfer';
                        d.cost_basis_eur = w.cost_basis_eur;
                        
                        console.log(`‚úÖ MATCH: ${wCoin} ${wAmount.toFixed(4)} | ${w._source} ‚Üí ${d._source}`);
                        matched++;
                        break;
                    }
                }
            }
            
            return matched;
        }
        
        // Helper: log analisi
        function logAnalysis(message) {
            analysisLog.push(message);
            console.log(message);
            
            const logEl = document.getElementById('analysisLog');
            if (logEl) {
                logEl.innerHTML = analysisLog.map(m => 
                    `<div style="font-family:monospace;font-size:12px;margin:2px 0;">${m}</div>`
                ).join('');
                logEl.scrollTop = logEl.scrollHeight;
            }
        }
        
        // Helper: update step
        async function updateAnalysisStep(step, message) {
            const stepEl = document.getElementById(`analysisStep${step}`);
            const progressEl = document.getElementById('analysisProgressText');
            
            // Marca step precedenti come completati
            for (let i = 1; i < step; i++) {
                const prevEl = document.getElementById(`analysisStep${i}`);
                if (prevEl) {
                    prevEl.innerHTML = prevEl.innerHTML.replace('‚è≥', '‚úÖ');
                    prevEl.style.opacity = '0.7';
                }
            }
            
            if (stepEl) {
                stepEl.innerHTML = `‚è≥ ${message}`;
                stepEl.style.color = 'var(--accent)';
                stepEl.style.fontWeight = '600';
            }
            
            if (progressEl) {
                progressEl.textContent = message;
            }
            
            logAnalysis(`\nüìå STEP ${step}: ${message}`);
            
            // Piccola pausa per UI update
            await new Promise(r => setTimeout(r, 100));
        }
        
        // Helper: update progress dentro step
        function updateAnalysisProgress(step, message) {
            const progressEl = document.getElementById('analysisProgressText');
            if (progressEl) {
                progressEl.textContent = message;
            }
        }
        
        // Modal progress analisi
        function showAnalysisProgressModal() {
            let modal = document.getElementById('analysisProgressModal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'analysisProgressModal';
                modal.className = 'modal';
                document.body.appendChild(modal);
            }
            
            modal.innerHTML = `
                <div class="modal-content" style="max-width:600px;">
                    <div class="modal-header">
                        <h2>ü§ñ Analisi Completa in Corso...</h2>
                    </div>
                    <div class="modal-body">
                        <div style="margin-bottom:20px;">
                            <div style="background:var(--bg-primary);border-radius:8px;height:8px;overflow:hidden;">
                                <div id="analysisProgressBar" style="background:linear-gradient(90deg,#667eea,#764ba2);height:100%;width:0%;transition:width 0.3s;animation:pulse 1.5s infinite;"></div>
                            </div>
                            <div id="analysisProgressText" style="text-align:center;margin-top:8px;font-size:13px;color:var(--text-secondary);">Inizializzazione...</div>
                        </div>
                        
                        <div style="display:grid;gap:8px;margin-bottom:20px;">
                            <div id="analysisStep1" style="padding:8px;background:var(--bg-primary);border-radius:6px;">‚è≥ 1. Raccolta dati exchange e wallet</div>
                            <div id="analysisStep2" style="padding:8px;background:var(--bg-primary);border-radius:6px;">‚è≥ 2. Conversione wallet</div>
                            <div id="analysisStep3" style="padding:8px;background:var(--bg-primary);border-radius:6px;">‚è≥ 3. Fetch prezzi storici</div>
                            <div id="analysisStep4" style="padding:8px;background:var(--bg-primary);border-radius:6px;">‚è≥ 4. Arricchimento transazioni</div>
                            <div id="analysisStep5" style="padding:8px;background:var(--bg-primary);border-radius:6px;">‚è≥ 5. Riconciliazione trasferimenti</div>
                            <div id="analysisStep6" style="padding:8px;background:var(--bg-primary);border-radius:6px;">‚è≥ 6. Risoluzione discrepanze</div>
                            <div id="analysisStep7" style="padding:8px;background:var(--bg-primary);border-radius:6px;">‚è≥ 7. Ricalcolo totali</div>
                            <div id="analysisStep8" style="padding:8px;background:var(--bg-primary);border-radius:6px;">‚è≥ 8. Aggiornamento cost basis</div>
                            <div id="analysisStep9" style="padding:8px;background:var(--bg-primary);border-radius:6px;">‚è≥ 9. Salvataggio</div>
                        </div>
                        
                        <div style="background:var(--bg-primary);border-radius:8px;padding:12px;max-height:200px;overflow-y:auto;" id="analysisLog">
                            <div style="font-family:monospace;font-size:12px;color:var(--text-secondary);">Avvio analisi...</div>
                        </div>
                    </div>
                </div>
            `;
            
            // Anima progress bar
            setTimeout(() => {
                const bar = document.getElementById('analysisProgressBar');
                if (bar) bar.style.width = '100%';
            }, 100);
            
            modal.classList.add('active');
        }
        
        // Modal completamento analisi
        function showAnalysisComplete(results) {
            const modal = document.getElementById('analysisProgressModal');
            if (!modal) return;
            
            modal.innerHTML = `
                <div class="modal-content" style="max-width:600px;">
                    <div class="modal-header" style="background:linear-gradient(135deg,rgba(0,206,201,0.2),rgba(108,92,231,0.2));">
                        <h2>‚úÖ Analisi Completata!</h2>
                        <button class="modal-close" onclick="document.getElementById('analysisProgressModal').classList.remove('active')">&times;</button>
                    </div>
                    <div class="modal-body">
                        <div style="text-align:center;margin-bottom:24px;">
                            <div style="font-size:64px;margin-bottom:12px;">üéâ</div>
                            <div style="font-size:18px;font-weight:600;">Tutti i dati sono stati elaborati!</div>
                            <div style="font-size:14px;color:var(--text-secondary);">Tempo: ${results.elapsed} secondi</div>
                        </div>
                        
                        <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:12px;margin-bottom:24px;">
                            <div style="background:var(--bg-primary);padding:16px;border-radius:12px;text-align:center;">
                                <div style="font-size:28px;font-weight:700;color:var(--green);">${results.transactions}</div>
                                <div style="font-size:12px;color:var(--text-secondary);">Transazioni</div>
                            </div>
                            <div style="background:var(--bg-primary);padding:16px;border-radius:12px;text-align:center;">
                                <div style="font-size:28px;font-weight:700;color:var(--accent);">${results.pricesFetched}</div>
                                <div style="font-size:12px;color:var(--text-secondary);">Prezzi Recuperati</div>
                            </div>
                            <div style="background:var(--bg-primary);padding:16px;border-radius:12px;text-align:center;">
                                <div style="font-size:28px;font-weight:700;color:var(--yellow);">${results.discrepanciesResolved}</div>
                                <div style="font-size:12px;color:var(--text-secondary);">Discrepanze Risolte</div>
                            </div>
                        </div>
                        
                        <div style="display:grid;grid-template-columns:repeat(2,1fr);gap:12px;margin-bottom:24px;">
                            <div style="background:var(--bg-primary);padding:12px;border-radius:8px;display:flex;align-items:center;gap:12px;">
                                <span style="font-size:24px;">üîó</span>
                                <div>
                                    <div style="font-weight:600;">${results.transfersMatched}</div>
                                    <div style="font-size:11px;color:var(--text-secondary);">Transfer Matchati</div>
                                </div>
                            </div>
                            <div style="background:var(--bg-primary);padding:12px;border-radius:8px;display:flex;align-items:center;gap:12px;">
                                <span style="font-size:24px;">üì¶</span>
                                <div>
                                    <div style="font-weight:600;">${results.lotsCreated}</div>
                                    <div style="font-size:11px;color:var(--text-secondary);">Lotti Cost Basis</div>
                                </div>
                            </div>
                        </div>
                        
                        <div style="background:rgba(0,206,201,0.1);border:1px solid var(--green);border-radius:8px;padding:16px;margin-bottom:20px;">
                            <div style="font-weight:600;margin-bottom:8px;">‚úÖ Cosa √® stato fatto:</div>
                            <ul style="margin:0;padding-left:20px;font-size:13px;color:var(--text-secondary);">
                                <li>Prezzi storici recuperati da CryptoCompare</li>
                                <li>Transazioni arricchite con valori EUR</li>
                                <li>Trasferimenti tra exchange riconciliati</li>
                                <li>Discrepanze analizzate e risolte automaticamente</li>
                                <li>Cost basis calcolato per ogni acquisto</li>
                                <li>Totali per anno ricalcolati</li>
                            </ul>
                        </div>
                        
                        <div style="display:flex;gap:12px;justify-content:center;">
                            <button class="btn" onclick="showView('taxReport');document.getElementById('analysisProgressModal').classList.remove('active');" 
                                    style="padding:12px 24px;background:var(--green);color:#000;">
                                üìã Vai al Tax Report
                            </button>
                            <button class="btn btn-secondary" onclick="document.getElementById('analysisProgressModal').classList.remove('active')" 
                                    style="padding:12px 24px;">
                                Chiudi
                            </button>
                        </div>
                    </div>
                </div>
            `;
        }
        
        // Modal errore
        function showAnalysisError(message) {
            const modal = document.getElementById('analysisProgressModal');
            if (!modal) return;
            
            const content = modal.querySelector('.modal-content');
            if (content) {
                content.innerHTML = `
                    <div class="modal-header" style="background:rgba(255,107,107,0.2);">
                        <h2>‚ùå Errore Analisi</h2>
                        <button class="modal-close" onclick="document.getElementById('analysisProgressModal').classList.remove('active')">&times;</button>
                    </div>
                    <div class="modal-body">
                        <div style="text-align:center;margin-bottom:20px;">
                            <div style="font-size:48px;">üòï</div>
                            <div style="color:var(--red);font-weight:600;margin-top:12px;">${message}</div>
                        </div>
                        
                        <div style="background:var(--bg-primary);border-radius:8px;padding:12px;max-height:200px;overflow-y:auto;margin-bottom:20px;" id="analysisLog">
                            ${analysisLog.map(m => `<div style="font-family:monospace;font-size:12px;margin:2px 0;">${m}</div>`).join('')}
                        </div>
                        
                        <div style="text-align:center;">
                            <button class="btn btn-secondary" onclick="document.getElementById('analysisProgressModal').classList.remove('active')">Chiudi</button>
                        </div>
                    </div>
                `;
            }
        }
        
        // ==================== END ANALISI COMPLETA AUTOMATICA ====================
        
        // ==================== ü§ñ AUTO-PILOT MODE ====================
        
        // Stato Auto-Pilot
        let autoPilotRunning = false;
        let autoPilotLog = [];
        
        // Funzione principale: FA TUTTO AUTOMATICAMENTE
        async function runAutoPilot() {
            if (autoPilotRunning) {
                alert('‚è≥ Auto-Pilot gi√† in esecuzione...');
                return;
            }
            
            autoPilotRunning = true;
            autoPilotLog = [];
            
            // Mostra modal progress
            showAutoPilotModal();
            
            try {
                const steps = [
                    { name: 'üîç Analisi dati', fn: autoPilotAnalyzeData },
                    { name: 'üí∞ Fetch prezzi mancanti', fn: autoPilotFetchPrices },
                    { name: 'üîó Transfer matching', fn: autoPilotTransferMatching },
                    { name: '‚ö†Ô∏è Rileva discrepanze', fn: autoPilotDetectDiscrepancies },
                    { name: 'ü§ñ Risolvi discrepanze', fn: autoPilotResolveDiscrepancies },
                    { name: 'üìä Calcola cost basis', fn: autoPilotCalculateCostBasis },
                    { name: 'üìÖ Calcola valori 31/12', fn: autoPilotCalculateYearEnd },
                    { name: 'üí∂ Calcola IVCA', fn: autoPilotCalculateIVCA },
                    { name: 'üìã Genera report', fn: autoPilotGenerateReport }
                ];
                
                const totalSteps = steps.length;
                
                for (let i = 0; i < steps.length; i++) {
                    const step = steps[i];
                    updateAutoPilotProgress(i + 1, totalSteps, step.name);
                    
                    log(`\n${'‚ïê'.repeat(50)}`);
                    log(`STEP ${i + 1}/${totalSteps}: ${step.name}`);
                    log('‚ïê'.repeat(50));
                    
                    await step.fn();
                    
                    // Piccola pausa per UI
                    await new Promise(r => setTimeout(r, 100));
                }
                
                // Completato!
                updateAutoPilotProgress(totalSteps, totalSteps, '‚úÖ Completato!');
                log('\nüéâ AUTO-PILOT COMPLETATO!');
                
                // Salva tutto
                saveExchangeDataToFirebase();
                saveCostBasisLots();
                
                // Refresh UI
                initExchangeGrid();
                updateExchangeTotals();
                
            } catch (error) {
                log(`\n‚ùå ERRORE: ${error.message}`);
                console.error('Auto-Pilot error:', error);
            } finally {
                autoPilotRunning = false;
            }
            
            function log(msg) {
                autoPilotLog.push(msg);
                updateAutoPilotLog();
                console.log(msg);
            }
        }
        
        // Step 1: Analizza dati disponibili
        async function autoPilotAnalyzeData() {
            const exchanges = Object.keys(exchangeData).filter(id => {
                const data = exchangeData[id];
                return data && (data.transactions?.length > 0 || data.transactionCount > 0);
            });
            
            let totalTx = 0;
            let totalCoins = new Set();
            
            for (const exchId of exchanges) {
                const data = exchangeData[exchId];
                const txCount = data.transactions?.length || 0;
                totalTx += txCount;
                
                if (data.transactions) {
                    for (const tx of data.transactions) {
                        const coin = tx.asset_in || tx.coin;
                        if (coin && coin !== 'EUR' && coin !== 'USD') {
                            totalCoins.add(coin.toUpperCase());
                        }
                    }
                }
                
                autoPilotLog.push(`  üìä ${exchId}: ${txCount} transazioni`);
            }
            
            autoPilotLog.push(`\n  üìà Totale: ${totalTx} transazioni, ${totalCoins.size} coin unici`);
            autoPilotLog.push(`  üì¶ Exchange con dati: ${exchanges.join(', ')}`);
            
            return { exchanges, totalTx, totalCoins: [...totalCoins] };
        }
        
        // Step 2: Fetch prezzi mancanti da CryptoCompare
        async function autoPilotFetchPrices() {
            const allPriceRequests = new Map();
            
            // Raccogli tutte le combinazioni coin+data da tutti gli exchange
            for (const exchId of Object.keys(exchangeData)) {
                const data = exchangeData[exchId];
                if (!data.transactions) continue;
                
                for (const tx of data.transactions) {
                    const coin = (tx.asset_in || tx.coin || '').toUpperCase();
                    if (!coin || coin === 'EUR' || coin === 'USD' || coin.startsWith('LD')) continue;
                    
                    const date = tx.timestamp || tx.date;
                    const d = date instanceof Date ? date : new Date(date);
                    const dateKey = d.toISOString().slice(0, 10);
                    const key = `${coin}_${dateKey}`;
                    
                    // Skip se gi√† in cache
                    if (cryptoComparePriceCache[key]) continue;
                    
                    if (!allPriceRequests.has(key)) {
                        allPriceRequests.set(key, { coin, date: d, dateKey });
                    }
                }
            }
            
            // Aggiungi prezzi 31/12 per ogni anno
            const years = [2021, 2022, 2023, 2024, 2025];
            const allCoins = new Set();
            
            for (const exchId of Object.keys(exchangeData)) {
                const data = exchangeData[exchId];
                if (data.balances) {
                    for (const year of Object.keys(data.balances)) {
                        for (const coin of Object.keys(data.balances[year])) {
                            if (coin !== 'EUR' && coin !== 'USD' && !coin.startsWith('LD')) {
                                allCoins.add(coin.toUpperCase());
                            }
                        }
                    }
                }
            }
            
            for (const coin of allCoins) {
                for (const year of years) {
                    const key = `${coin}_${year}`;
                    if (!cryptoComparePriceCache[key]) {
                        allPriceRequests.set(key, { coin, year, dateKey: `${year}-12-31` });
                    }
                }
            }
            
            const total = allPriceRequests.size;
            autoPilotLog.push(`  üîç ${total} prezzi da recuperare...`);
            
            if (total === 0) {
                autoPilotLog.push(`  ‚úÖ Tutti i prezzi gi√† in cache!`);
                return;
            }
            
            let fetched = 0;
            let errors = 0;
            
            for (const [key, info] of allPriceRequests) {
                let price;
                if (info.year) {
                    price = await fetchCryptoComparePrice(info.coin, info.year);
                } else {
                    price = await fetchCryptoComparePriceForDate(info.coin, info.date);
                }
                
                if (price && price > 0) {
                    fetched++;
                } else {
                    errors++;
                }
                
                // Progress ogni 20
                if ((fetched + errors) % 20 === 0) {
                    autoPilotLog.push(`  ‚è≥ ${fetched + errors}/${total}...`);
                    updateAutoPilotLog();
                }
                
                // Rate limit
                await new Promise(r => setTimeout(r, 50));
            }
            
            autoPilotLog.push(`  ‚úÖ Recuperati ${fetched} prezzi (${errors} non trovati)`);
        }
        
        // Step 3: Transfer matching tra exchange
        async function autoPilotTransferMatching() {
            // Raccogli tutte le transazioni da tutti gli exchange
            const allTransactions = [];
            
            for (const exchId of Object.keys(exchangeData)) {
                const data = exchangeData[exchId];
                if (data.transactions) {
                    for (const tx of data.transactions) {
                        allTransactions.push({ ...tx, source: exchId });
                    }
                }
            }
            
            autoPilotLog.push(`  üîç Analizzando ${allTransactions.length} transazioni...`);
            
            // Match transfers
            const withdrawals = allTransactions.filter(tx => tx.type === 'withdrawal');
            const deposits = allTransactions.filter(tx => tx.type === 'deposit');
            
            let matched = 0;
            const windowMs = 60 * 60 * 1000; // 1 ora
            
            for (const withdrawal of withdrawals) {
                if (withdrawal.linked_tx_id || withdrawal.is_internal) continue;
                
                const wTime = new Date(withdrawal.timestamp || withdrawal.date).getTime();
                const wCoin = (withdrawal.asset_in || withdrawal.coin || '').toUpperCase();
                const wAmount = Math.abs(withdrawal.amount_in || withdrawal.amount || 0);
                
                for (const deposit of deposits) {
                    if (deposit.linked_tx_id || deposit.is_internal) continue;
                    if (deposit.source === withdrawal.source) continue; // Stesso exchange
                    
                    const dTime = new Date(deposit.timestamp || deposit.date).getTime();
                    const dCoin = (deposit.asset_in || deposit.coin || '').toUpperCase();
                    const dAmount = Math.abs(deposit.amount_in || deposit.amount || 0);
                    
                    const timeDiff = Math.abs(dTime - wTime);
                    const amountDiff = Math.abs(wAmount - dAmount) / Math.max(wAmount, dAmount);
                    
                    if (wCoin === dCoin && timeDiff <= windowMs && amountDiff <= 0.05) {
                        // Match!
                        withdrawal.linked_tx_id = deposit.id;
                        withdrawal.is_internal = true;
                        withdrawal.is_taxable = false;
                        
                        deposit.linked_tx_id = withdrawal.id;
                        deposit.is_internal = true;
                        deposit.is_taxable = false;
                        deposit.cost_basis_eur = withdrawal.cost_basis_eur;
                        
                        matched++;
                        autoPilotLog.push(`  üîó ${wCoin}: ${withdrawal.source} ‚Üí ${deposit.source}`);
                        break;
                    }
                }
            }
            
            autoPilotLog.push(`  ‚úÖ Matched ${matched} trasferimenti interni`);
        }
        
        // Step 4: Rileva discrepanze
        async function autoPilotDetectDiscrepancies() {
            let totalIssues = 0;
            
            for (const exchId of Object.keys(exchangeData)) {
                const data = exchangeData[exchId];
                if (!data.realBalances || Object.keys(data.realBalances).length === 0) continue;
                
                const check = zeroSumCheck(data.transactions || [], data.realBalances);
                data.discrepancies = check.issues || [];
                
                if (check.issues.length > 0) {
                    autoPilotLog.push(`  ‚ö†Ô∏è ${exchId}: ${check.issues.length} discrepanze`);
                    totalIssues += check.issues.length;
                }
            }
            
            if (totalIssues === 0) {
                autoPilotLog.push(`  ‚úÖ Nessuna discrepanza rilevata!`);
            } else {
                autoPilotLog.push(`  üìä Totale: ${totalIssues} discrepanze da risolvere`);
            }
        }
        
        // Step 5: Risolvi discrepanze con AI
        async function autoPilotResolveDiscrepancies() {
            let resolved = 0;
            
            for (const exchId of Object.keys(exchangeData)) {
                const data = exchangeData[exchId];
                const issues = data.discrepancies || [];
                
                for (const issue of issues) {
                    // Analisi AI
                    const analysisData = {
                        coin: issue.coin,
                        difference: issue.difference,
                        diffValueEur: Math.abs(issue.difference) * getPriceEur(issue.coin, new Date().getFullYear()),
                        deposits: 0,
                        withdrawals: 0,
                        rewards: 0,
                        lastTx: new Date().toISOString().slice(0, 10)
                    };
                    
                    const analysis = analyzeDiscrepancyHeuristic(analysisData);
                    
                    // Aggiungi transazione
                    addManualTransaction(exchId, {
                        date: new Date(),
                        type: analysis.txType,
                        coin: issue.coin,
                        amount: issue.difference,
                        notes: `Auto-Pilot AI: ${analysis.cause}`
                    });
                    
                    autoPilotLog.push(`  ü§ñ ${exchId}/${issue.coin}: ${analysis.cause}`);
                    resolved++;
                }
                
                // Pulisci discrepanze
                data.discrepancies = [];
            }
            
            autoPilotLog.push(`  ‚úÖ Risolte ${resolved} discrepanze automaticamente`);
        }
        
        // Step 6: Calcola cost basis per tutti i lotti
        async function autoPilotCalculateCostBasis() {
            // Reset lotti
            costBasisLots = [];
            
            // Raccogli tutte le transazioni ordinate
            const allTx = [];
            for (const exchId of Object.keys(exchangeData)) {
                const data = exchangeData[exchId];
                if (data.transactions) {
                    for (const tx of data.transactions) {
                        allTx.push({ ...tx, source: exchId });
                    }
                }
            }
            
            allTx.sort((a, b) => new Date(a.timestamp || a.date) - new Date(b.timestamp || b.date));
            
            let lots = 0;
            
            for (const tx of allTx) {
                const coin = (tx.asset_in || tx.coin || '').toUpperCase();
                if (!coin || coin === 'EUR' || coin === 'USD' || coin.startsWith('LD')) continue;
                
                const change = tx.change || 0;
                const date = tx.timestamp || tx.date;
                
                // Solo acquisti (change > 0)
                if (change > 0 && (tx.type === 'buy' || tx.type === 'deposit' || tx.type === 'reward' || tx.type === 'staking')) {
                    const priceEur = tx.price_eur || getPriceEur(coin, date);
                    if (priceEur > 0) {
                        createLot(date, coin, change, priceEur, tx.source, tx.type);
                        lots++;
                    }
                }
            }
            
            autoPilotLog.push(`  ‚úÖ Creati ${lots} lotti di acquisto`);
            autoPilotLog.push(`  üìä Totale lotti: ${costBasisLots.length}`);
        }
        
        // Step 7: Calcola valori al 31/12
        async function autoPilotCalculateYearEnd() {
            const years = [2021, 2022, 2023, 2024, 2025];
            
            for (const exchId of Object.keys(exchangeData)) {
                const data = exchangeData[exchId];
                if (!data.balances) continue;
                
                for (const year of years) {
                    if (!data.balances[year]) continue;
                    
                    let totalEur = 0;
                    for (const [coin, amount] of Object.entries(data.balances[year])) {
                        if (amount > 0 && !coin.startsWith('LD')) {
                            const priceEur = getPriceEur(coin, year);
                            totalEur += amount * priceEur;
                        }
                    }
                    
                    if (!data.totals) data.totals = {};
                    data.totals[year] = Math.round(totalEur * 100) / 100;
                }
            }
            
            autoPilotLog.push(`  ‚úÖ Calcolati valori 31/12 per ${years.length} anni`);
        }
        
        // Step 8: Calcola IVCA
        async function autoPilotCalculateIVCA() {
            const years = [2024, 2025];
            
            for (const year of years) {
                let totalValue = 0;
                
                for (const exchId of Object.keys(exchangeData)) {
                    const data = exchangeData[exchId];
                    totalValue += data.totals?.[year] || 0;
                }
                
                const ivca = totalValue * 0.002; // 0.2%
                autoPilotLog.push(`  üìÖ ${year}: ‚Ç¨${totalValue.toFixed(2)} ‚Üí IVCA ‚Ç¨${ivca.toFixed(2)}`);
            }
        }
        
        // Step 9: Genera report
        async function autoPilotGenerateReport() {
            // Calcola totali
            let grandTotal2024 = 0;
            let grandTotal2025 = 0;
            
            for (const exchId of Object.keys(exchangeData)) {
                const data = exchangeData[exchId];
                grandTotal2024 += data.totals?.[2024] || 0;
                grandTotal2025 += data.totals?.[2025] || 0;
            }
            
            autoPilotLog.push(`\n  ${'‚îÄ'.repeat(40)}`);
            autoPilotLog.push(`  üìä RIEPILOGO FINALE`);
            autoPilotLog.push(`  ${'‚îÄ'.repeat(40)}`);
            autoPilotLog.push(`  üí∞ Valore 31/12/2024: ‚Ç¨${grandTotal2024.toLocaleString('it-IT')}`);
            autoPilotLog.push(`  üí∞ Valore 31/12/2025: ‚Ç¨${grandTotal2025.toLocaleString('it-IT')}`);
            autoPilotLog.push(`  üí∂ IVCA 2024: ‚Ç¨${(grandTotal2024 * 0.002).toFixed(2)}`);
            autoPilotLog.push(`  üí∂ IVCA 2025: ‚Ç¨${(grandTotal2025 * 0.002).toFixed(2)}`);
            autoPilotLog.push(`  üì¶ Lotti acquisto: ${costBasisLots.length}`);
            autoPilotLog.push(`  ${'‚îÄ'.repeat(40)}`);
        }
        
        // UI Modal Auto-Pilot
        function showAutoPilotModal() {
            let modal = document.getElementById('autoPilotModal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'autoPilotModal';
                modal.className = 'modal active';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width:700px;max-height:90vh;">
                        <div class="modal-header">
                            <h2>ü§ñ Auto-Pilot - Elaborazione Automatica</h2>
                        </div>
                        <div class="modal-body">
                            <div id="autoPilotProgressSection" style="margin-bottom:20px;">
                                <div style="display:flex;justify-content:space-between;margin-bottom:8px;">
                                    <span id="autoPilotStep">Inizializzazione...</span>
                                    <span id="autoPilotPercent">0%</span>
                                </div>
                                <div style="background:var(--bg-primary);border-radius:8px;height:12px;overflow:hidden;">
                                    <div id="autoPilotBar" style="background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);height:100%;width:0%;transition:width 0.3s;"></div>
                                </div>
                            </div>
                            <div id="autoPilotLogSection" style="background:var(--bg-primary);border-radius:8px;padding:16px;max-height:400px;overflow-y:auto;font-family:'SF Mono',Monaco,monospace;font-size:12px;line-height:1.6;">
                                <div id="autoPilotLogContent"></div>
                            </div>
                        </div>
                        <div class="modal-footer" style="padding:16px;border-top:1px solid var(--border);display:flex;justify-content:center;">
                            <button id="autoPilotCloseBtn" class="btn btn-secondary" onclick="document.getElementById('autoPilotModal').classList.remove('active')" style="padding:12px 24px;" disabled>
                                Chiudi
                            </button>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
            } else {
                modal.classList.add('active');
            }
            
            document.getElementById('autoPilotCloseBtn').disabled = true;
            document.getElementById('autoPilotLogContent').innerHTML = '';
        }
        
        function updateAutoPilotProgress(current, total, stepName) {
            const percent = Math.round((current / total) * 100);
            document.getElementById('autoPilotStep').textContent = stepName;
            document.getElementById('autoPilotPercent').textContent = percent + '%';
            document.getElementById('autoPilotBar').style.width = percent + '%';
            
            if (current >= total) {
                document.getElementById('autoPilotCloseBtn').disabled = false;
            }
        }
        
        function updateAutoPilotLog() {
            const content = document.getElementById('autoPilotLogContent');
            if (content) {
                content.innerHTML = autoPilotLog.map(line => {
                    if (line.includes('STEP') || line.includes('‚ïê')) {
                        return `<div style="color:var(--accent);font-weight:bold;">${line}</div>`;
                    } else if (line.includes('‚úÖ')) {
                        return `<div style="color:var(--green);">${line}</div>`;
                    } else if (line.includes('‚ùå') || line.includes('‚ö†Ô∏è')) {
                        return `<div style="color:var(--yellow);">${line}</div>`;
                    } else if (line.includes('üéâ')) {
                        return `<div style="color:var(--green);font-weight:bold;font-size:14px;">${line}</div>`;
                    } else {
                        return `<div>${line}</div>`;
                    }
                }).join('');
                content.scrollTop = content.scrollHeight;
            }
        }
        
        // ==================== END AUTO-PILOT MODE ====================
        
        // Fetch prezzi mancanti da CryptoCompare
        async function fetchMissingPrices() {
            const btn = event.target;
            const originalText = btn.innerHTML;
            btn.innerHTML = '‚è≥ Fetching...';
            btn.disabled = true;
            
            try {
                // Raccogli tutti i token da tutti gli exchange
                const allTokensByYear = {};
                const years = [2021, 2022, 2023, 2024, 2025, 2026];
                
                for (const year of years) {
                    allTokensByYear[year] = new Set();
                }
                
                for (const exchId of Object.keys(exchangeData)) {
                    const data = exchangeData[exchId];
                    if (data.balances) {
                        for (const year of Object.keys(data.balances)) {
                            for (const coin of Object.keys(data.balances[year])) {
                                const amount = data.balances[year][coin];
                                if (Math.abs(amount) > 0.0001) {
                                    allTokensByYear[year]?.add(coin.toUpperCase());
                                }
                            }
                        }
                    }
                }
                
                // Lista stablecoin da escludere (prezzo fisso)
                const SKIP_TOKENS = ['USDT', 'USDC', 'BUSD', 'DAI', 'TUSD', 'FDUSD', 'EUR', 'USD', 'EURT', 'EUROC'];
                
                let totalFetched = 0;
                let totalMissing = 0;
                
                for (const year of years) {
                    const tokens = [...allTokensByYear[year]].filter(t => !SKIP_TOKENS.includes(t));
                    
                    for (const token of tokens) {
                        // Controlla se gi√† abbiamo il prezzo
                        const cacheKey = `${token}_${year}`;
                        if (cryptoComparePriceCache[cacheKey]) continue;
                        
                        // Controlla se CoinGecko ce l'ha
                        const cgPrice = getHistoricalPrice(token, year);
                        if (cgPrice > 0) continue;
                        
                        // Fetch da CryptoCompare
                        totalMissing++;
                        btn.innerHTML = `‚è≥ ${token} ${year}...`;
                        
                        const price = await fetchCryptoComparePrice(token, year);
                        if (price && price > 0) {
                            totalFetched++;
                        }
                        
                        // Rate limit: aspetta 100ms tra richieste
                        await new Promise(r => setTimeout(r, 100));
                    }
                }
                
                // Ricalcola i totali per tutti gli exchange
                for (const exchId of Object.keys(exchangeData)) {
                    if (exchangeData[exchId].transactions?.length > 0) {
                        calculateExchangeBalances(exchId);
                    }
                }
                
                updateExchangeTotals();
                
                if (totalFetched > 0) {
                    alert(`‚úÖ Recuperati ${totalFetched} prezzi storici da CryptoCompare!\n\nI valori sono stati ricalcolati.`);
                } else if (totalMissing === 0) {
                    alert('‚úÖ Tutti i prezzi sono gi√† disponibili!');
                } else {
                    alert(`‚ö†Ô∏è ${totalMissing} token non trovati su CryptoCompare.\n\nAlcuni token potrebbero essere troppo nuovi o non listati.`);
                }
                
            } catch (err) {
                console.error('Fetch missing prices error:', err);
                alert('‚ùå Errore: ' + err.message);
            } finally {
                btn.innerHTML = originalText;
                btn.disabled = false;
            }
        }
        
        // Fetch prezzo per data specifica (per transazioni)
        async function fetchCryptoComparePriceForDate(symbol, date) {
            const symUpper = symbol.toUpperCase();
            const d = date instanceof Date ? date : new Date(date);
            const timestamp = Math.floor(d.getTime() / 1000);
            const dateKey = d.toISOString().slice(0, 10); // YYYY-MM-DD
            const cacheKey = `${symUpper}_${dateKey}`;
            
            // Check cache
            if (cryptoComparePriceCache[cacheKey]) {
                return cryptoComparePriceCache[cacheKey];
            }
            
            // Skip stablecoins
            const STABLECOINS = ['USDT', 'USDC', 'BUSD', 'DAI', 'TUSD', 'EUR', 'USD', 'FDUSD'];
            if (STABLECOINS.includes(symUpper)) {
                return symUpper === 'EUR' ? 1 : EUR_USD;
            }
            
            try {
                const url = `https://min-api.cryptocompare.com/data/pricehistorical?fsym=${symUpper}&tsyms=EUR&ts=${timestamp}`;
                
                const response = await fetch(url);
                if (!response.ok) return null;
                
                const data = await response.json();
                
                if (data[symUpper] && data[symUpper].EUR) {
                    const price = data[symUpper].EUR;
                    cryptoComparePriceCache[cacheKey] = price;
                    saveCryptoCompareCache();
                    return price;
                }
            } catch (err) {
                console.warn(`CryptoCompare date price error for ${symUpper}:`, err.message);
            }
            
            return null;
        }
        
        // Fetch prezzi per tutte le transazioni dell'exchange corrente
        async function fetchTransactionPrices() {
            const btn = event?.target;
            if (btn) {
                btn.innerHTML = '‚è≥ Fetching...';
                btn.disabled = true;
            }
            
            const exchData = exchangeData[currentDetailExchange];
            if (!exchData || !exchData.transactions || exchData.transactions.length === 0) {
                alert('Nessuna transazione da elaborare');
                if (btn) { btn.innerHTML = 'üí∞ Fetch Prezzi'; btn.disabled = false; }
                return;
            }
            
            // Raccogli tutte le combinazioni token+data uniche
            const toFetch = new Map();
            
            for (const tx of exchData.transactions) {
                if (!tx.coin || tx.coin === 'EUR' || tx.coin === 'USD') continue;
                if (tx.coin.startsWith('LD')) continue; // Skip LD* tokens
                
                const d = tx.date instanceof Date ? tx.date : new Date(tx.date);
                const dateKey = d.toISOString().slice(0, 10);
                const mapKey = `${tx.coin.toUpperCase()}_${dateKey}`;
                
                // Skip se gi√† in cache
                if (cryptoComparePriceCache[mapKey]) continue;
                
                if (!toFetch.has(mapKey)) {
                    toFetch.set(mapKey, { coin: tx.coin.toUpperCase(), date: d, dateKey });
                }
            }
            
            if (toFetch.size === 0) {
                alert('‚úÖ Tutti i prezzi sono gi√† in cache!');
                if (btn) { btn.innerHTML = 'üí∞ Fetch Prezzi'; btn.disabled = false; }
                renderExchDetailTxTable();
                return;
            }
            
            console.log(`üîç Fetching prezzi per ${toFetch.size} combinazioni coin/data...`);
            
            let fetched = 0;
            let errors = 0;
            const total = toFetch.size;
            
            for (const [key, info] of toFetch) {
                if (btn) {
                    btn.innerHTML = `‚è≥ ${fetched}/${total}`;
                }
                
                const price = await fetchCryptoComparePriceForDate(info.coin, info.date);
                if (price && price > 0) {
                    fetched++;
                    console.log(`‚úÖ ${info.coin} @ ${info.dateKey}: ‚Ç¨${price.toFixed(6)}`);
                } else {
                    errors++;
                    console.log(`‚ùå ${info.coin} @ ${info.dateKey}: non trovato`);
                }
                
                // Rate limit: 80ms tra richieste
                await new Promise(r => setTimeout(r, 80));
            }
            
            // Refresh tabella transazioni
            renderExchDetailTxTable();
            
            if (btn) {
                btn.innerHTML = 'üí∞ Fetch Prezzi';
                btn.disabled = false;
            }
            
            alert(`‚úÖ Completato!\n\n‚úì ${fetched} prezzi recuperati\n‚úó ${errors} non trovati\n\nI valori nelle transazioni sono stati aggiornati.`);
        }
        
        // ==================== COINGECKO PRICE FETCHER ====================
        
        // Cache prezzi CoinGecko
        let coinGeckoPriceCache = JSON.parse(localStorage.getItem('cryptofolio_cg_prices') || '{}');
        let coinGeckoIdMap = JSON.parse(localStorage.getItem('cryptofolio_cg_ids') || '{}');
        
        // Mapping esteso symbol ‚Üí CoinGecko ID
        const EXTENDED_CG_MAP = {
            // Top coins
            'BTC': 'bitcoin', 'ETH': 'ethereum', 'BNB': 'binancecoin', 'SOL': 'solana',
            'XRP': 'ripple', 'ADA': 'cardano', 'DOGE': 'dogecoin', 'DOT': 'polkadot',
            'MATIC': 'matic-network', 'LINK': 'chainlink', 'AVAX': 'avalanche-2',
            'SHIB': 'shiba-inu', 'LTC': 'litecoin', 'BCH': 'bitcoin-cash',
            // Stablecoins
            'USDT': 'tether', 'USDC': 'usd-coin', 'BUSD': 'binance-usd', 'DAI': 'dai',
            'FDUSD': 'first-digital-usd', 'TUSD': 'true-usd',
            // Layer 1
            'TRX': 'tron', 'TON': 'the-open-network', 'ATOM': 'cosmos', 'ALGO': 'algorand',
            'EOS': 'eos', 'XLM': 'stellar', 'VET': 'vechain', 'NEO': 'neo', 'ETC': 'ethereum-classic',
            'FIL': 'filecoin', 'HBAR': 'hedera-hashgraph', 'ICP': 'internet-computer',
            // Layer 2
            'ARB': 'arbitrum', 'OP': 'optimism', 'IMX': 'immutable-x',
            // DeFi
            'UNI': 'uniswap', 'AAVE': 'aave', 'CAKE': 'pancakeswap-token', '1INCH': '1inch',
            'SUSHI': 'sushi', 'CRV': 'curve-dao-token', 'COMP': 'compound-governance-token',
            'MKR': 'maker', 'SNX': 'synthetix-network-token', 'LDO': 'lido-dao',
            'PENDLE': 'pendle', 'RDNT': 'radiant-capital',
            // Meme
            'PEPE': 'pepe', 'FLOKI': 'floki', 'BONK': 'bonk', 'WIF': 'dogwifcoin',
            'BONE': 'bone-shibaswap', '1MBABYDOGE': 'baby-doge-coin',
            // Telegram/TON
            'NOT': 'notcoin', 'DOGS': 'dogs-2', 'HMSTR': 'hamster-kombat', 'CATI': 'catizen',
            // Gaming
            'SAND': 'the-sandbox', 'MANA': 'decentraland', 'AXS': 'axie-infinity',
            'GALA': 'gala', 'ENJ': 'enjincoin', 'HIGH': 'highstreet',
            // Exchange
            'CRO': 'crypto-com-chain', 'KCS': 'kucoin-shares', 'GT': 'gate-token',
            // Terra
            'LUNC': 'terra-luna', 'LUNA': 'terra-luna-2', 'USTC': 'terrausd',
            // Others
            'KSM': 'kusama', 'QTUM': 'qtum', 'APE': 'apecoin', 'CHZ': 'chiliz',
            'BAT': 'basic-attention-token', 'ZEN': 'horizen', 'WRX': 'wazirx',
            'BAKE': 'bakerytoken', 'GAL': 'galxe', 'CYBER': 'cyberconnect',
            'SEI': 'sei-network', 'INJ': 'injective-protocol', 'SUI': 'sui',
            'APT': 'aptos', 'NEAR': 'near', 'FTM': 'fantom', 'KAVA': 'kava',
            // Fan tokens
            'SANTOS': 'santos-fc-fan-token', 'CITY': 'manchester-city-fan-token',
            'PSG': 'paris-saint-germain-fan-token', 'BAR': 'fc-barcelona-fan-token',
            // AI
            'AI': 'sleepless-ai', 'FET': 'fetch-ai', 'AGIX': 'singularitynet',
            // More Binance coins
            'MC': 'merit-circle', 'DAR': 'mines-of-dalarnia', 'COCOS': 'cocos-bcx',
            'NFP': 'nfprompt', 'MEME': 'memecoin', 'HFT': 'hashflow',
            'QI': 'benqi', 'IO': 'io-net', 'ZRO': 'layerzero',
        };
        
        async function fetchCoinGeckoPrices(symbols) {
            // Converti symbols in CoinGecko IDs
            const ids = [];
            const symbolToId = {};
            
            for (const sym of symbols) {
                const symUpper = sym.toUpperCase();
                const cgId = EXTENDED_CG_MAP[symUpper] || coinGeckoIdMap[symUpper];
                if (cgId) {
                    ids.push(cgId);
                    symbolToId[cgId] = symUpper;
                }
            }
            
            if (ids.length === 0) return {};
            
            // Batch in gruppi di 100 (limite CoinGecko)
            const results = {};
            const batchSize = 100;
            
            for (let i = 0; i < ids.length; i += batchSize) {
                const batch = ids.slice(i, i + batchSize);
                try {
                    const url = `https://api.coingecko.com/api/v3/simple/price?ids=${batch.join(',')}&vs_currencies=eur,usd`;
                    console.log('Fetching CoinGecko prices for', batch.length, 'coins...');
                    
                    const response = await fetch(url);
                    if (!response.ok) {
                        console.warn('CoinGecko API error:', response.status);
                        continue;
                    }
                    
                    const data = await response.json();
                    
                    for (const [cgId, prices] of Object.entries(data)) {
                        const symbol = symbolToId[cgId];
                        if (symbol && prices.eur) {
                            results[symbol] = {
                                eur: prices.eur,
                                usd: prices.usd || prices.eur / EUR_USD,
                                fetchedAt: Date.now()
                            };
                        }
                    }
                    
                    // Rate limit: aspetta 1.5s tra le batch (CoinGecko free = 30 calls/min)
                    if (i + batchSize < ids.length) {
                        await new Promise(r => setTimeout(r, 1500));
                    }
                } catch (err) {
                    console.error('CoinGecko fetch error:', err);
                }
            }
            
            // Salva in cache
            Object.assign(coinGeckoPriceCache, results);
            localStorage.setItem('cryptofolio_cg_prices', JSON.stringify(coinGeckoPriceCache));
            
            console.log('‚úÖ Fetched', Object.keys(results).length, 'prices from CoinGecko');
            return results;
        }
        
        function getCachedPrice(symbol) {
            const symUpper = symbol.toUpperCase();
            const cached = coinGeckoPriceCache[symUpper];
            
            // Cache valida per 1 ora
            if (cached && (Date.now() - cached.fetchedAt) < 3600000) {
                return cached.eur;
            }
            return null;
        }
        
        async function updateAllPrices() {
            // Raccogli tutti i token da tutti gli exchange
            const allTokens = new Set();
            
            for (const exchId of Object.keys(exchangeData)) {
                const data = exchangeData[exchId];
                if (data.balances) {
                    for (const year of Object.keys(data.balances)) {
                        for (const coin of Object.keys(data.balances[year])) {
                            if (Math.abs(data.balances[year][coin]) > 0.0001) {
                                allTokens.add(coin);
                            }
                        }
                    }
                }
                if (data.transactions) {
                    for (const tx of data.transactions) {
                        allTokens.add(tx.coin);
                    }
                }
            }
            
            console.log('üîÑ Updating prices for', allTokens.size, 'tokens...');
            
            const prices = await fetchCoinGeckoPrices([...allTokens]);
            
            return prices;
        }
        
        // ==================== END COINGECKO PRICE FETCHER ====================
        
        // ==================== COST BASIS TRACKING SYSTEM ====================
        
        // Database dei lotti di acquisto
        // Ogni lotto: { id, date, coin, amount, priceEur, costEur, source, status, linkedTo }
        let costBasisLots = JSON.parse(localStorage.getItem('cryptofolio_costbasis') || '[]');
        let lotIdCounter = parseInt(localStorage.getItem('cryptofolio_lotcounter') || '1');
        
        function saveCostBasis() {
            localStorage.setItem('cryptofolio_costbasis', JSON.stringify(costBasisLots));
            localStorage.setItem('cryptofolio_lotcounter', lotIdCounter.toString());
        }
        
        // Alias per compatibilit√†
        const saveCostBasisLots = saveCostBasis;
        
        function createLot(date, coin, amount, priceEur, source, txType = 'buy') {
            const lot = {
                id: lotIdCounter++,
                date: date instanceof Date ? date.toISOString() : date,
                coin: coin.toUpperCase(),
                amount: Math.abs(amount),
                priceEur: priceEur,
                costEur: Math.abs(amount) * priceEur,
                source: source, // 'binance', 'bitpanda', etc.
                status: 'held', // 'held', 'withdrawn', 'sold', 'transferred'
                txType: txType, // 'buy', 'reward', 'airdrop'
                linkedTo: null, // Per collegare withdraw ‚Üí deposit
                createdAt: new Date().toISOString()
            };
            
            costBasisLots.push(lot);
            console.log(`üì¶ Lotto #${lot.id}: ${lot.amount.toFixed(4)} ${lot.coin} @ ‚Ç¨${priceEur.toFixed(6)} = ‚Ç¨${lot.costEur.toFixed(2)} (${source})`);
            
            return lot;
        }
        
        // Estrae cost basis da transazioni di qualsiasi exchange
        function extractCostBasisFromTransactions(exchangeId) {
            const exchData = exchangeData[exchangeId];
            if (!exchData || !exchData.transactions) {
                return { lots: 0, skipped: 0 };
            }
            
            // Rimuovi lotti esistenti per questo exchange
            costBasisLots = costBasisLots.filter(lot => lot.source !== exchangeId);
            
            const transactions = exchData.transactions;
            let lots = 0;
            let skipped = 0;
            
            // Tipi che creano lotti
            const acquireTypes = ['buy', 'deposit', 'reward', 'staking', 'interest', 'dividend', 'airdrop', 'refund'];
            
            for (const tx of transactions) {
                const coin = (tx.asset_in || tx.coin || '').toUpperCase();
                if (!coin || coin === 'EUR' || coin === 'USD' || coin.startsWith('LD')) {
                    continue;
                }
                
                const change = tx.change || 0;
                const amount = Math.abs(tx.amount_in || tx.amount || change);
                
                // Solo transazioni positive (acquisizioni)
                if (change <= 0 || amount <= 0) continue;
                
                // Skip transfer interni (non cambiano cost basis totale)
                if (tx.is_internal) continue;
                
                // Controlla tipo
                const type = tx.type || 'unknown';
                if (!acquireTypes.includes(type) && change <= 0) continue;
                
                // Ottieni prezzo
                const txDate = tx.timestamp || tx.date;
                let priceEur = tx.price_eur || tx.priceEur;
                
                if (!priceEur || priceEur <= 0) {
                    priceEur = getPriceEur(coin, txDate);
                }
                
                if (!priceEur || priceEur <= 0) {
                    skipped++;
                    continue;
                }
                
                // Verifica duplicati
                const txDateStr = txDate instanceof Date ? txDate.toISOString() : txDate;
                const exists = costBasisLots.find(lot => 
                    lot.source === exchangeId &&
                    lot.coin === coin &&
                    Math.abs(lot.amount - amount) < 0.00001 &&
                    lot.date === txDateStr
                );
                
                if (exists) {
                    skipped++;
                    continue;
                }
                
                // Crea lotto
                createLot(txDate, coin, amount, priceEur, exchangeId, type);
                lots++;
            }
            
            console.log(`üì¶ ${exchangeId}: ${lots} lotti creati, ${skipped} skippati`);
            return { lots, skipped };
        }
        
        function calculateCostBasisFromBinance(transactions) {
            console.log('\nüí∞ CALCOLO COST BASIS DA BINANCE (solo EUR reali)...');
            
            // Reset lotti Binance esistenti
            costBasisLots = costBasisLots.filter(lot => lot.source !== 'binance');
            
            // Ordina per data
            const sorted = [...transactions].sort((a, b) => a.date - b.date);
            
            // Raggruppa per timestamp (stesso secondo = stessa operazione)
            const grouped = {};
            for (const tx of sorted) {
                const key = tx.date.toISOString().slice(0, 19); // Fino ai secondi
                if (!grouped[key]) grouped[key] = [];
                grouped[key].push(tx);
            }
            
            let lotsCreated = 0;
            let totalCostBasis = 0;
            
            for (const [timestamp, txGroup] of Object.entries(grouped)) {
                // Trova SOLO transazioni EUR in uscita (non stablecoin!)
                const eurPayments = txGroup.filter(tx => 
                    tx.coin === 'EUR' && tx.change < 0
                );
                
                if (eurPayments.length === 0) continue; // Skip se non c'√® EUR
                
                // Trova crypto in entrata
                const cryptoIn = txGroup.filter(tx => 
                    tx.change > 0 && 
                    !['EUR', 'USD'].includes(tx.coin) &&
                    tx.type !== 'reward' && tx.type !== 'airdrop' && tx.type !== 'deposit'
                );
                
                if (cryptoIn.length === 0) continue;
                
                // Calcola totale EUR speso
                let totalEurSpent = 0;
                for (const p of eurPayments) {
                    totalEurSpent += Math.abs(p.change);
                }
                
                // Calcola totale quantit√† crypto
                let totalCryptoAmount = 0;
                for (const c of cryptoIn) {
                    totalCryptoAmount += c.change;
                }
                
                // Crea lotto per ogni crypto acquistata
                for (const crypto of cryptoIn) {
                    // Proporzione del costo
                    const proportion = crypto.change / totalCryptoAmount;
                    const costEur = totalEurSpent * proportion;
                    const priceEur = costEur / crypto.change;
                    
                    // Verifica se esiste gi√† un lotto simile
                    const exists = costBasisLots.find(lot => 
                        lot.coin === crypto.coin.toUpperCase() &&
                        lot.date === crypto.date.toISOString() &&
                        Math.abs(lot.amount - crypto.change) < 0.0001
                    );
                    
                    if (!exists && costEur > 0.01) {
                        createLot(crypto.date, crypto.coin, crypto.change, priceEur, 'binance', 'buy');
                        lotsCreated++;
                        totalCostBasis += costEur;
                    }
                }
            }
            
            // Gestisci anche "Buy Crypto With Card" e "Fiat Deposit" seguiti da acquisto
            for (const [timestamp, txGroup] of Object.entries(grouped)) {
                const cardBuys = txGroup.filter(tx => 
                    tx.operation?.toLowerCase().includes('buy crypto with')
                );
                
                for (const tx of cardBuys) {
                    if (tx.coin === 'EUR' && tx.change < 0) {
                        // Trova la crypto corrispondente
                        const cryptoTx = txGroup.find(t => 
                            t.coin !== 'EUR' && t.change > 0
                        );
                        
                        if (cryptoTx) {
                            const costEur = Math.abs(tx.change);
                            const priceEur = costEur / cryptoTx.change;
                            
                            const exists = costBasisLots.find(lot => 
                                lot.coin === cryptoTx.coin.toUpperCase() &&
                                Math.abs(new Date(lot.date).getTime() - cryptoTx.date.getTime()) < 5000
                            );
                            
                            if (!exists && costEur > 0.01) {
                                createLot(cryptoTx.date, cryptoTx.coin, cryptoTx.change, priceEur, 'binance', 'buy');
                                lotsCreated++;
                                totalCostBasis += costEur;
                            }
                        }
                    }
                }
            }
            
            saveCostBasis();
            console.log(`‚úÖ Cost Basis: ${lotsCreated} lotti creati, totale EUR investiti: ‚Ç¨${totalCostBasis.toFixed(2)}`);
            
            return { lotsCreated, totalCostBasis };
        }
        
        function calculateCostBasisFromBitpanda(transactions) {
            console.log('\nüí∞ CALCOLO COST BASIS DA BITPANDA...');
            
            // Reset lotti Bitpanda esistenti
            costBasisLots = costBasisLots.filter(lot => lot.source !== 'bitpanda');
            
            let lotsCreated = 0;
            let totalCostBasis = 0;
            
            for (const tx of transactions) {
                if (tx.type === 'buy' && tx.priceEur && tx.priceEur > 0) {
                    // Bitpanda ha gi√† il prezzo nel CSV!
                    const exists = costBasisLots.find(lot => 
                        lot.coin === tx.coin.toUpperCase() &&
                        lot.date === tx.date.toISOString() &&
                        Math.abs(lot.amount - tx.amount) < 0.0001
                    );
                    
                    if (!exists) {
                        createLot(tx.date, tx.coin, tx.amount, tx.priceEur, 'bitpanda', 'buy');
                        lotsCreated++;
                        totalCostBasis += tx.amount * tx.priceEur;
                    }
                }
                
                // Rewards
                if (tx.type === 'reward' && tx.amount > 0) {
                    const exists = costBasisLots.find(lot => 
                        lot.coin === tx.coin.toUpperCase() &&
                        lot.date === tx.date.toISOString() &&
                        lot.txType === 'reward'
                    );
                    
                    if (!exists) {
                        const rewardPrice = tx.priceEur || 0;
                        createLot(tx.date, tx.coin, tx.amount, rewardPrice, 'bitpanda', 'reward');
                        lotsCreated++;
                    }
                }
            }
            
            saveCostBasis();
            console.log(`‚úÖ Cost Basis Bitpanda: ${lotsCreated} lotti, totale: ‚Ç¨${totalCostBasis.toFixed(2)}`);
            
            return { lotsCreated, totalCostBasis };
        }
        
        function linkWithdrawToDeposit(withdrawTx, depositTx) {
            // Cerca lotti del coin che sono stati "withdrawn"
            const lots = costBasisLots.filter(lot => 
                lot.coin === withdrawTx.coin.toUpperCase() &&
                lot.status === 'held' &&
                lot.source === 'binance'
            );
            
            // FIFO: prendi i lotti pi√π vecchi prima
            lots.sort((a, b) => new Date(a.date) - new Date(b.date));
            
            let amountToLink = Math.abs(withdrawTx.change);
            
            for (const lot of lots) {
                if (amountToLink <= 0) break;
                
                if (lot.amount <= amountToLink) {
                    // Tutto il lotto √® stato trasferito
                    lot.status = 'transferred';
                    lot.linkedTo = depositTx?.source || 'wallet';
                    amountToLink -= lot.amount;
                } else {
                    // Solo parte del lotto - split
                    const transferredAmount = amountToLink;
                    const remainingAmount = lot.amount - transferredAmount;
                    
                    // Aggiorna lotto originale
                    lot.amount = remainingAmount;
                    lot.costEur = remainingAmount * lot.priceEur;
                    
                    // Crea nuovo lotto per la parte trasferita
                    const newLot = {
                        ...lot,
                        id: lotIdCounter++,
                        amount: transferredAmount,
                        costEur: transferredAmount * lot.priceEur,
                        status: 'transferred',
                        linkedTo: depositTx?.source || 'wallet'
                    };
                    costBasisLots.push(newLot);
                    
                    amountToLink = 0;
                }
            }
            
            saveCostBasis();
        }
        
        function getCostBasisForCoin(coin, source = null) {
            const coinUpper = coin.toUpperCase();
            
            let lots = costBasisLots.filter(lot => 
                lot.coin === coinUpper && 
                (lot.status === 'held' || lot.status === 'transferred')
            );
            
            if (source) {
                lots = lots.filter(lot => lot.source === source || lot.linkedTo === source);
            }
            
            const totalAmount = lots.reduce((sum, lot) => sum + lot.amount, 0);
            const totalCost = lots.reduce((sum, lot) => sum + lot.costEur, 0);
            const avgPrice = totalAmount > 0 ? totalCost / totalAmount : 0;
            
            return {
                coin: coinUpper,
                totalAmount,
                totalCost,
                avgPrice,
                lots: lots.length
            };
        }
        
        function getCostBasisSummary() {
            const summary = {};
            
            for (const lot of costBasisLots) {
                if (!summary[lot.coin]) {
                    summary[lot.coin] = {
                        totalAmount: 0,
                        totalCost: 0,
                        lots: 0,
                        bySource: {}
                    };
                }
                
                summary[lot.coin].totalAmount += lot.amount;
                summary[lot.coin].totalCost += lot.costEur;
                summary[lot.coin].lots++;
                
                if (!summary[lot.coin].bySource[lot.source]) {
                    summary[lot.coin].bySource[lot.source] = { amount: 0, cost: 0 };
                }
                summary[lot.coin].bySource[lot.source].amount += lot.amount;
                summary[lot.coin].bySource[lot.source].cost += lot.costEur;
            }
            
            // Calcola prezzo medio
            for (const coin of Object.keys(summary)) {
                summary[coin].avgPrice = summary[coin].totalAmount > 0 
                    ? summary[coin].totalCost / summary[coin].totalAmount 
                    : 0;
            }
            
            return summary;
        }
        
        function calculateProfitLoss(coin, sellAmount, sellPriceEur, method = 'FIFO') {
            const coinUpper = coin.toUpperCase();
            
            // Trova lotti disponibili
            let lots = costBasisLots.filter(lot => 
                lot.coin === coinUpper && 
                lot.status === 'held' &&
                lot.amount > 0
            );
            
            // Ordina per FIFO o LIFO
            if (method === 'FIFO') {
                lots.sort((a, b) => new Date(a.date) - new Date(b.date));
            } else {
                lots.sort((a, b) => new Date(b.date) - new Date(a.date));
            }
            
            let remainingToSell = sellAmount;
            let totalCostBasis = 0;
            const lotsUsed = [];
            
            for (const lot of lots) {
                if (remainingToSell <= 0) break;
                
                const amountFromLot = Math.min(lot.amount, remainingToSell);
                const costFromLot = amountFromLot * lot.priceEur;
                
                totalCostBasis += costFromLot;
                remainingToSell -= amountFromLot;
                
                lotsUsed.push({
                    lotId: lot.id,
                    amount: amountFromLot,
                    costBasis: costFromLot,
                    priceEur: lot.priceEur,
                    date: lot.date
                });
            }
            
            const sellValue = sellAmount * sellPriceEur;
            const profitLoss = sellValue - totalCostBasis;
            
            return {
                coin: coinUpper,
                sellAmount,
                sellPriceEur,
                sellValue,
                costBasis: totalCostBasis,
                profitLoss,
                isGain: profitLoss > 0,
                taxableAmount: profitLoss > 0 ? profitLoss * 0.26 : 0, // 26% tasse
                method,
                lotsUsed
            };
        }
        
        function clearCostBasis() {
            if (confirm('‚ö†Ô∏è Vuoi cancellare tutto lo storico Cost Basis?\n\nQuesta azione √® irreversibile!')) {
                costBasisLots = [];
                lotIdCounter = 1;
                saveCostBasis();
                alert('‚úÖ Cost Basis cancellato!');
            }
        }
        
        // ==================== END COST BASIS TRACKING ====================
        
        // ==================== TRANSFER MATCHING (PONTE) ====================
        
        // Finestra temporale per matching (30 minuti)
        const TRANSFER_MATCH_WINDOW_MS = 30 * 60 * 1000;
        
        // Database trasferimenti riconosciuti
        let recognizedTransfers = JSON.parse(localStorage.getItem('cryptofolio_transfers') || '[]');
        
        function findMatchingTransfers(allTransactions) {
            console.log('\nüîó TRANSFER MATCHING - Ricerca spostamenti interni...');
            
            const matches = [];
            
            // Separa withdraw e deposit
            const withdrawals = allTransactions.filter(tx => 
                tx.type === 'withdrawal' && tx.change < 0
            );
            
            const deposits = allTransactions.filter(tx => 
                tx.type === 'deposit' && tx.change > 0
            );
            
            console.log(`  üì§ Withdrawals: ${withdrawals.length}`);
            console.log(`  üì• Deposits: ${deposits.length}`);
            
            // Per ogni withdrawal, cerca deposit corrispondente
            for (const withdraw of withdrawals) {
                const withdrawTime = new Date(withdraw.date).getTime();
                const withdrawAmount = Math.abs(withdraw.change);
                
                // Cerca deposit con:
                // 1. Stessa coin
                // 2. Stessa quantit√† (¬±1% per fee)
                // 3. Entro 30 minuti DOPO il withdraw
                const matchingDeposit = deposits.find(dep => {
                    if (dep._matched) return false; // Gi√† accoppiato
                    
                    const depTime = new Date(dep.date).getTime();
                    const depAmount = Math.abs(dep.change);
                    
                    const sameCoim = dep.coin.toUpperCase() === withdraw.coin.toUpperCase();
                    const similarAmount = Math.abs(depAmount - withdrawAmount) / withdrawAmount < 0.01; // ¬±1%
                    const withinWindow = depTime >= withdrawTime && depTime <= withdrawTime + TRANSFER_MATCH_WINDOW_MS;
                    const differentSource = dep.source !== withdraw.source;
                    
                    return sameCoim && similarAmount && withinWindow && differentSource;
                });
                
                if (matchingDeposit) {
                    matchingDeposit._matched = true;
                    
                    const transfer = {
                        id: `TRF_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`,
                        coin: withdraw.coin.toUpperCase(),
                        amount: withdrawAmount,
                        from: withdraw.source,
                        to: matchingDeposit.source || 'wallet',
                        withdrawDate: withdraw.date,
                        depositDate: matchingDeposit.date,
                        withdrawTx: withdraw,
                        depositTx: matchingDeposit
                    };
                    
                    matches.push(transfer);
                    
                    console.log(`  ‚úÖ Match: ${withdrawAmount.toFixed(4)} ${withdraw.coin} | ${withdraw.source} ‚Üí ${transfer.to}`);
                }
            }
            
            // Salva trasferimenti riconosciuti
            recognizedTransfers = [...recognizedTransfers, ...matches];
            localStorage.setItem('cryptofolio_transfers', JSON.stringify(recognizedTransfers));
            
            console.log(`üîó Transfer Matching completato: ${matches.length} trasferimenti trovati`);
            
            return matches;
        }
        
        function linkCostBasisToTransfer(transfer) {
            // Trova lotti del coin dalla sorgente
            const lots = costBasisLots.filter(lot => 
                lot.coin === transfer.coin &&
                lot.source === transfer.from &&
                lot.status === 'held'
            );
            
            // FIFO: prendi i pi√π vecchi
            lots.sort((a, b) => new Date(a.date) - new Date(b.date));
            
            let remaining = transfer.amount;
            
            for (const lot of lots) {
                if (remaining <= 0) break;
                
                if (lot.amount <= remaining) {
                    // Tutto il lotto si sposta
                    lot.status = 'transferred';
                    lot.linkedTo = transfer.to;
                    lot.transferId = transfer.id;
                    remaining -= lot.amount;
                    
                    // Crea nuovo lotto nel wallet di destinazione con stesso cost basis
                    const newLot = {
                        ...lot,
                        id: lotIdCounter++,
                        source: transfer.to,
                        status: 'held',
                        transferredFrom: lot.id,
                        transferDate: transfer.depositDate
                    };
                    costBasisLots.push(newLot);
                } else {
                    // Split del lotto
                    const transferAmount = remaining;
                    const transferCost = lot.priceEur * transferAmount;
                    
                    // Aggiorna lotto originale
                    lot.amount -= transferAmount;
                    lot.costEur = lot.amount * lot.priceEur;
                    
                    // Crea lotto trasferito
                    const newLot = {
                        id: lotIdCounter++,
                        coin: lot.coin,
                        amount: transferAmount,
                        priceEur: lot.priceEur,
                        costEur: transferCost,
                        date: lot.date,
                        source: transfer.to,
                        status: 'held',
                        txType: lot.txType,
                        transferredFrom: lot.id,
                        transferDate: transfer.depositDate
                    };
                    costBasisLots.push(newLot);
                    
                    remaining = 0;
                }
            }
            
            saveCostBasis();
        }
        
        // ==================== COSTO MEDIO PONDERATO ====================
        
        function calculateWeightedAverageCost(coin) {
            const coinUpper = coin.toUpperCase();
            
            // Trova tutti i lotti held per questo coin
            const lots = costBasisLots.filter(lot => 
                lot.coin === coinUpper && 
                lot.status === 'held' &&
                lot.amount > 0
            );
            
            if (lots.length === 0) {
                return { avgPrice: 0, totalAmount: 0, totalCost: 0 };
            }
            
            const totalAmount = lots.reduce((sum, lot) => sum + lot.amount, 0);
            const totalCost = lots.reduce((sum, lot) => sum + lot.costEur, 0);
            const avgPrice = totalAmount > 0 ? totalCost / totalAmount : 0;
            
            return {
                coin: coinUpper,
                avgPrice,
                totalAmount,
                totalCost,
                lots: lots.length
            };
        }
        
        // ==================== ALIQUOTE 2026 (DOPPIO BINARIO) ====================
        
        // Token Euro-backed (MiCAR) - 26%
        const EURO_TOKENS_26 = ['EURC', 'EURT', 'EUROC', 'EURS', 'AGEUR', 'CEUR', 'JEUR', 'SEUR'];
        
        // Tutti gli altri - 33% dal 2026
        function getTaxRate(coin, year) {
            const coinUpper = coin.toUpperCase();
            
            if (year <= 2025) {
                return 0.26; // 26% per tutti nel 2025
            }
            
            // Dal 2026: doppio binario
            if (EURO_TOKENS_26.includes(coinUpper)) {
                return 0.26; // 26% per stablecoin EUR (MiCAR)
            }
            
            return 0.33; // 33% per tutto il resto (BTC, ETH, SOL, USDT, USDC, etc.)
        }
        
        function getTaxRateLabel(coin, year) {
            const rate = getTaxRate(coin, year);
            if (rate === 0.26) {
                return year >= 2026 ? '26% (MiCAR EUR)' : '26%';
            }
            return '33% (2026+)';
        }
        
        // ==================== CALCOLO PLUSVALENZA COMPLETO ====================
        
        function calculateCapitalGainComplete(coin, amountSold, sellPriceEur, sellDate, method = 'CMP') {
            const coinUpper = coin.toUpperCase();
            const sellYear = new Date(sellDate).getFullYear();
            const taxRate = getTaxRate(coinUpper, sellYear);
            
            let costBasis = 0;
            let lotsUsed = [];
            
            if (method === 'CMP') {
                // Costo Medio Ponderato
                const avg = calculateWeightedAverageCost(coinUpper);
                costBasis = avg.avgPrice * amountSold;
                lotsUsed = [{ method: 'CMP', avgPrice: avg.avgPrice, amount: amountSold }];
                
            } else if (method === 'LIFO') {
                // Last In First Out - vendi i pi√π recenti
                const lots = costBasisLots.filter(lot => 
                    lot.coin === coinUpper && lot.status === 'held'
                ).sort((a, b) => new Date(b.date) - new Date(a.date)); // Pi√π recenti prima
                
                let remaining = amountSold;
                for (const lot of lots) {
                    if (remaining <= 0) break;
                    const useAmount = Math.min(lot.amount, remaining);
                    costBasis += useAmount * lot.priceEur;
                    remaining -= useAmount;
                    lotsUsed.push({ lotId: lot.id, amount: useAmount, price: lot.priceEur, date: lot.date });
                }
                
            } else {
                // FIFO - vendi i pi√π vecchi
                const lots = costBasisLots.filter(lot => 
                    lot.coin === coinUpper && lot.status === 'held'
                ).sort((a, b) => new Date(a.date) - new Date(b.date)); // Pi√π vecchi prima
                
                let remaining = amountSold;
                for (const lot of lots) {
                    if (remaining <= 0) break;
                    const useAmount = Math.min(lot.amount, remaining);
                    costBasis += useAmount * lot.priceEur;
                    remaining -= useAmount;
                    lotsUsed.push({ lotId: lot.id, amount: useAmount, price: lot.priceEur, date: lot.date });
                }
            }
            
            const sellValue = amountSold * sellPriceEur;
            const gain = sellValue - costBasis;
            const tax = gain > 0 ? gain * taxRate : 0;
            
            return {
                coin: coinUpper,
                amountSold,
                sellPriceEur,
                sellValue,
                costBasis,
                gain,
                isProfit: gain > 0,
                taxRate,
                taxRatePercent: (taxRate * 100).toFixed(0) + '%',
                taxDue: tax,
                method,
                lotsUsed,
                sellDate,
                sellYear
            };
        }
        
        // ==================== RECONCILIATOR ====================
        
        function reconcileInventory() {
            console.log('\nüîç RECONCILIATOR - Verifica coerenza magazzino...');
            
            const issues = [];
            
            // Per ogni coin, verifica che il saldo calcolato corrisponda ai lotti
            const summary = getCostBasisSummary();
            
            for (const [coin, data] of Object.entries(summary)) {
                // Cerca il saldo reale dagli exchange
                let realBalance = 0;
                
                for (const exchId of Object.keys(exchangeData)) {
                    const exchData = exchangeData[exchId];
                    if (exchData.balances) {
                        // Prendi l'ultimo anno disponibile
                        const years = Object.keys(exchData.balances).sort((a, b) => b - a);
                        if (years.length > 0) {
                            const latestYear = years[0];
                            realBalance += exchData.balances[latestYear][coin] || 0;
                        }
                    }
                }
                
                // Confronta
                const diff = Math.abs(data.totalAmount - realBalance);
                const diffPercent = realBalance > 0 ? (diff / realBalance) * 100 : 0;
                
                if (diffPercent > 5 && diff > 0.01) {
                    issues.push({
                        coin,
                        costBasisAmount: data.totalAmount,
                        realBalance,
                        difference: diff,
                        diffPercent,
                        message: `‚ö†Ô∏è ${coin}: Cost Basis ${data.totalAmount.toFixed(4)} ‚â† Saldo reale ${realBalance.toFixed(4)} (diff: ${diffPercent.toFixed(1)}%)`
                    });
                }
            }
            
            if (issues.length === 0) {
                console.log('‚úÖ Nessun problema rilevato!');
            } else {
                console.log(`‚ö†Ô∏è ${issues.length} problemi rilevati:`);
                for (const issue of issues) {
                    console.log(`  ${issue.message}`);
                }
            }
            
            return issues;
        }
        
        // ==================== END ADVANCED TAX CALCULATIONS ====================
        
        // ==================== IVCA (Imposta 0.2%) PRO-RATA ====================
        
        // Database minusvalenze
        let minusvalenzeDB = JSON.parse(localStorage.getItem('cryptofolio_minusvalenze') || '[]');
        
        function saveMinusvalenze() {
            localStorage.setItem('cryptofolio_minusvalenze', JSON.stringify(minusvalenzeDB));
        }
        
        // Registra minusvalenza
        function registerMinusvalenza(data) {
            // data: { date, coin, amount (EUR), saleId }
            const minusvalenza = {
                id: `MINUS_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`,
                date: data.date,
                year: new Date(data.date).getFullYear(),
                coin: data.coin.toUpperCase(),
                amount: data.amount, // Importo perdita in EUR
                usedAmount: 0, // Quanto √® stato compensato
                expiryYear: new Date(data.date).getFullYear() + 4, // Valida per 4 anni
                saleId: data.saleId || null
            };
            
            minusvalenzeDB.push(minusvalenza);
            saveMinusvalenze();
            
            console.log(`üìâ Minusvalenza registrata: ‚Ç¨${minusvalenza.amount.toFixed(2)} (valida fino ${minusvalenza.expiryYear})`);
            return minusvalenza;
        }
        
        // Ottieni crediti fiscali disponibili
        function getAvailableMinusvalenze(forYear) {
            return minusvalenzeDB.filter(m => 
                m.expiryYear >= forYear && 
                m.usedAmount < m.amount
            ).map(m => ({
                ...m,
                available: m.amount - m.usedAmount
            }));
        }
        
        // Compensa plusvalenza con minusvalenze
        function compensateWithMinusvalenze(plusvalenza, forYear) {
            let remaining = plusvalenza;
            const compensations = [];
            
            const available = getAvailableMinusvalenze(forYear)
                .sort((a, b) => a.year - b.year); // Usa prima le pi√π vecchie
            
            for (const minus of available) {
                if (remaining <= 0) break;
                
                const toUse = Math.min(minus.available, remaining);
                minus.usedAmount += toUse;
                remaining -= toUse;
                
                compensations.push({
                    minusId: minus.id,
                    amount: toUse,
                    fromYear: minus.year
                });
                
                // Aggiorna nel database
                const dbEntry = minusvalenzeDB.find(m => m.id === minus.id);
                if (dbEntry) dbEntry.usedAmount = minus.usedAmount;
            }
            
            saveMinusvalenze();
            
            return {
                originalPlusvalenza: plusvalenza,
                compensated: plusvalenza - remaining,
                netPlusvalenza: remaining,
                compensations
            };
        }
        
        // Calcola IVCA con pro-rata giorni
        function calculateIVCA(year, yearEndValue, firstPurchaseDates) {
            const IVCA_RATE = 0.002; // 0.2%
            const daysInYear = (year % 4 === 0) ? 366 : 365;
            
            if (!yearEndValue || !yearEndValue.assets) {
                console.log(`‚ö†Ô∏è Nessun dato per calcolo IVCA ${year}`);
                return null;
            }
            
            let totalIVCA = 0;
            const details = {};
            
            for (const [coin, data] of Object.entries(yearEndValue.assets)) {
                if (!data.valueEur || data.valueEur < 1) continue;
                
                // Trova data primo acquisto
                let daysHeld = daysInYear;
                const firstPurchase = firstPurchaseDates?.[coin.toUpperCase()];
                
                if (firstPurchase) {
                    const purchaseDate = new Date(firstPurchase);
                    if (purchaseDate.getFullYear() === year) {
                        // Acquistato durante l'anno - calcola giorni
                        const yearEnd = new Date(year, 11, 31);
                        daysHeld = Math.ceil((yearEnd - purchaseDate) / (1000 * 60 * 60 * 24)) + 1;
                    }
                }
                
                const proRata = daysHeld / daysInYear;
                const ivcaCoin = data.valueEur * IVCA_RATE * proRata;
                totalIVCA += ivcaCoin;
                
                details[coin] = {
                    valueEur: data.valueEur,
                    daysHeld,
                    proRata: Math.round(proRata * 1000) / 1000,
                    ivca: Math.round(ivcaCoin * 100) / 100
                };
            }
            
            return {
                year,
                totalIVCA: Math.round(totalIVCA * 100) / 100,
                totalValue: yearEndValue.totalValueEur,
                rate: '0.2%',
                details
            };
        }
        
        // Trova data primo acquisto per ogni coin
        function getFirstPurchaseDates() {
            const dates = {};
            
            // Da cost basis lots
            for (const lot of costBasisLots) {
                const coin = lot.coin.toUpperCase();
                const lotDate = new Date(lot.date);
                
                if (!dates[coin] || lotDate < new Date(dates[coin])) {
                    dates[coin] = lot.date;
                }
            }
            
            // Da transazioni exchange
            for (const exchId of Object.keys(exchangeData)) {
                const data = exchangeData[exchId];
                if (data.transactions) {
                    for (const tx of data.transactions) {
                        if (tx.type === 'buy' || tx.type === 'deposit' || (tx.change > 0 && tx.type === 'trade')) {
                            const coin = (tx.coin || '').toUpperCase();
                            if (!coin || coin === 'EUR' || coin === 'USD') continue;
                            
                            const txDate = tx.date instanceof Date ? tx.date : new Date(tx.date);
                            
                            if (!dates[coin] || txDate < new Date(dates[coin])) {
                                dates[coin] = txDate.toISOString();
                            }
                        }
                    }
                }
            }
            
            return dates;
        }
        
        // ==================== REPORT FISCALE COMPLETO ====================
        
        function generateCompleteFiscalReport(year) {
            console.log(`\nüìã Generazione Report Fiscale ${year}...`);
            
            // Raccogli dati
            const yearEndData = { assets: {}, totalValueEur: 0 };
            
            // Da tutti gli exchange
            for (const exchId of Object.keys(exchangeData)) {
                const data = exchangeData[exchId];
                if (data.balances && data.balances[year]) {
                    for (const [coin, amount] of Object.entries(data.balances[year])) {
                        if (amount > 0.0001 && !coin.startsWith('LD')) {
                            if (!yearEndData.assets[coin]) {
                                yearEndData.assets[coin] = { amount: 0, valueEur: 0, sources: [] };
                            }
                            yearEndData.assets[coin].amount += amount;
                            yearEndData.assets[coin].sources.push(exchId);
                        }
                    }
                }
                if (data.totals && data.totals[year]) {
                    yearEndData.totalValueEur += data.totals[year];
                }
            }
            
            // Calcola prezzi per ogni asset
            for (const [coin, data] of Object.entries(yearEndData.assets)) {
                const priceEur = getPriceEur(coin, year);
                data.priceEur = priceEur;
                data.valueEur = data.amount * priceEur;
            }
            
            // IVCA
            const firstPurchaseDates = getFirstPurchaseDates();
            const ivca = calculateIVCA(year, yearEndData, firstPurchaseDates);
            
            // Minusvalenze disponibili
            const minusvalenzeDisponibili = getAvailableMinusvalenze(year);
            const totaleMinusvalenze = minusvalenzeDisponibili.reduce((sum, m) => sum + m.available, 0);
            
            // Costruisci report
            const report = {
                year,
                generatedAt: new Date().toISOString(),
                
                // Quadro RW
                quadroRW: {
                    totalValue: Math.round(yearEndData.totalValueEur * 100) / 100,
                    assets: yearEndData.assets,
                    threshold: 15000, // Soglia dichiarazione
                    requiresDeclaration: yearEndData.totalValueEur > 15000
                },
                
                // IVCA
                ivca: ivca,
                
                // Minusvalenze
                minusvalenze: {
                    disponibili: minusvalenzeDisponibili,
                    totale: Math.round(totaleMinusvalenze * 100) / 100
                },
                
                // Aliquote
                taxRates: {
                    standard: year >= 2026 ? '33%' : '26%',
                    eurStablecoin: '26% (MiCAR)'
                }
            };
            
            console.log(`\n‚úÖ Report Fiscale ${year}:`);
            console.log(`   üìä Quadro RW: ‚Ç¨${report.quadroRW.totalValue.toLocaleString('it-IT')}`);
            console.log(`   üí∂ IVCA (0.2%): ‚Ç¨${(ivca?.totalIVCA || 0).toFixed(2)}`);
            console.log(`   üìâ Minusvalenze disponibili: ‚Ç¨${totaleMinusvalenze.toFixed(2)}`);
            
            return report;
        }
        
        function runReconciliator() {
            const issues = reconcileInventory();
            const container = document.getElementById('reconciliatorResults');
            
            if (!container) return;
            
            container.style.display = 'block';
            
            if (issues.length === 0) {
                container.innerHTML = `
                    <div style="background:var(--green);color:#000;padding:12px;border-radius:8px;">
                        ‚úÖ <strong>Tutto OK!</strong> I saldi del Cost Basis corrispondono ai saldi reali.
                    </div>
                `;
            } else {
                let html = `
                    <div style="background:var(--yellow);color:#000;padding:12px;border-radius:8px;">
                        <strong>‚ö†Ô∏è ${issues.length} discrepanze trovate:</strong>
                        <ul style="margin:8px 0 0;padding-left:20px;">
                `;
                for (const issue of issues) {
                    html += `<li>${issue.coin}: Magazzino ${issue.costBasisAmount.toFixed(4)} ‚â† Saldo ${issue.realBalance.toFixed(4)}</li>`;
                }
                html += `
                        </ul>
                        <div style="font-size:12px;margin-top:8px;">
                            üí° Possibili cause: trasferimenti non tracciati, CSV incompleti, o transazioni mancanti.
                        </div>
                    </div>
                `;
                container.innerHTML = html;
            }
        }
        
        function refreshCostBasisUI() {
            const container = document.getElementById('costBasisContent');
            if (!container) return;
            
            const summary = getCostBasisSummary();
            const coins = Object.entries(summary)
                .filter(([coin, data]) => data.totalCost > 0.01 || data.totalAmount > 0.0001)
                .sort((a, b) => b[1].totalCost - a[1].totalCost);
            
            if (coins.length === 0) {
                container.innerHTML = `
                    <div class="empty-state" style="padding:20px;">
                        <div style="color:var(--text-secondary);">Nessun cost basis calcolato.<br>Importa CSV da Binance o Bitpanda.</div>
                    </div>
                `;
                return;
            }
            
            let totalInvestment = 0;
            const currentYear = new Date().getFullYear();
            
            let html = `
                <table style="width:100%;border-collapse:collapse;">
                    <tr style="background:var(--bg-primary);">
                        <th style="padding:10px;text-align:left;border-bottom:2px solid var(--border);">Token</th>
                        <th style="padding:10px;text-align:right;border-bottom:2px solid var(--border);">Quantit√†</th>
                        <th style="padding:10px;text-align:right;border-bottom:2px solid var(--border);">Costo Totale</th>
                        <th style="padding:10px;text-align:right;border-bottom:2px solid var(--border);">Prezzo Medio</th>
                        <th style="padding:10px;text-align:right;border-bottom:2px solid var(--border);">Aliquota 2026</th>
                        <th style="padding:10px;text-align:right;border-bottom:2px solid var(--border);">Fonte</th>
                    </tr>
            `;
            
            for (const [coin, data] of coins) {
                totalInvestment += data.totalCost;
                
                // Fonti
                const sources = Object.keys(data.bySource).join(', ');
                
                // Formatta quantit√†
                let amountStr = data.totalAmount.toFixed(2);
                if (data.totalAmount >= 1000000) {
                    amountStr = (data.totalAmount / 1000000).toFixed(2) + 'M';
                } else if (data.totalAmount >= 1000) {
                    amountStr = (data.totalAmount / 1000).toFixed(2) + 'K';
                } else if (data.totalAmount < 0.01) {
                    amountStr = data.totalAmount.toFixed(6);
                }
                
                // Aliquota fiscale 2026
                const taxRate = getTaxRate(coin, 2026);
                const taxColor = taxRate === 0.26 ? 'var(--green)' : 'var(--yellow)';
                const taxLabel = taxRate === 0.26 ? '26% EUR' : '33%';
                
                html += `
                    <tr>
                        <td style="padding:10px;border-bottom:1px solid var(--border);font-weight:bold;">${coin}</td>
                        <td style="padding:10px;text-align:right;border-bottom:1px solid var(--border);">${amountStr}</td>
                        <td style="padding:10px;text-align:right;border-bottom:1px solid var(--border);color:var(--green);">‚Ç¨${data.totalCost.toFixed(2)}</td>
                        <td style="padding:10px;text-align:right;border-bottom:1px solid var(--border);">‚Ç¨${data.avgPrice.toFixed(6)}</td>
                        <td style="padding:10px;text-align:right;border-bottom:1px solid var(--border);color:${taxColor};font-weight:bold;">${taxLabel}</td>
                        <td style="padding:10px;text-align:right;border-bottom:1px solid var(--border);color:var(--text-secondary);font-size:12px;">${sources}</td>
                    </tr>
                `;
            }
            
            html += `
                <tr style="background:var(--bg-primary);font-weight:bold;">
                    <td style="padding:12px;" colspan="2">üìä TOTALE INVESTITO (EUR reali)</td>
                    <td style="padding:12px;text-align:right;color:var(--green);font-size:18px;">‚Ç¨${totalInvestment.toFixed(2)}</td>
                    <td style="padding:12px;text-align:right;" colspan="3">${costBasisLots.length} lotti</td>
                </tr>
            </table>
            <div style="margin-top:12px;font-size:12px;color:var(--text-secondary);">
                üí° <strong>2026:</strong> 33% su BTC, ETH, stablecoin USD | 26% solo su stablecoin EUR (MiCAR)
            </div>
            `;
            
            container.innerHTML = html;
        }
        
        async function refreshAllPricesUI() {
            const btn = event.target;
            const originalText = btn.innerHTML;
            btn.innerHTML = '‚è≥ Aggiornando...';
            btn.disabled = true;
            
            try {
                const prices = await updateAllPrices();
                const count = Object.keys(prices).length;
                
                // Ricalcola i totali per tutti gli exchange
                for (const exchId of Object.keys(exchangeData)) {
                    if (exchangeData[exchId].transactions?.length > 0) {
                        calculateExchangeBalances(exchId);
                    }
                }
                
                updateExchangeTotals();
                
                alert(`‚úÖ Aggiornati ${count} prezzi da CoinGecko!\n\nI valori sono stati ricalcolati.`);
            } catch (err) {
                console.error('Price refresh error:', err);
                alert('‚ùå Errore aggiornamento prezzi: ' + err.message);
            } finally {
                btn.innerHTML = originalText;
                btn.disabled = false;
            }
        }
        
        const SYMBOL_TO_CG = { 
            // Top coins
            'BTC': 'bitcoin', 'ETH': 'ethereum', 'BNB': 'binancecoin',
            'SOL': 'solana', 'XRP': 'ripple', 'ADA': 'cardano',
            'DOGE': 'dogecoin', 'DOT': 'polkadot', 'MATIC': 'matic-network',
            'LINK': 'chainlink', 'AVAX': 'avalanche-2', 'SHIB': 'shiba-inu',
            // Stablecoins
            'USDT': 'tether', 'USDC': 'usd-coin', 'BUSD': 'tether', 
            'FDUSD': 'tether', 'DAI': 'dai', 'TUSD': 'tether',
            // Layer 1
            'ATOM': 'cosmos', 'NEAR': 'near', 'TRX': 'tron', 
            'TON': 'the-open-network', 'ALGO': 'algorand', 'EOS': 'eos',
            'XLM': 'stellar', 'VET': 'vechain', 'NEO': 'neo',
            // DeFi
            'UNI': 'uniswap', 'AAVE': 'aave', 'CAKE': 'pancakeswap-token',
            '1INCH': '1inch', 'SUSHI': 'sushi', 'COMP': 'compound-governance-token',
            'CRV': 'curve-dao-token', 'SNX': 'synthetix-network-token',
            // Meme
            'PEPE': 'pepe', 'FLOKI': 'floki', 'BONE': 'bone-shibaswap',
            // Telegram/TON meme
            'NOT': 'notcoin', 'DOGS': 'dogs-2', 'HMSTR': 'hamster-kombat', 'CATI': 'catizen',
            // Gaming/Metaverse  
            'SAND': 'the-sandbox', 'MANA': 'decentraland', 'AXS': 'axie-infinity',
            'ENJ': 'enjincoin', 'GALA': 'gala', 'IMX': 'immutable-x',
            // Layer 2
            'ARB': 'arbitrum', 'OP': 'optimism',
            // Exchange tokens
            'CRO': 'crypto-com-chain', 'FTT': 'ftx-token', 'OKB': 'okb',
            // PulseChain
            'PLS': 'pulsechain', 'HEX': 'hex', 'PLSX': 'pulsex',
            // Luna
            'LUNC': 'terra-luna', 'LUNA': 'terra-luna-2',
            // Other popular
            'LTC': 'litecoin', 'BCH': 'bitcoin-cash', 'ETC': 'ethereum-classic',
            'FIL': 'filecoin', 'APE': 'apecoin', 'LDO': 'lido-dao',
            'OSMO': 'osmosis', 'INJ': 'injective-protocol',
            'KSM': 'kusama', 'QTUM': 'qtum', 'PENDLE': 'pendle',
            'SEI': 'sei-network', 'APT': 'aptos',
            // Fiat
            'EUR': 'eur', 'USD': 'usd',
        };
        
        let tokenBlacklist = JSON.parse(localStorage.getItem('cryptofolio_blacklist') || '[]');
        let blacklistNames = JSON.parse(localStorage.getItem('cryptofolio_blacklist_names') || '{}');
        let selectedChains = JSON.parse(localStorage.getItem('cryptofolio_chains') || '["eth","bsc"]');
        let savedWallets = JSON.parse(localStorage.getItem('cryptofolio_wallets') || '[]');
        let apiKeys = JSON.parse(localStorage.getItem('cryptofolio_apikeys') || '{}');
        let taxReportData = null; // Cached tax report results
        let saveTimeout = null;
        
        // Binance
        const BINANCE_SERVER_URL = 'http://localhost:3457';
        let binanceData = { balances: { spot: [], earn: [], staking: [] }, totals: { spot: 0, earn: 0, staking: 0 }, lastUpdate: null };
        
        // Exchange values per Tax Report (31/12 di ogni anno)
        let exchangeValues = { 2021: 0, 2022: 0, 2023: 0, 2024: 0, 2025: 0, 2026: 0 };
        
        // Multi-API Moralis (cascata)
        let moralisKeys = []; // Array di API keys
        let currentMoralisKeyIndex = 0;
        let moralisKeyFailures = {}; // Traccia fallimenti per key
        
        // NFT data
        let nftData = []; // Array di NFT: { tokenId, name, collection, image, chain, contract, floorPrice, purchasePrice, wallet }
        let nftPurchasePrices = {}; // { contract_tokenId: purchasePrice } - prezzi di acquisto manuali
        
        // Exchange data from CSV imports
        let exchangeData = {}; // { binance: { transactions: [], balances: {2021: {BTC: 0.5, ...}}, totals: {2021: 1234, ...} }, ... }
        
        // Lista exchange supportati
        const EXCHANGE_LIST = [
            { id: 'binance', name: 'Binance', color: '#f3ba2f', icon: 'B', logo: 'https://assets.coingecko.com/markets/images/52/small/binance.jpg', hasApi: true },
            { id: 'bitget', name: 'Bitget', color: '#00f0ff', icon: 'Bg', logo: 'https://assets.coingecko.com/markets/images/540/small/bitget.jpg', hasApi: true },
            { id: 'bitpanda', name: 'Bitpanda', color: '#08b289', icon: 'Bp', logo: 'https://assets.coingecko.com/markets/images/237/small/bitpanda.jpg', hasApi: true },
            { id: 'bybit', name: 'Bybit', color: '#f7a600', icon: 'By', logo: 'https://assets.coingecko.com/markets/images/698/small/bybit_spot.png' },
            { id: 'bybit_eu', name: 'Bybit EU', color: '#f7a600', icon: 'BE', logo: 'https://assets.coingecko.com/markets/images/698/small/bybit_spot.png' },
            { id: 'cake', name: 'Cake DeFi', color: '#00d395', icon: 'üç∞', logo: null },
            { id: 'coinbase', name: 'Coinbase', color: '#0052ff', icon: 'Cb', logo: 'https://assets.coingecko.com/markets/images/23/small/Coinbase_Coin_Primary.png' },
            { id: 'cosmos', name: 'Cosmos', color: '#2e3148', icon: '‚öõÔ∏è', logo: 'https://assets.coingecko.com/coins/images/1481/small/cosmos_hub.png' },
            { id: 'cryptocom_app', name: 'Crypto.com App', color: '#002d74', icon: 'Ca', logo: 'https://assets.coingecko.com/markets/images/589/small/crypto_com.jpg' },
            { id: 'cryptocom_exchange', name: 'Crypto.com Exchange', color: '#002d74', icon: 'Ce', logo: 'https://assets.coingecko.com/markets/images/589/small/crypto_com.jpg' },
            { id: 'gateio', name: 'Gate.io', color: '#17e6a1', icon: 'G', logo: 'https://assets.coingecko.com/markets/images/60/small/gate_io.jpg' },
            { id: 'kraken', name: 'Kraken', color: '#5741d9', icon: 'Kr', logo: 'https://assets.coingecko.com/markets/images/29/small/kraken.jpg' },
            { id: 'kucoin', name: 'KuCoin', color: '#23af91', icon: 'Ku', logo: 'https://assets.coingecko.com/markets/images/61/small/kucoin.jpg' },
            { id: 'manta', name: 'Manta Pacific', color: '#1fc7d4', icon: 'üêô', logo: null },
            { id: 'mexc', name: 'MEXC', color: '#00b897', icon: 'Mx', logo: 'https://assets.coingecko.com/markets/images/409/small/MEXC_logo_square.jpeg' },
            { id: 'nexo', name: 'Nexo', color: '#1a4bff', icon: 'Nx', logo: 'https://assets.coingecko.com/coins/images/3695/small/nexo.png' },
            { id: 'okx', name: 'OKX', color: '#000000', icon: 'OK', logo: 'https://assets.coingecko.com/markets/images/96/small/WeChat_Image_20220117220452.png' },
            { id: 'osmo', name: 'Osmosis', color: '#5e12a0', icon: 'üß™', logo: 'https://assets.coingecko.com/coins/images/16724/small/osmo.png' },
            { id: 'pionex', name: 'Pionex', color: '#c8a02c', icon: 'Px', logo: 'https://assets.coingecko.com/markets/images/532/small/pionex.png' },
            { id: 'pulsechain', name: 'PulseChain', color: '#00ff00', icon: 'üíö', logo: null },
            { id: 'revolut', name: 'Revolut', color: '#0666eb', icon: 'Rv', logo: null },
            { id: 'terra', name: 'Terra-LUNC', color: '#5493f7', icon: 'üåô', logo: 'https://assets.coingecko.com/coins/images/8284/small/01_LussLogo_color.png' },
            { id: 'whitebit', name: 'WhiteBit', color: '#02c3bd', icon: 'Wb', logo: 'https://assets.coingecko.com/markets/images/418/small/logo_wb_small.png' },
            { id: 'youholders', name: 'YouHodler', color: '#6c5ce7', icon: 'Yh', logo: null },
            { id: 'youngplatform', name: 'Young Platform', color: '#ff6b35', icon: 'Yp', logo: 'https://assets.coingecko.com/markets/images/770/small/LOGO.jpg' },
        ];
        
        // Moralis chain mapping
        const MORALIS_CHAINS = {
            eth: '0x1',
            bsc: '0x38',
            polygon: '0x89',
            arbitrum: '0xa4b1',
            optimism: '0xa',
            base: '0x2105',
            cronos: '0x19'
        };
        
        // ==================== FIREBASE ====================
        function updateSyncStatus(status, color) {
            document.getElementById('syncStatus').textContent = status;
            document.getElementById('syncDot').style.background = color || 'var(--green)';
        }
        
        function saveToFirebase() {
            if (saveTimeout) clearTimeout(saveTimeout);
            saveTimeout = setTimeout(async () => {
                try {
                    updateSyncStatus('Salvataggio...', 'var(--accent)');
                    await db.collection('cryptofolio').doc('settings').set({
                        wallets: savedWallets,
                        blacklist: tokenBlacklist,
                        blacklistNames: blacklistNames,
                        selectedChains: selectedChains,
                        apiKeys: apiKeys,
                        walletResults: walletResults,
                        taxReportData: taxReportData,
                        exchangeValues: exchangeValues,
                        lastUpdate: new Date().toISOString()
                    });
                    updateSyncStatus('Salvato ‚úì', 'var(--green)');
                    console.log('‚úÖ Firebase saved');
                } catch (e) {
                    updateSyncStatus('Errore sync', 'var(--red)');
                    console.error('Firebase save error:', e);
                }
            }, 1500);
        }
        
        async function loadFromFirebase() {
            try {
                updateSyncStatus('Caricamento...', 'var(--accent)');
                const doc = await db.collection('cryptofolio').doc('settings').get();
                
                if (doc.exists) {
                    const data = doc.data();
                    savedWallets = data.wallets || [];
                    tokenBlacklist = data.blacklist || [];
                    blacklistNames = data.blacklistNames || {};
                    selectedChains = data.selectedChains || ['eth', 'bsc'];
                    // Merge apiKeys: mantiene chiavi locali + aggiunge cloud
                    const cloudApiKeys = data.apiKeys || {};
                    apiKeys = { ...apiKeys, ...cloudApiKeys };
                    walletResults = data.walletResults || {};
                    taxReportData = data.taxReportData || null;
                    exchangeValues = data.exchangeValues || { 2021: 0, 2022: 0, 2023: 0, 2024: 0, 2025: 0, 2026: 0 };
                    
                    // Sync to localStorage
                    localStorage.setItem('cryptofolio_wallets', JSON.stringify(savedWallets));
                    localStorage.setItem('cryptofolio_blacklist', JSON.stringify(tokenBlacklist));
                    localStorage.setItem('cryptofolio_blacklist_names', JSON.stringify(blacklistNames));
                    localStorage.setItem('cryptofolio_chains', JSON.stringify(selectedChains));
                    localStorage.setItem('cryptofolio_apikeys', JSON.stringify(apiKeys));
                    
                    // Backward compatibility: load old apiKey into new structure
                    if (data.apiKey && !apiKeys.etherscan) {
                        apiKeys.etherscan = data.apiKey;
                        localStorage.setItem('cryptofolio_apikeys', JSON.stringify(apiKeys));
                    }
                    
                    // Update UI fields
                    if (apiKeys.etherscan) {
                        document.getElementById('apiKey').value = apiKeys.etherscan;
                    }
                    
                    console.log('‚úÖ Firebase loaded:', savedWallets.length, 'wallets,', Object.keys(walletResults).length, 'scan results', taxReportData ? ', tax report cached' : '');
                }
                
                updateSyncStatus('Connesso ‚úì', 'var(--green)');
            } catch (e) {
                updateSyncStatus('Offline', 'var(--red)');
                console.error('Firebase load error:', e);
            }
        }
        
        async function forceSyncFirebase() {
            if (saveTimeout) clearTimeout(saveTimeout);
            try {
                updateSyncStatus('Sync...', 'var(--accent)');
                await db.collection('cryptofolio').doc('settings').set({
                    wallets: savedWallets,
                    blacklist: tokenBlacklist,
                    blacklistNames: blacklistNames,
                    selectedChains: selectedChains,
                    apiKeys: apiKeys,
                    walletResults: walletResults,
                    taxReportData: taxReportData,
                    lastUpdate: new Date().toISOString()
                });
                updateSyncStatus('Salvato ‚úì', 'var(--green)');
                alert('‚úÖ Dati sincronizzati con Firebase!');
            } catch (e) {
                updateSyncStatus('Errore', 'var(--red)');
                alert('‚ùå Errore sync: ' + e.message);
            }
        }
        
        // ==================== UTILS ====================
        function log(msg, type = '') { 
            const el = document.getElementById('statusLog'); 
            el.innerHTML += `<div class="log-line ${type}">[${new Date().toLocaleTimeString('it-IT')}] ${msg}</div>`; 
            el.scrollTop = el.scrollHeight; 
        }
        function formatNum(n, d = 2) { 
            if (n >= 1e9) return (n/1e9).toFixed(2)+'B'; 
            if (n >= 1e6) return (n/1e6).toFixed(2)+'M'; 
            if (n < 0.0001 && n > 0) return n.toExponential(2); 
            return n.toLocaleString('en-US', {minimumFractionDigits: d, maximumFractionDigits: d}); 
        }
        function formatEUR(n) { 
            if (n === null || n === undefined || isNaN(n)) return '0,00';
            return n.toLocaleString('it-IT', {minimumFractionDigits: 2, maximumFractionDigits: 2}); 
        }
        function isSpam(name, sym) { 
            const n = (name||'').toLowerCase(), s = (sym||'').toLowerCase(); 
            const spam = ['visit', 'claim', 'reward', '.com', '.org', '.io', '.xyz', 'airdrop', 'bonus', 'free', 'gift', 'http', '$', '#']; 
            for (const p of spam) if (n.includes(p) || s.includes(p)) return true; 
            return (name||'').length > 40; 
        }
        function isBlacklisted(c) { return tokenBlacklist.includes(c.toLowerCase()); }
        function hideToken(c, s) { 
            const lc = c.toLowerCase(); 
            if (!tokenBlacklist.includes(lc)) { 
                tokenBlacklist.push(lc); 
                blacklistNames[lc] = s; 
                localStorage.setItem('cryptofolio_blacklist', JSON.stringify(tokenBlacklist)); 
                localStorage.setItem('cryptofolio_blacklist_names', JSON.stringify(blacklistNames)); 
            }
            updateBlacklist(); 
            displayResults(lastScanResults);
            // Aggiorna anche wallet detail se aperto
            if (currentDetailWallet) displayWalletDetail();
            saveToFirebase();
        }
        function restoreToken(c) { 
            tokenBlacklist = tokenBlacklist.filter(x => x !== c.toLowerCase()); 
            delete blacklistNames[c.toLowerCase()]; 
            localStorage.setItem('cryptofolio_blacklist', JSON.stringify(tokenBlacklist)); 
            localStorage.setItem('cryptofolio_blacklist_names', JSON.stringify(blacklistNames)); 
            updateBlacklist(); 
            displayResults(lastScanResults);
            // Aggiorna anche wallet detail se aperto
            if (currentDetailWallet) displayWalletDetail();
            saveToFirebase();
        }
        function clearBlacklist() { 
            tokenBlacklist = []; blacklistNames = {}; 
            localStorage.removeItem('cryptofolio_blacklist'); 
            localStorage.removeItem('cryptofolio_blacklist_names'); 
            updateBlacklist(); 
            displayResults(lastScanResults);
            saveToFirebase();
        }
        function toggleBlacklist() { 
            const p = document.getElementById('blacklistPanel'); 
            p.style.display = p.style.display === 'none' ? 'block' : 'none'; 
        }
        function updateBlacklist() { 
            document.getElementById('blacklistCount').textContent = tokenBlacklist.length; 
            const c = document.getElementById('blacklistContent'); 
            if (tokenBlacklist.length === 0) { c.innerHTML = '<p style="color:var(--text-secondary);">Nessun token nascosto</p>'; return; } 
            let h = ''; 
            for (const x of tokenBlacklist) { 
                h += `<div class="blacklist-item"><span>${blacklistNames[x]||x.slice(0,10)}</span><button class="btn-restore" onclick="restoreToken('${x}')">‚Ü©Ô∏è</button></div>`; 
            } 
            c.innerHTML = h; 
        }
        
        // ==================== UI ====================
        let currentDetailWallet = null;
        
        function showView(view) {
            document.getElementById('dashboardView').style.display = view === 'dashboard' ? 'block' : 'none';
            document.getElementById('walletsView').style.display = view === 'wallets' ? 'block' : 'none';
            document.getElementById('walletDetailView').style.display = view === 'walletDetail' ? 'block' : 'none';
            document.getElementById('nftView').style.display = view === 'nft' ? 'block' : 'none';
            document.getElementById('exchangesView').style.display = view === 'exchanges' ? 'block' : 'none';
            document.getElementById('exchangeDetailView').style.display = view === 'exchangeDetail' ? 'block' : 'none';
            document.getElementById('reconcileView').style.display = view === 'reconcile' ? 'block' : 'none';
            document.getElementById('taxView').style.display = view === 'tax' ? 'block' : 'none';
            document.getElementById('apiView').style.display = view === 'api' ? 'block' : 'none';
            document.querySelectorAll('.nav-item').forEach((e, i) => {
                e.classList.toggle('active', 
                    (view === 'dashboard' && i === 0) || 
                    (view === 'wallets' && i === 1) || 
                    (view === 'walletDetail' && i === 1) || 
                    (view === 'nft' && i === 2) ||
                    (view === 'exchanges' && i === 3) ||
                    (view === 'exchangeDetail' && i === 3) ||
                    (view === 'reconcile' && i === 4) ||
                    (view === 'tax' && i === 5) ||
                    (view === 'api' && i === 6)
                );
            });
            
            // Aggiorna dropdown tax e mostra dati salvati
            if (view === 'tax') {
                updateTaxWalletsList();
                loadExchangeValuesUI();
                if (taxReportData) {
                    renderTaxReport(taxReportData);
                }
            }
            
            // Carica dati riconciliazione da localStorage
            if (view === 'reconcile') {
                // Carica sempre da localStorage se non ci sono dati in memoria
                const hasData = reconcileData.exchangeTx.length > 0 || reconcileData.walletTx.length > 0 || reconcileData.matches.length > 0;
                if (!hasData) {
                    if (loadReconcileFromLocalStorage()) {
                        updateReconcileSummary();
                        renderReconcileData();
                    }
                } else {
                    // Aggiorna la UI con i dati esistenti
                    updateReconcileSummary();
                    renderReconcileData();
                }
            }
            
            // Aggiorna status API quando si apre
            if (view === 'api') {
                updateApiStatus();
            }
            
            // Inizializza griglia exchange quando si apre
            if (view === 'exchanges') {
                initExchangeGrid();
                updateExchangeTotals();
            }
        }
        
        function renderTaxReport(data) {
            if (!data || !data.grandTotals || !data.walletDetails) {
                console.error('Invalid tax report data');
                return;
            }
            
            const container = document.getElementById('taxReportContent');
            const detailCard = document.getElementById('taxDetailCard');
            const detailContent = document.getElementById('taxDetailContent');
            const years = [2021, 2022, 2023, 2024, 2025, 2026];
            
            // Calcola totali includendo exchange
            const combinedTotals = {};
            let hasExchange = false;
            for (const y of years) {
                const walletEur = data.grandTotals[y]?.eur || 0;
                const walletUsd = data.grandTotals[y]?.usd || 0;
                const exchEur = exchangeValues[y] || 0;
                const exchUsd = exchEur / EUR_USD;
                if (exchEur > 0) hasExchange = true;
                combinedTotals[y] = {
                    eur: walletEur + exchEur,
                    usd: walletUsd + exchUsd,
                    walletEur: walletEur,
                    exchangeEur: exchEur
                };
            }
            
            // Render summary cards
            let html = '<div style="display:grid;gap:12px;">';
            
            for (const y of years) {
                const t = combinedTotals[y];
                const above = (t.eur || 0) >= 15000;
                const bgColor = above ? 'rgba(255,82,82,0.1)' : 'var(--bg-primary)';
                const borderColor = above ? 'var(--red)' : 'var(--border)';
                
                html += '<div style="background:' + bgColor + ';border:1px solid ' + borderColor + ';border-radius:12px;padding:16px;display:grid;grid-template-columns:80px 1fr 1fr 1fr 120px;align-items:center;gap:16px;">';
                html += '<div style="text-align:center;"><div style="font-size:28px;font-weight:700;color:var(--text-primary);">' + y + '</div></div>';
                html += '<div style="text-align:center;"><div style="font-size:11px;color:var(--text-secondary);margin-bottom:4px;">üëõ WALLET</div>';
                html += '<div style="font-size:16px;font-weight:600;color:var(--green);">‚Ç¨' + formatEUR(t.walletEur || 0) + '</div></div>';
                html += '<div style="text-align:center;"><div style="font-size:11px;color:var(--text-secondary);margin-bottom:4px;">üè¶ EXCHANGE</div>';
                html += '<div style="font-size:16px;font-weight:600;color:#f3ba2f;">‚Ç¨' + formatEUR(t.exchangeEur || 0) + '</div></div>';
                html += '<div style="text-align:center;"><div style="font-size:11px;color:var(--text-secondary);margin-bottom:4px;">üí∞ TOTALE</div>';
                html += '<div style="font-size:22px;font-weight:700;color:var(--green);">‚Ç¨' + formatEUR(t.eur || 0) + '</div></div>';
                html += '<div style="text-align:center;"><div style="font-size:11px;color:var(--text-secondary);margin-bottom:4px;">QUADRO RW</div>';
                if (above) {
                    html += '<div style="font-size:14px;font-weight:700;color:var(--red);background:rgba(255,82,82,0.2);padding:6px 12px;border-radius:8px;">‚ö†Ô∏è OBBLIGO</div>';
                } else {
                    html += '<div style="font-size:14px;font-weight:600;color:var(--green);background:rgba(0,230,118,0.1);padding:6px 12px;border-radius:8px;">‚úì NO</div>';
                }
                html += '</div></div>';
            }
            html += '</div>';
            
            // Footer info
            html += '<div style="margin-top:20px;padding:16px;background:var(--bg-primary);border-radius:12px;">';
            html += '<div style="display:flex;flex-wrap:wrap;gap:16px;justify-content:center;align-items:center;font-size:13px;">';
            html += '<span>üìä <strong>' + (data.walletCount || 0) + '</strong> wallet</span>';
            if (hasExchange) html += '<span style="color:var(--border);">|</span><span>üè¶ <strong>Exchange inclusi</strong></span>';
            html += '<span style="color:var(--border);">|</span>';
            html += '<span>‚õìÔ∏è ' + (data.chainNames || 'N/A') + '</span>';
            html += '<span style="color:var(--border);">|</span>';
            html += '<span>‚ö†Ô∏è Soglia RW: <strong>‚Ç¨15.000</strong></span>';
            html += '<span style="color:var(--border);">|</span>';
            html += '<span style="color:var(--text-secondary);">üìÖ ' + new Date(data.calculatedAt || Date.now()).toLocaleString('it-IT') + '</span>';
            html += '</div>';
            
            // Transazioni per anno (se disponibili)
            const txByYear = countTransactionsByYear();
            const hasTx = Object.values(txByYear).some(v => v > 0);
            if (hasTx) {
                html += '<div style="margin-top:12px;padding-top:12px;border-top:1px solid var(--border);display:flex;flex-wrap:wrap;gap:12px;justify-content:center;align-items:center;font-size:12px;">';
                html += '<span style="color:var(--text-secondary);">üìú Transazioni:</span>';
                for (const y of years) {
                    if (txByYear[y] > 0) {
                        html += '<span style="background:var(--bg-secondary);padding:4px 8px;border-radius:4px;"><strong>' + y + '</strong>: ' + txByYear[y] + '</span>';
                    }
                }
                html += '</div>';
            }
            html += '</div>';
            
            container.innerHTML = html;
            
            // Render detail per wallet
            let dh = '';
            for (const wd of (data.walletDetails || [])) {
                if (!wd) continue;
                dh += '<div style="margin-bottom:24px;padding:20px;background:var(--bg-primary);border-radius:12px;">';
                dh += '<h3 style="margin-bottom:16px;display:flex;align-items:center;gap:10px;font-size:16px;">üëõ ' + (wd.walletName || 'Wallet') + ' <span style="font-size:12px;color:var(--text-secondary);font-weight:normal;">' + (wd.walletAddress || '') + '</span></h3>';
                dh += '<table style="width:100%;border-collapse:collapse;font-size:13px;"><thead><tr style="border-bottom:2px solid var(--border);"><th style="text-align:left;padding:12px 8px;color:var(--text-secondary);font-weight:500;">TOKEN</th>';
                for (const y of years) dh += '<th style="text-align:center;padding:12px 8px;color:var(--text-secondary);font-weight:500;">' + y + '</th>';
                dh += '</tr></thead><tbody>';
                
                // Token rows
                for (const row of (wd.rows || [])) {
                    if (!row) continue;
                    dh += '<tr style="border-bottom:1px solid var(--border);"><td style="padding:12px 8px;"><strong>' + (row.tokenKey || '?') + '</strong></td>';
                    for (const y of years) {
                        const cell = row.cells ? row.cells[y] : null;
                        if (cell && cell.hasValue) {
                            dh += '<td style="text-align:center;padding:12px 8px;"><span style="color:var(--green);font-weight:600;">‚Ç¨' + formatEUR(cell.eur || 0) + '</span><br><span style="font-size:10px;color:var(--text-secondary);">' + formatNum(cell.balance || 0, 2) + '</span></td>';
                        } else if (cell && cell.balance > 0) {
                            dh += '<td style="text-align:center;padding:12px 8px;"><span style="color:var(--text-secondary);">' + formatNum(cell.balance || 0, 2) + '</span><br><span style="font-size:10px;color:var(--red);">no price</span></td>';
                        } else {
                            dh += '<td style="text-align:center;padding:12px 8px;color:var(--text-secondary);">-</td>';
                        }
                    }
                    dh += '</tr>';
                }
                
                // Wallet total row
                dh += '<tr style="background:var(--bg-secondary);border-radius:8px;"><td style="padding:14px 8px;font-weight:700;">TOTALE</td>';
                for (const y of years) {
                    const tot = wd.totals ? wd.totals[y] : null;
                    dh += '<td style="text-align:center;padding:14px 8px;font-weight:700;font-size:15px;color:var(--green);">‚Ç¨' + formatEUR(tot ? (tot.eur || 0) : 0) + '</td>';
                }
                dh += '</tr>';
                
                dh += '</tbody></table></div>';
            }
            
            detailContent.innerHTML = dh;
            detailCard.style.display = 'block';
        }
        
        function printTaxReport() {
            if (!taxReportData || !taxReportData.grandTotals || !taxReportData.walletDetails) {
                alert('Nessun report da stampare. Calcola prima il Tax Report.');
                return;
            }
            
            const years = [2021, 2022, 2023, 2024];
            const data = taxReportData;
            const dateStr = new Date().toLocaleString('it-IT');
            
            // Calcola totali combinati
            const combinedTotals = {};
            let hasExchange = false;
            for (const y of years) {
                const walletEur = data.grandTotals[y]?.eur || 0;
                const walletUsd = data.grandTotals[y]?.usd || 0;
                const exchEur = exchangeValues[y] || 0;
                const exchUsd = exchEur / EUR_USD;
                if (exchEur > 0) hasExchange = true;
                combinedTotals[y] = { eur: walletEur + exchEur, usd: walletUsd + exchUsd, walletEur, exchangeEur: exchEur };
            }
            
            // Build HTML string safely
            let html = '<!DOCTYPE html><html><head><meta charset="UTF-8"><title>Tax Report - Quadro RW</title>';
            html += '<style>';
            html += '* { margin: 0; padding: 0; box-sizing: border-box; }';
            html += 'body { font-family: Arial, sans-serif; padding: 40px; color: #1a1a2e; background: #fff; }';
            html += '.header { text-align: center; margin-bottom: 30px; border-bottom: 2px solid #1a1a2e; padding-bottom: 20px; }';
            html += '.header h1 { font-size: 24px; margin-bottom: 8px; }';
            html += '.header p { color: #666; font-size: 12px; }';
            html += '.summary h2 { font-size: 16px; margin-bottom: 15px; background: #f5f5f5; padding: 10px; }';
            html += 'table { width: 100%; border-collapse: collapse; margin-bottom: 20px; font-size: 12px; }';
            html += 'th { background: #1a1a2e; color: white; padding: 12px 8px; text-align: center; }';
            html += 'td { padding: 10px 8px; border-bottom: 1px solid #ddd; text-align: center; }';
            html += '.value-eur { font-weight: 700; color: #00c853; font-size: 14px; }';
            html += '.value-exchange { font-weight: 600; color: #f3ba2f; }';
            html += '.obbligo { background: #ffebee; }';
            html += '.obbligo-badge { background: #f44336; color: white; padding: 4px 8px; border-radius: 4px; font-size: 10px; }';
            html += '.no-badge { background: #e8f5e9; color: #2e7d32; padding: 4px 8px; border-radius: 4px; font-size: 10px; }';
            html += '.wallet-section { margin-bottom: 25px; page-break-inside: avoid; }';
            html += '.wallet-header { background: #f5f5f5; padding: 10px; margin-bottom: 10px; }';
            html += '.total-row { background: #e3f2fd; font-weight: 700; }';
            html += '.footer { margin-top: 30px; padding-top: 20px; border-top: 1px solid #ddd; font-size: 10px; color: #666; text-align: center; }';
            html += '.info-box { background: #fff3e0; border: 1px solid #ff9800; padding: 12px; margin-bottom: 20px; font-size: 11px; }';
            html += '</style></head><body>';
            
            // Header
            html += '<div class="header">';
            html += '<h1>TAX REPORT - QUADRO RW</h1>';
            html += '<p>Generato il ' + dateStr + ' | CryptoFolio</p>';
            html += '</div>';
            
            // Info box
            html += '<div class="info-box">';
            html += '<strong>NOTA:</strong> Valore criptovalute al 31/12. Soglia Quadro RW: 15.000 EUR. Consultare commercialista.';
            html += '</div>';
            
            // Summary table con colonne separate
            html += '<div class="summary"><h2>RIEPILOGO ANNUALE</h2>';
            html += '<table><thead><tr><th>ANNO</th><th>WALLET</th><th>EXCHANGE</th><th>TOTALE EUR</th><th>QUADRO RW</th></tr></thead><tbody>';
            
            for (const y of years) {
                const t = combinedTotals[y];
                const above = (t.eur || 0) >= 15000;
                html += '<tr class="' + (above ? 'obbligo' : '') + '">';
                html += '<td><strong>' + y + '</strong></td>';
                html += '<td class="value-eur">EUR ' + formatEUR(t.walletEur || 0) + '</td>';
                html += '<td class="value-exchange">EUR ' + formatEUR(t.exchangeEur || 0) + '</td>';
                html += '<td class="value-eur" style="font-size:16px;">EUR ' + formatEUR(t.eur || 0) + '</td>';
                html += '<td>' + (above ? '<span class="obbligo-badge">SI - OBBLIGO</span>' : '<span class="no-badge">NO</span>') + '</td>';
                html += '</tr>';
            }
            
            html += '</tbody></table>';
            html += '<p style="font-size:11px;color:#666;">Aggregato da ' + (data.walletCount || 0) + ' wallet' + (hasExchange ? ' + Exchange' : '') + ' | Chain: ' + (data.chainNames || 'N/A') + '</p>';
            html += '</div>';
            
            // Wallet details
            html += '<h2 style="font-size:16px;margin:20px 0 15px;background:#f5f5f5;padding:10px;">DETTAGLIO PER WALLET</h2>';
            
            for (const wd of (data.walletDetails || [])) {
                if (!wd) continue;
                html += '<div class="wallet-section">';
                html += '<div class="wallet-header"><strong>' + (wd.walletName || 'Wallet') + '</strong> - ' + (wd.walletAddress || '') + '</div>';
                html += '<table><thead><tr><th style="text-align:left;">TOKEN</th>';
                for (const y of years) {
                    html += '<th>' + y + '</th>';
                }
                html += '</tr></thead><tbody>';
                
                for (const row of (wd.rows || [])) {
                    if (!row) continue;
                    html += '<tr><td style="text-align:left;"><strong>' + (row.tokenKey || '?') + '</strong></td>';
                    for (const y of years) {
                        const cell = row.cells ? row.cells[y] : null;
                        if (cell && cell.hasValue) {
                            html += '<td class="value-eur">EUR ' + formatEUR(cell.eur || 0) + '<br><small style="color:#666;">' + formatNum(cell.balance || 0, 2) + '</small></td>';
                        } else if (cell && cell.balance > 0) {
                            html += '<td><small>' + formatNum(cell.balance || 0, 2) + '</small></td>';
                        } else {
                            html += '<td>-</td>';
                        }
                    }
                    html += '</tr>';
                }
                
                html += '<tr class="total-row"><td style="text-align:left;"><strong>TOTALE</strong></td>';
                for (const y of years) {
                    const tot = wd.totals ? wd.totals[y] : null;
                    html += '<td class="value-eur">EUR ' + formatEUR(tot ? (tot.eur || 0) : 0) + '</td>';
                }
                html += '</tr></tbody></table></div>';
            }
            
            // Footer
            html += '<div class="footer">';
            html += '<p>Documento generato da CryptoFolio | Solo uso informativo</p>';
            html += '</div>';
            
            html += '</body></html>';
            
            // Open print window
            const printWindow = window.open('', '_blank');
            if (printWindow) {
                printWindow.document.write(html);
                printWindow.document.close();
                printWindow.onload = function() { printWindow.print(); };
            } else {
                alert('Popup bloccato! Abilita i popup per stampare.');
            }
        }
        
        function clearTaxReport() {
            if (!confirm('Vuoi cancellare il Tax Report salvato?')) return;
            taxReportData = null;
            document.getElementById('taxReportContent').innerHTML = '<div class="empty-state"><div class="icon">üëÜ</div><h3>Clicca "Calcola Tutti" per iniziare</h3></div>';
            document.getElementById('taxDetailCard').style.display = 'none';
            saveToFirebase();
            alert('Tax Report resettato!');
        }
        
        function saveExchangeValues() {
            const years = [2021, 2022, 2023, 2024, 2025, 2026];
            for (const y of years) {
                const val = parseFloat(document.getElementById('exchange' + y).value) || 0;
                exchangeValues[y] = val;
            }
            saveToFirebase();
            alert('‚úÖ Valori Exchange salvati!');
            
            // Ricalcola se c'√® gi√† un report
            if (taxReportData) {
                renderTaxReport(taxReportData);
            }
        }
        
        function loadExchangeValuesUI() {
            const years = [2021, 2022, 2023, 2024, 2025, 2026];
            for (const y of years) {
                const input = document.getElementById('exchange' + y);
                if (input && exchangeValues[y]) {
                    // Formatta con max 2 decimali
                    input.value = parseFloat(exchangeValues[y]).toFixed(2);
                }
            }
        }
        
        function updateTaxWalletsList() {
            const container = document.getElementById('taxWalletsList');
            if (!container) return;
            
            if (savedWallets.length === 0) {
                container.innerHTML = '<p style="color:var(--red);">‚ö†Ô∏è Nessun wallet salvato. Vai su <strong>Wallets</strong> per aggiungerne.</p>';
                document.getElementById('taxReportContent').innerHTML = '<div class="empty-state"><div class="icon">üëõ</div><h3>Aggiungi wallet prima</h3></div>';
                return;
            }
            
            let html = '<div style="display:flex;flex-wrap:wrap;gap:8px;">';
            savedWallets.forEach(w => {
                const shortAddr = w.address.slice(0, 6) + '...' + w.address.slice(-4);
                html += `<span style="background:var(--bg-primary);padding:6px 12px;border-radius:8px;font-size:13px;">üëõ ${w.name} <span style="color:var(--text-secondary);">(${shortAddr})</span></span>`;
            });
            html += '</div>';
            container.innerHTML = html;
        }
        
        // ==================== API MANAGEMENT ====================
        function saveMoralisKey() {
            const key = document.getElementById('moralisKey').value.trim();
            if (!key) {
                alert('Inserisci una API key valida');
                return;
            }
            
            // Supporta multiple keys separate da virgola o a capo
            const keys = key.split(/[,\n]/).map(k => k.trim()).filter(k => k.length > 10);
            
            if (keys.length === 0) {
                alert('Inserisci almeno una API key valida');
                return;
            }
            
            // Salva array di keys
            moralisKeys = keys;
            currentMoralisKeyIndex = 0;
            moralisKeyFailures = {};
            
            // Mantieni compatibilit√† con vecchio sistema
            apiKeys.moralis = keys[0];
            apiKeys.moralisKeys = keys;
            
            localStorage.setItem('cryptofolio_apikeys', JSON.stringify(apiKeys));
            localStorage.setItem('cryptofolio_moralis_keys', JSON.stringify(keys));
            saveToFirebase();
            updateApiStatus();
            
            if (keys.length > 1) {
                alert(`‚úÖ ${keys.length} Moralis API keys salvate!\n\nLe chiavi verranno usate in cascata quando una raggiunge il limite.`);
            } else {
                alert('‚úÖ Moralis API key salvata!');
            }
        }
        
        // Funzione per ottenere la key Moralis corrente
        function getMoralisKey() {
            if (moralisKeys.length === 0) {
                // Carica da localStorage se non ancora caricato
                loadMoralisKeys();
            }
            
            if (moralisKeys.length === 0) {
                return apiKeys.moralis || null;
            }
            
            return moralisKeys[currentMoralisKeyIndex] || moralisKeys[0];
        }
        
        // Carica le keys Moralis
        function loadMoralisKeys() {
            try {
                const saved = localStorage.getItem('cryptofolio_moralis_keys');
                if (saved) {
                    moralisKeys = JSON.parse(saved);
                    console.log(`üîë Caricate ${moralisKeys.length} Moralis API keys`);
                } else if (apiKeys.moralis) {
                    moralisKeys = [apiKeys.moralis];
                }
            } catch (e) {
                if (apiKeys.moralis) {
                    moralisKeys = [apiKeys.moralis];
                }
            }
        }
        
        // Ruota alla prossima key quando una fallisce
        function rotateMoralisKey(reason = '') {
            if (moralisKeys.length <= 1) return false;
            
            const oldIndex = currentMoralisKeyIndex;
            const oldKey = moralisKeys[oldIndex];
            
            // Segna questa key come fallita
            moralisKeyFailures[oldKey] = (moralisKeyFailures[oldKey] || 0) + 1;
            
            // Passa alla prossima
            currentMoralisKeyIndex = (currentMoralisKeyIndex + 1) % moralisKeys.length;
            
            // Se abbiamo provato tutte le keys, resetta i contatori
            if (currentMoralisKeyIndex === 0) {
                console.warn('‚ö†Ô∏è Tutte le Moralis API keys hanno raggiunto il limite!');
                return false;
            }
            
            console.log(`üîÑ Moralis API key rotata: ${oldIndex + 1} ‚Üí ${currentMoralisKeyIndex + 1} (${reason})`);
            return true;
        }
        
        function saveEtherscanKey() {
            const key = document.getElementById('etherscanKey').value.trim();
            if (!key) {
                alert('Inserisci una API key valida');
                return;
            }
            apiKeys.etherscan = key;
            // Also update the old apiKey field for backward compatibility
            document.getElementById('apiKey').value = key;
            localStorage.setItem('cryptofolio_apikeys', JSON.stringify(apiKeys));
            saveToFirebase();
            updateApiStatus();
            alert('‚úÖ Etherscan API key salvata!');
        }
        
        function saveHeliusKey() {
            const key = document.getElementById('heliusKey').value.trim();
            if (!key) {
                alert('Inserisci una API key valida');
                return;
            }
            apiKeys.helius = key;
            localStorage.setItem('cryptofolio_apikeys', JSON.stringify(apiKeys));
            saveToFirebase();
            updateApiStatus();
            alert('‚úÖ Helius API key salvata! Solana scan migliorato.');
        }
        
        function updateApiStatus() {
            // Update status badges
            const moralisStatus = document.getElementById('moralisStatus');
            const etherscanStatus = document.getElementById('etherscanStatus');
            
            if (moralisStatus) {
                if (apiKeys.moralis) {
                    moralisStatus.textContent = 'ON';
                    moralisStatus.classList.add('api-on');
                } else {
                    moralisStatus.textContent = 'OFF';
                    moralisStatus.classList.remove('api-on');
                }
            }
            
            if (etherscanStatus) {
                if (apiKeys.etherscan) {
                    etherscanStatus.textContent = 'ON';
                    etherscanStatus.classList.add('api-on');
                } else {
                    etherscanStatus.textContent = 'OFF';
                    etherscanStatus.classList.remove('api-on');
                }
            }
            
            const heliusStatus = document.getElementById('heliusStatus');
            if (heliusStatus) {
                if (apiKeys.helius) {
                    heliusStatus.textContent = 'ON';
                    heliusStatus.classList.add('api-on');
                } else {
                    heliusStatus.textContent = 'OFF';
                    heliusStatus.classList.remove('api-on');
                }
            }
            
            // Fill input fields
            if (document.getElementById('moralisKey')) {
                // Mostra tutte le keys separate da newline
                loadMoralisKeys();
                if (moralisKeys.length > 0) {
                    document.getElementById('moralisKey').value = moralisKeys.join('\n');
                } else if (apiKeys.moralis) {
                    document.getElementById('moralisKey').value = apiKeys.moralis;
                }
            }
            if (document.getElementById('etherscanKey') && apiKeys.etherscan) {
                document.getElementById('etherscanKey').value = apiKeys.etherscan;
            }
            if (document.getElementById('heliusKey') && apiKeys.helius) {
                document.getElementById('heliusKey').value = apiKeys.helius;
            }
            
            // Update API count badge
            updateApiCount();
            
            // Update summary
            const summary = document.getElementById('apiSummary');
            if (summary) {
                let html = '';
                
                // Moralis
                const moralisCount = moralisKeys.length || (apiKeys.moralis ? 1 : 0);
                const moralisStatus = moralisCount > 1 ? `‚úì ${moralisCount} keys` : (moralisCount === 1 ? '‚úì Configurato' : '‚úó Non configurato');
                html += `<div style="padding:16px;background:var(--bg-primary);border-radius:10px;text-align:center;">
                    <div style="font-size:24px;margin-bottom:8px;">üü¢</div>
                    <div style="font-weight:600;">Moralis</div>
                    <div style="font-size:12px;color:${moralisCount > 0 ? 'var(--green)' : 'var(--red)'};">${moralisStatus}</div>
                </div>`;
                
                // Etherscan
                html += `<div style="padding:16px;background:var(--bg-primary);border-radius:10px;text-align:center;">
                    <div style="font-size:24px;margin-bottom:8px;">üîµ</div>
                    <div style="font-weight:600;">Etherscan</div>
                    <div style="font-size:12px;color:${apiKeys.etherscan ? 'var(--green)' : 'var(--red)'};">${apiKeys.etherscan ? '‚úì Configurato' : '‚úó Non configurato'}</div>
                </div>`;
                
                // PulseChain
                html += `<div style="padding:16px;background:var(--bg-primary);border-radius:10px;text-align:center;">
                    <div style="font-size:24px;margin-bottom:8px;">üíö</div>
                    <div style="font-weight:600;">PulseChain</div>
                    <div style="font-size:12px;color:var(--green);">‚úì Auto</div>
                </div>`;
                
                // Solana / Helius
                html += `<div style="padding:16px;background:var(--bg-primary);border-radius:10px;text-align:center;">
                    <div style="font-size:24px;margin-bottom:8px;">üü£</div>
                    <div style="font-weight:600;">Solana</div>
                    <div style="font-size:12px;color:${apiKeys.helius ? 'var(--green)' : 'var(--red)'};">${apiKeys.helius ? '‚úì Helius' : '‚úó Configura Helius'}</div>
                </div>`;
                
                summary.innerHTML = html;
            }
        }
        
        function updateApiCount() {
            let count = 1; // PulseChain sempre attiva
            if (apiKeys.moralis) count++;
            if (apiKeys.etherscan) count++;
            if (apiKeys.helius) count++;
            document.getElementById('apiCount').textContent = count;
        }
        
        // ==================== HELIUS API (SOLANA) ====================
        async function fetchWithHelius(addr) {
            if (!apiKeys.helius) return null;
            
            try {
                console.log('Fetching Solana data with Helius for', addr);
                
                // Helius balances endpoint - restituisce SOL + tutti i token SPL
                const url = `https://api.helius.xyz/v0/addresses/${addr}/balances?api-key=${apiKeys.helius}`;
                const response = await fetch(url);
                
                if (!response.ok) {
                    console.error('Helius API error:', response.status);
                    return null;
                }
                
                const data = await response.json();
                console.log('Helius response:', data);
                
                const results = [];
                
                // Native SOL balance
                if (data.nativeBalance) {
                    const solBalance = data.nativeBalance / 1e9; // lamports to SOL
                    const solPrice = NATIVE_PRICES.SOL || 150;
                    
                    if (solBalance > 0.0001) {
                        results.push({
                            symbol: 'SOL',
                            name: 'Solana',
                            balance: solBalance,
                            price: solPrice,
                            valueUSD: solBalance * solPrice,
                            contract: 'native-solana',
                            logo: TOKEN_ICONS['SOL'],
                            chain: 'solana'
                        });
                        console.log('SOL balance:', solBalance, 'USD:', solBalance * solPrice);
                    }
                }
                
                // Token balances
                if (data.tokens && data.tokens.length > 0) {
                    for (const token of data.tokens) {
                        if (!token.amount || token.amount <= 0) continue;
                        
                        const decimals = token.decimals || 0;
                        const balance = token.amount / Math.pow(10, decimals);
                        
                        if (balance <= 0) continue;
                        
                        // Try to get price from DexScreener
                        let price = 0;
                        let logo = null;
                        let symbol = token.symbol || 'SPL';
                        let name = token.name || 'Solana Token';
                        
                        const pd = await fetchTokenPrice(token.mint, 'solana');
                        if (pd) {
                            price = pd.price;
                            if (pd.logo) logo = pd.logo;
                            if (pd.symbol) symbol = pd.symbol;
                            if (pd.name) name = pd.name;
                        }
                        
                        // Skip dust (< $0.01)
                        const valueUSD = balance * price;
                        if (valueUSD < 0.01 && price > 0) continue;
                        
                        results.push({
                            symbol: symbol,
                            name: name,
                            balance: balance,
                            price: price,
                            valueUSD: valueUSD,
                            contract: token.mint,
                            logo: logo,
                            chain: 'solana'
                        });
                    }
                }
                
                console.log('Helius found', results.length, 'assets');
                return results;
                
            } catch (e) {
                console.error('Helius fetch error:', e);
                return null;
            }
        }
        
        // ==================== MORALIS API ====================
        async function fetchWithMoralis(addr, chainKey, retryCount = 0) {
            const moralisKey = getMoralisKey();
            if (!moralisKey || !MORALIS_CHAINS[chainKey]) return null;
            
            try {
                const chain = MORALIS_CHAINS[chainKey];
                
                // Get native balance
                const nativeRes = await fetch(`https://deep-index.moralis.io/api/v2.2/${addr}/balance?chain=${chain}`, {
                    headers: { 'X-API-Key': moralisKey }
                });
                
                // Controlla rate limit
                if (nativeRes.status === 429 || nativeRes.status === 400) {
                    console.warn(`‚ö†Ô∏è Moralis rate limit (key ${currentMoralisKeyIndex + 1})`);
                    if (rotateMoralisKey('rate limit') && retryCount < moralisKeys.length) {
                        return fetchWithMoralis(addr, chainKey, retryCount + 1);
                    }
                    return null;
                }
                
                const nativeData = await nativeRes.json();
                
                // Get token balances
                const tokenRes = await fetch(`https://deep-index.moralis.io/api/v2.2/${addr}/erc20?chain=${chain}`, {
                    headers: { 'X-API-Key': moralisKey }
                });
                
                // Controlla rate limit
                if (tokenRes.status === 429 || tokenRes.status === 400) {
                    console.warn(`‚ö†Ô∏è Moralis rate limit (key ${currentMoralisKeyIndex + 1})`);
                    if (rotateMoralisKey('rate limit') && retryCount < moralisKeys.length) {
                        return fetchWithMoralis(addr, chainKey, retryCount + 1);
                    }
                    return null;
                }
                
                const tokenData = await tokenRes.json();
                
                return {
                    nativeBalance: nativeData.balance || '0',
                    tokens: tokenData || []
                };
            } catch (e) {
                console.error('Moralis error:', e);
                // Prova a ruotare la key anche per errori di rete
                if (rotateMoralisKey('network error') && retryCount < moralisKeys.length) {
                    return fetchWithMoralis(addr, chainKey, retryCount + 1);
                }
                return null;
            }
        }
        
        async function scanWithMoralis(addr, chainKey) {
            const chainInfo = CHAINS[chainKey];
            const moralisData = await fetchWithMoralis(addr, chainKey);
            
            if (!moralisData) return [];
            
            const results = [];
            
            // Native balance
            const nativeBal = moralisData.nativeBalance ? Number(BigInt(moralisData.nativeBalance)) / 1e18 : 0;
            let nativePrice = NATIVE_PRICES[chainInfo.symbol] || NATIVE_PRICES.ETH;
            
            // FIX: Forza prezzo corretto per CRO (evita bug Moralis/DexScreener)
            if (chainInfo.symbol === 'CRO' && (nativePrice > 1 || nativePrice === 0)) {
                nativePrice = NATIVE_PRICES.CRO || 0.09;
            }
            
            if (nativeBal > 0.0001) {
                results.push({
                    symbol: chainInfo.symbol,
                    name: `${chainInfo.symbol} (${chainInfo.name})`,
                    balance: nativeBal,
                    price: nativePrice,
                    valueUSD: nativeBal * nativePrice,
                    contract: `native-${chainKey}`,
                    logo: TOKEN_ICONS[chainInfo.symbol],
                    chain: chainKey
                });
            }
            
            // Token balances - check if tokens exists and is array
            if (moralisData.tokens && Array.isArray(moralisData.tokens)) {
                for (const token of moralisData.tokens) {
                    if (isBlacklisted(token.token_address) || isSpam(token.name, token.symbol)) continue;
                    
                    const bal = Number(BigInt(token.balance)) / Math.pow(10, token.decimals || 18);
                    if (bal <= 0) continue;
                    
                    let price = 0, logo = TOKEN_ICONS[token.symbol?.toUpperCase()] || token.logo || null;
                    
                    // Get price from DexScreener
                    const pd = await fetchTokenPrice(token.token_address, chainInfo.dex);
                    if (pd) { price = pd.price; if (pd.logo) logo = pd.logo; }
                    
                    // FIX: Forza prezzo corretto per WCRO e token CRO-like su Cronos
                    const sym = (token.symbol || '').toUpperCase();
                    if ((sym === 'WCRO' || sym === 'CRO') && (price > 1 || price === 0)) {
                        price = NATIVE_PRICES.CRO || 0.09;
                    }
                    
                    results.push({
                        symbol: token.symbol,
                        name: token.name,
                        balance: bal,
                        price,
                        valueUSD: bal * price,
                        contract: token.token_address.toLowerCase(),
                        logo,
                        chain: chainKey
                    });
                }
            }
            
            return results;
        }
        
        // ==================== WALLET TRANSACTIONS (MORALIS + ETHERSCAN FALLBACK) ====================
        
        // Etherscan-compatible API endpoints (include PulseScan)
        const ETHERSCAN_TX_APIS = {
            eth: 'https://api.etherscan.io/api',
            bsc: 'https://api.bscscan.com/api',
            polygon: 'https://api.polygonscan.com/api',
            arbitrum: 'https://api.arbiscan.io/api',
            base: 'https://api.basescan.org/api',
            pulse: 'https://api.scan.pulsechain.com/api'  // PulseScan - no API key needed!
        };
        
        // Scarica transazioni via Etherscan/PulseScan (fallback)
        async function fetchTxEtherscan(addr, chainKey, type = 'native') {
            const apiUrl = ETHERSCAN_TX_APIS[chainKey];
            if (!apiUrl) return [];
            
            // PulseScan non richiede API key
            const needsKey = chainKey !== 'pulse';
            const etherscanKey = apiKeys.etherscan;
            if (needsKey && !etherscanKey) return [];
            
            try {
                const action = type === 'native' ? 'txlist' : 'tokentx';
                let url = `${apiUrl}?module=account&action=${action}&address=${addr}&startblock=0&endblock=99999999&sort=desc`;
                if (needsKey) url += `&apikey=${etherscanKey}`;
                
                console.log(`üì° ${chainKey === 'pulse' ? 'PulseScan' : 'Etherscan'} ${type} tx: ${chainKey}`);
                const res = await fetch(url);
                const data = await res.json();
                
                if (data.status === '1' && Array.isArray(data.result)) {
                    console.log(`‚úÖ Got ${data.result.length} ${type} tx from ${chainKey}`);
                    return data.result;
                }
                return [];
            } catch (e) {
                console.error(`Scanner error (${chainKey}):`, e);
                return [];
            }
        }
        
        // Scarica transazioni native (ETH, BNB transfers) - Moralis con Etherscan/PulseScan fallback
        async function fetchNativeTxMoralis(addr, chainKey, cursor = null, retryCount = 0) {
            if (moralisKeys.length === 0) loadMoralisKeys();
            
            const moralisKey = getMoralisKey();
            const chain = MORALIS_CHAINS[chainKey];
            
            // PulseChain: usa direttamente PulseScan (non supportato da Moralis)
            if (chainKey === 'pulse') {
                console.log(`üì° PulseScan native tx: pulse`);
                const results = await fetchTxEtherscan(addr, 'pulse', 'native');
                return { result: results, cursor: null, source: 'pulsescan' };
            }
            
            // Se non c'√® Moralis o chain non supportata, prova Etherscan
            if (!moralisKey || !chain) {
                if (ETHERSCAN_TX_APIS[chainKey]) {
                    console.log(`üì° Etherscan fallback native tx: ${chainKey}`);
                    const results = await fetchTxEtherscan(addr, chainKey, 'native');
                    return { result: results, cursor: null, source: 'etherscan' };
                }
                return { result: [], cursor: null };
            }
            
            try {
                let url = `https://deep-index.moralis.io/api/v2.2/${addr}?chain=${chain}&limit=100`;
                if (cursor) url += `&cursor=${cursor}`;
                
                console.log(`üì° Moralis native tx: ${chainKey} (key #${currentMoralisKeyIndex + 1}/${moralisKeys.length})`);
                const res = await fetch(url, { headers: { 'X-API-Key': moralisKey } });
                
                if (res.status === 429 || res.status === 401) {
                    // Prova rotazione
                    if (rotateMoralisKey(`status ${res.status}`) && retryCount < moralisKeys.length) {
                        await new Promise(r => setTimeout(r, 300));
                        return fetchNativeTxMoralis(addr, chainKey, cursor, retryCount + 1);
                    }
                    
                    // Tutte le key Moralis fallite - usa Etherscan
                    if (ETHERSCAN_TX_APIS[chainKey] && apiKeys.etherscan) {
                        console.log(`‚ö†Ô∏è Moralis esaurito, uso Etherscan per ${chainKey}`);
                        const results = await fetchTxEtherscan(addr, chainKey, 'native');
                        console.log(`‚úÖ Etherscan fallback: ${results.length} native tx`);
                        return { result: results, cursor: null, source: 'etherscan' };
                    }
                    return { result: [], cursor: null };
                }
                
                if (!res.ok) return { result: [], cursor: null };
                
                const data = await res.json();
                console.log(`‚úÖ Moralis: ${data.result?.length || 0} native tx from ${chainKey}`);
                return { result: data.result || [], cursor: data.cursor || null, source: 'moralis' };
            } catch (e) {
                console.error('Moralis error:', e);
                // Fallback Etherscan
                if (ETHERSCAN_TX_APIS[chainKey] && apiKeys.etherscan) {
                    const results = await fetchTxEtherscan(addr, chainKey, 'native');
                    return { result: results, cursor: null, source: 'etherscan' };
                }
                return { result: [], cursor: null };
            }
        }
        
        // Scarica trasferimenti token ERC20 - Moralis con Etherscan/PulseScan fallback
        async function fetchTokenTxMoralis(addr, chainKey, cursor = null, retryCount = 0) {
            if (moralisKeys.length === 0) loadMoralisKeys();
            
            const moralisKey = getMoralisKey();
            const chain = MORALIS_CHAINS[chainKey];
            
            // PulseChain: usa direttamente PulseScan
            if (chainKey === 'pulse') {
                console.log(`üì° PulseScan token tx: pulse`);
                const results = await fetchTxEtherscan(addr, 'pulse', 'token');
                return { result: results, cursor: null, source: 'pulsescan' };
            }
            
            if (!moralisKey || !chain) {
                if (ETHERSCAN_TX_APIS[chainKey]) {
                    console.log(`üì° Etherscan fallback token tx: ${chainKey}`);
                    const results = await fetchTxEtherscan(addr, chainKey, 'token');
                    return { result: results, cursor: null, source: 'etherscan' };
                }
                return { result: [], cursor: null };
            }
            
            try {
                let url = `https://deep-index.moralis.io/api/v2.2/${addr}/erc20/transfers?chain=${chain}&limit=100`;
                if (cursor) url += `&cursor=${cursor}`;
                
                const res = await fetch(url, { headers: { 'X-API-Key': moralisKey } });
                
                if (res.status === 429 || res.status === 401) {
                    if (rotateMoralisKey(`status ${res.status}`) && retryCount < moralisKeys.length) {
                        await new Promise(r => setTimeout(r, 300));
                        return fetchTokenTxMoralis(addr, chainKey, cursor, retryCount + 1);
                    }
                    
                    // Fallback Etherscan
                    if (ETHERSCAN_TX_APIS[chainKey] && apiKeys.etherscan) {
                        console.log(`‚ö†Ô∏è Moralis esaurito, uso Etherscan per ${chainKey}`);
                        const results = await fetchTxEtherscan(addr, chainKey, 'token');
                        console.log(`‚úÖ Etherscan fallback: ${results.length} token tx`);
                        return { result: results, cursor: null, source: 'etherscan' };
                    }
                    return { result: [], cursor: null };
                }
                
                const data = await res.json();
                console.log(`‚úÖ Moralis: ${data.result?.length || 0} token tx from ${chainKey}`);
                return { result: data.result || [], cursor: data.cursor || null, source: 'moralis' };
            } catch (e) {
                if (ETHERSCAN_TX_APIS[chainKey] && apiKeys.etherscan) {
                    const results = await fetchTxEtherscan(addr, chainKey, 'token');
                    return { result: results, cursor: null, source: 'etherscan' };
                }
                return { result: [], cursor: null };
            }
        }
        
        // Scarica tutte le transazioni per un wallet (formato compatto)
        async function downloadWalletTransactions(addr, progressCallback) {
            const addrLower = addr.toLowerCase();
            const chainsToScan = ['eth', 'polygon', 'bsc', 'arbitrum', 'base', 'pulse'];
            
            console.log(`üöÄ Download transazioni per ${addrLower.slice(0,10)}...`);
            
            const nativeTx = [];
            const tokenTx = [];
            
            for (const chainKey of chainsToScan) {
                const chainSymbol = CHAINS[chainKey]?.symbol || 'ETH';
                
                // Download native transactions
                if (progressCallback) progressCallback(`${CHAINS[chainKey]?.name || chainKey} native...`);
                const { result: nativeResult, source: nativeSource } = await fetchNativeTxMoralis(addr, chainKey, null);
                
                for (const tx of nativeResult) {
                    let value, date;
                    
                    if (nativeSource === 'etherscan' || nativeSource === 'pulsescan') {
                        value = tx.value ? Number(tx.value) / 1e18 : 0;
                        date = tx.timeStamp ? new Date(tx.timeStamp * 1000).toISOString().slice(0, 10) : '';
                    } else {
                        value = tx.value ? Number(tx.value) / 1e18 : 0;
                        date = tx.block_timestamp?.slice(0, 10) || '';
                    }
                    
                    if (value < 0.0000001) continue;
                    
                    const toAddr = (nativeSource === 'etherscan' || nativeSource === 'pulsescan' ? tx.to : tx.to_address)?.toLowerCase();
                    
                    nativeTx.push({
                        d: date,
                        t: toAddr === addrLower ? 'in' : 'out',
                        s: chainSymbol,
                        a: value,
                        h: tx.hash?.slice(0, 10) || '',
                        c: chainKey
                    });
                }
                
                await new Promise(r => setTimeout(r, 250));
                
                // Download token transfers
                if (progressCallback) progressCallback(`${CHAINS[chainKey]?.name || chainKey} token...`);
                const { result: tokenResult, source: tokenSource } = await fetchTokenTxMoralis(addr, chainKey, null);
                
                for (const tx of tokenResult) {
                    let symbol, name, value, date, toAddr;
                    
                    if (tokenSource === 'etherscan' || tokenSource === 'pulsescan') {
                        symbol = tx.tokenSymbol || 'UNKNOWN';
                        name = tx.tokenName || symbol;
                        const decimals = parseInt(tx.tokenDecimal) || 18;
                        value = tx.value ? Number(tx.value) / Math.pow(10, decimals) : 0;
                        date = tx.timeStamp ? new Date(tx.timeStamp * 1000).toISOString().slice(0, 10) : '';
                        toAddr = tx.to?.toLowerCase();
                    } else {
                        symbol = tx.token_symbol || 'UNKNOWN';
                        name = tx.token_name || symbol;
                        const decimals = parseInt(tx.token_decimals) || 18;
                        value = tx.value ? Number(tx.value) / Math.pow(10, decimals) : 0;
                        date = tx.block_timestamp?.slice(0, 10) || '';
                        toAddr = tx.to_address?.toLowerCase();
                    }
                    
                    if (isSpam(name, symbol)) continue;
                    if (value < 0.0000001) continue;
                    
                    tokenTx.push({
                        d: date,
                        t: toAddr === addrLower ? 'in' : 'out',
                        s: symbol,
                        a: value,
                        h: (tx.hash || tx.transaction_hash)?.slice(0, 10) || '',
                        c: chainKey
                    });
                }
                
                await new Promise(r => setTimeout(r, 250));
            }
            
            console.log(`üìä Download completato: ${nativeTx.length} native + ${tokenTx.length} token = ${nativeTx.length + tokenTx.length} totali`);
            return { nativeTx, tokenTx, lastDownload: Date.now() };
        }
        
        // Salva transazioni in localStorage
        function saveWalletTransactions() {
            try {
                const data = JSON.stringify(walletTransactions);
                if (data.length > 4000000) { // ~4MB limit
                    console.warn('‚ö†Ô∏è Transazioni troppo grandi per localStorage');
                    return false;
                }
                localStorage.setItem('cryptofolio_wallet_tx', data);
                console.log(`üíæ Salvate transazioni: ${(data.length / 1024).toFixed(1)} KB`);
                return true;
            } catch (e) {
                console.error('Errore salvataggio transazioni:', e);
                return false;
            }
        }
        
        // Carica transazioni da localStorage
        function loadWalletTransactions() {
            try {
                const saved = localStorage.getItem('cryptofolio_wallet_tx');
                if (saved) {
                    walletTransactions = JSON.parse(saved);
                    const totalTx = Object.values(walletTransactions).reduce((sum, w) => 
                        sum + (w.nativeTx?.length || 0) + (w.tokenTx?.length || 0), 0);
                    console.log(`üìÇ Caricate ${totalTx} transazioni wallet`);
                    return true;
                }
            } catch (e) {
                console.error('Errore caricamento transazioni:', e);
            }
            return false;
        }
        
        // Conta transazioni per un wallet
        function getWalletTxCount(addr) {
            // Carica da localStorage se non in memoria
            if (Object.keys(walletTransactions).length === 0) {
                loadWalletTransactions();
            }
            const data = walletTransactions[addr.toLowerCase()];
            if (!data) return 0;
            return (data.nativeTx?.length || 0) + (data.tokenTx?.length || 0);
        }
        
        // ==================== WALLET MANAGEMENT ====================
        function addWallet() {
            const name = document.getElementById('newWalletName').value.trim();
            const address = document.getElementById('newWalletAddress').value.trim();
            
            if (!name) { alert('Inserisci un nome per il wallet'); return; }
            
            // Validazione: EVM (0x + 40 hex) o Solana (32-44 chars base58)
            const isEVM = address.startsWith('0x') && address.length === 42 && /^0x[a-fA-F0-9]{40}$/.test(address);
            const isSolana = /^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(address);
            
            if (!isEVM && !isSolana) { 
                alert('Indirizzo wallet non valido.\n\nFormati supportati:\n‚Ä¢ EVM: 0x... (42 caratteri)\n‚Ä¢ Solana: base58 (32-44 caratteri)'); 
                return; 
            }
            
            // Check duplicate
            if (savedWallets.some(w => w.address.toLowerCase() === address.toLowerCase())) {
                alert('Questo wallet √® gi√† salvato');
                return;
            }
            
            // Detect wallet type
            const walletType = isSolana ? 'solana' : 'evm';
            
            savedWallets.push({ name, address, type: walletType, addedAt: Date.now() });
            localStorage.setItem('cryptofolio_wallets', JSON.stringify(savedWallets));
            
            document.getElementById('newWalletName').value = '';
            document.getElementById('newWalletAddress').value = '';
            
            updateWalletsList();
            updateWalletSelect();
            saveToFirebase();
            log(`‚úÖ Wallet "${name}" (${walletType.toUpperCase()}) aggiunto`, 'success');
        }
        
        function removeWallet(index) {
            if (confirm(`Rimuovere wallet "${savedWallets[index].name}"?`)) {
                savedWallets.splice(index, 1);
                localStorage.setItem('cryptofolio_wallets', JSON.stringify(savedWallets));
                updateWalletsList();
                updateWalletSelect();
                saveToFirebase();
            }
        }
        
        function selectWallet(index) {
            const wallet = savedWallets[index];
            document.getElementById('walletAddress').value = wallet.address;
            document.getElementById('walletSelect').value = index;
            showView('dashboard');
            log(`üëõ Wallet "${wallet.name}" selezionato`, 'info');
        }
        
        function onWalletSelect() {
            const select = document.getElementById('walletSelect');
            const idx = select.value;
            if (idx !== '' && savedWallets[idx]) {
                document.getElementById('walletAddress').value = savedWallets[idx].address;
            }
        }
        
        function updateWalletsList() {
            const container = document.getElementById('walletsList');
            document.getElementById('walletCount').textContent = savedWallets.length;
            
            if (savedWallets.length === 0) {
                container.innerHTML = '<p style="color:var(--text-secondary);padding:20px;text-align:center;">Nessun wallet salvato.<br>Aggiungi il tuo primo wallet sopra!</p>';
                return;
            }
            
            let html = '';
            savedWallets.forEach((w, i) => {
                const shortAddr = w.address.slice(0, 8) + '...' + w.address.slice(-6);
                // Calcola totale se scannerizzato
                const walletData = walletResults[w.address.toLowerCase()];
                const total = walletData ? walletData.results.reduce((s, t) => s + t.valueUSD, 0) * EUR_USD : 0;
                const totalStr = walletData ? `‚Ç¨${formatEUR(total)}` : '<span style="color:var(--text-secondary);">Non scansionato</span>';
                
                // Data ultima scansione
                const scanDate = walletData && walletData.scannedAt 
                    ? new Date(walletData.scannedAt).toLocaleString('it-IT', { day: '2-digit', month: '2-digit', year: '2-digit', hour: '2-digit', minute: '2-digit' })
                    : null;
                
                // Detect wallet type
                const isSolana = w.type === 'solana' || (!w.address.startsWith('0x') && /^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(w.address));
                const typeBadge = isSolana 
                    ? '<span style="background:#9945ff;color:#fff;padding:2px 6px;border-radius:4px;font-size:10px;margin-left:8px;">SOL</span>'
                    : '<span style="background:#627eea;color:#fff;padding:2px 6px;border-radius:4px;font-size:10px;margin-left:8px;">EVM</span>';
                
                html += `
                    <div style="display:flex;align-items:center;justify-content:space-between;padding:16px;background:var(--bg-primary);border-radius:12px;margin-bottom:12px;">
                        <div style="display:flex;align-items:center;gap:16px;cursor:pointer;flex:1;" onclick="openWalletDetail(${i})">
                            <div style="width:48px;height:48px;border-radius:12px;background:linear-gradient(135deg,${isSolana ? '#9945ff,#14f195' : 'var(--accent),var(--accent-light)'});display:flex;align-items:center;justify-content:center;font-size:20px;">üëõ</div>
                            <div>
                                <div style="font-weight:600;font-size:16px;">${w.name}${typeBadge}</div>
                                <div style="font-size:13px;color:var(--text-secondary);font-family:monospace;">${shortAddr}</div>
                            </div>
                            <div style="margin-left:auto;text-align:right;">
                                <div style="font-weight:600;color:var(--green);">${totalStr}</div>
                                ${scanDate ? `<div style="font-size:11px;color:var(--text-secondary);margin-top:2px;">üïê ${scanDate}</div>` : ''}
                            </div>
                        </div>
                        <div style="display:flex;gap:8px;margin-left:16px;">
                            <button class="btn btn-primary" onclick="selectWallet(${i})" style="padding:8px 16px;">üìä Scan</button>
                            <button class="btn btn-secondary" onclick="navigator.clipboard.writeText('${w.address}')" style="padding:8px 12px;">üìã</button>
                            <button class="btn btn-secondary" onclick="removeWallet(${i})" style="padding:8px 12px;color:var(--red);">üóëÔ∏è</button>
                        </div>
                    </div>
                `;
            });
            container.innerHTML = html;
        }
        
        function updateWalletSelect() {
            const select = document.getElementById('walletSelect');
            let html = '<option value="">-- Seleziona wallet salvato --</option>';
            savedWallets.forEach((w, i) => {
                const shortAddr = w.address.slice(0, 6) + '...' + w.address.slice(-4);
                html += `<option value="${i}">${w.name} (${shortAddr})</option>`;
            });
            select.innerHTML = html;
        }
        
        // ==================== WALLET DETAIL ====================
        function openWalletDetail(index) {
            const wallet = savedWallets[index];
            if (!wallet) return;
            
            currentDetailWallet = wallet;
            document.getElementById('detailWalletName').textContent = wallet.name;
            document.getElementById('detailWalletAddress').textContent = wallet.address;
            
            displayWalletDetail();
            showView('walletDetail');
        }
        
        function copyDetailAddress() {
            if (currentDetailWallet) {
                navigator.clipboard.writeText(currentDetailWallet.address);
                alert('Indirizzo copiato!');
            }
        }
        
        function displayWalletDetail() {
            if (!currentDetailWallet) return;
            
            const walletData = walletResults[currentDetailWallet.address.toLowerCase()];
            const container = document.getElementById('detailChainsContent');
            
            // Aggiorna data scansione
            const scanDateEl = document.getElementById('detailScanDate');
            if (walletData && walletData.scannedAt) {
                const scanDate = new Date(walletData.scannedAt).toLocaleString('it-IT', { 
                    day: '2-digit', month: '2-digit', year: 'numeric', 
                    hour: '2-digit', minute: '2-digit', second: '2-digit' 
                });
                scanDateEl.innerHTML = `üïê Ultima scansione: <strong>${scanDate}</strong>`;
            } else {
                scanDateEl.textContent = '‚ö†Ô∏è Mai scansionato';
            }
            
            if (!walletData || walletData.results.length === 0) {
                document.getElementById('detailTotal').textContent = '‚Ç¨0,00';
                document.getElementById('detailChainCount').textContent = '0';
                document.getElementById('detailTokenCount').textContent = '0';
                container.innerHTML = '<div class="card"><div class="empty-state"><div class="icon">üì≠</div><h3>Nessun dato</h3><p style="color:var(--text-secondary);">Clicca "Scan" per scansionare questo wallet</p></div></div>';
                return;
            }
            
            // Raggruppa token per chain (escludi blacklistati)
            const byChain = {};
            for (const token of walletData.results) {
                const contractAddr = token.contract || token.token_address || '';
                if (isBlacklisted(contractAddr)) continue;
                if (!byChain[token.chain]) byChain[token.chain] = [];
                byChain[token.chain].push(token);
            }
            
            // Calcola totali (escludi blacklistati)
            const visibleTokens = walletData.results.filter(t => !isBlacklisted(t.contract || t.token_address || ''));
            const totalUSD = visibleTokens.reduce((s, t) => s + t.valueUSD, 0);
            const totalEUR = totalUSD * EUR_USD;
            const chainCount = Object.keys(byChain).length;
            const tokenCount = visibleTokens.length;
            
            document.getElementById('detailTotal').textContent = '‚Ç¨' + formatEUR(totalEUR);
            document.getElementById('detailChainCount').textContent = chainCount;
            document.getElementById('detailTokenCount').textContent = tokenCount;
            
            // Conta transazioni
            const txCount = getWalletTxCount(currentDetailWallet.address);
            document.getElementById('detailTxCount').textContent = txCount;
            
            // Genera HTML per ogni chain
            let html = '';
            for (const [chainKey, tokens] of Object.entries(byChain)) {
                const chain = CHAINS[chainKey];
                const chainTotal = tokens.filter(t => !isBlacklisted(t.contract || t.token_address || '')).reduce((s, t) => s + t.valueUSD, 0) * EUR_USD;
                
                html += `
                    <div class="card" style="margin-bottom:16px;">
                        <div class="card-header">
                            <div class="card-title" style="display:flex;align-items:center;gap:10px;">
                                <span style="width:12px;height:12px;border-radius:50%;background:${chain?.color || '#666'};"></span>
                                ${chain?.name || chainKey}
                            </div>
                            <div style="font-weight:600;color:var(--green);">‚Ç¨${formatEUR(chainTotal)}</div>
                        </div>
                        <table class="holdings-table">
                            <thead><tr><th>TOKEN</th><th>BALANCE</th><th>PREZZO</th><th>VALORE</th></tr></thead>
                            <tbody>
                `;
                
                // Ordina token per valore
                tokens.sort((a, b) => b.valueUSD - a.valueUSD);
                
                for (const t of tokens) {
                    // Salta token blacklistati o con valore troppo basso
                    const contractAddr = t.contract || t.token_address || '';
                    if (isBlacklisted(contractAddr)) continue;
                    if (t.valueUSD < 0.01) continue;
                    
                    const vEUR = t.valueUSD * EUR_USD;
                    html += `
                        <tr>
                            <td><div class="token-cell">
                                <button class="hide-btn" onclick="hideToken('${contractAddr}','${t.symbol || ''}')">‚úï</button>
                                <div class="token-icon">${t.logo ? `<img src="${t.logo}" onerror="this.parentElement.textContent='${t.symbol?.slice(0,2) || '??'}'">` : (t.symbol?.slice(0,2) || '??')}</div>
                                <div class="token-info">
                                    <div class="symbol">${t.symbol || '???'}</div>
                                    <div class="name">${t.name || ''}</div>
                                </div>
                            </div></td>
                            <td class="text-right text-mono">${formatNum(t.balance, 4)}</td>
                            <td class="text-right text-mono text-secondary">$${t.price > 0 ? formatNum(t.price, 6) : '-'}</td>
                            <td class="text-right text-mono" style="color:var(--green);">‚Ç¨${formatEUR(vEUR)}</td>
                        </tr>
                    `;
                }
                
                html += '</tbody></table></div>';
            }
            
            container.innerHTML = html;
        }
        
        function showWalletTab(tab) {
            const tokensBtn = document.getElementById('tabTokensBtn');
            const txBtn = document.getElementById('tabTxBtn');
            const tokensContent = document.getElementById('detailChainsContent');
            const txContent = document.getElementById('detailTxContent');
            
            if (tab === 'tokens') {
                tokensBtn.className = 'btn btn-primary';
                txBtn.className = 'btn btn-secondary';
                tokensContent.style.display = 'block';
                txContent.style.display = 'none';
            } else {
                tokensBtn.className = 'btn btn-secondary';
                txBtn.className = 'btn btn-primary';
                tokensContent.style.display = 'none';
                txContent.style.display = 'block';
                displayWalletTransactions();
            }
        }
        
        function displayWalletTransactions() {
            if (!currentDetailWallet) return;
            
            const container = document.getElementById('detailTxContent');
            const addrLower = currentDetailWallet.address.toLowerCase();
            
            console.log('üîç displayWalletTransactions for:', addrLower.slice(0,10));
            console.log('üì¶ walletTransactions keys:', Object.keys(walletTransactions));
            
            // Carica da localStorage se non in memoria
            if (!walletTransactions[addrLower]) {
                console.log('üìÇ Not in memory, loading from localStorage...');
                loadWalletTransactions();
                console.log('üì¶ After load, keys:', Object.keys(walletTransactions));
            }
            
            const txData = walletTransactions[addrLower];
            console.log('üìä txData:', txData ? `native=${txData.nativeTx?.length}, token=${txData.tokenTx?.length}` : 'NULL');
            
            if (!txData || ((txData.nativeTx?.length || 0) === 0 && (txData.tokenTx?.length || 0) === 0)) {
                container.innerHTML = `
                    <div class="card">
                        <div class="empty-state">
                            <div class="icon">üì≠</div>
                            <h3>Nessuna transazione</h3>
                            <p style="color:var(--text-secondary);">Scansiona il wallet per scaricare le transazioni</p>
                            <p style="color:var(--yellow);font-size:12px;margin-top:12px;">
                                ‚ö†Ô∏è Moralis supporta: Ethereum, BSC, Polygon, Arbitrum, Base, Cronos<br>
                                PulseChain e Solana non sono supportati.
                            </p>
                        </div>
                    </div>`;
                return;
            }
            
            // Combina tutte le tx
            const allTx = [
                ...txData.nativeTx.map(tx => ({ ...tx, type: 'native' })),
                ...txData.tokenTx.map(tx => ({ ...tx, type: 'token' }))
            ].sort((a, b) => new Date(b.d) - new Date(a.d));
            
            // Raggruppa per CHAIN
            const byChain = {};
            for (const tx of allTx) {
                const chain = tx.c || 'unknown';
                if (!byChain[chain]) byChain[chain] = [];
                byChain[chain].push(tx);
            }
            
            // Raggruppa per anno (per stats)
            const byYear = {};
            for (const tx of allTx) {
                const year = tx.d?.slice(0, 4) || '????';
                if (!byYear[year]) byYear[year] = [];
                byYear[year].push(tx);
            }
            
            // STATS PER ANNO
            let html = '<div class="card" style="margin-bottom:16px;"><div class="card-header"><div class="card-title">üìä Transazioni per Anno</div></div>';
            html += '<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(80px,1fr));gap:8px;padding:12px;">';
            
            for (const year of Object.keys(byYear).sort().reverse()) {
                const yearTx = byYear[year];
                const inCount = yearTx.filter(tx => tx.t === 'in').length;
                const outCount = yearTx.filter(tx => tx.t === 'out').length;
                html += `
                    <div style="background:var(--bg-primary);padding:10px;border-radius:8px;text-align:center;">
                        <div style="font-weight:700;font-size:16px;">${year}</div>
                        <div style="font-size:11px;color:var(--text-secondary);">${yearTx.length} tx</div>
                        <div style="font-size:10px;margin-top:2px;">
                            <span style="color:var(--green);">‚Üì${inCount}</span> 
                            <span style="color:var(--red);">‚Üë${outCount}</span>
                        </div>
                    </div>`;
            }
            html += '</div></div>';
            
            // TRANSAZIONI PER CHAIN
            for (const chainKey of Object.keys(byChain).sort()) {
                const chainTx = byChain[chainKey];
                const chain = CHAINS[chainKey];
                const chainName = chain?.name || chainKey.toUpperCase();
                const chainColor = chain?.color || '#666';
                
                // Mostra solo ultime 50 per chain
                const recentChainTx = chainTx.slice(0, 50);
                
                html += `
                    <div class="card" style="margin-bottom:16px;">
                        <div class="card-header">
                            <div class="card-title" style="display:flex;align-items:center;gap:8px;">
                                <span style="width:12px;height:12px;border-radius:50%;background:${chainColor};"></span>
                                ${chainName}
                            </div>
                            <div style="font-size:12px;color:var(--text-secondary);">${chainTx.length} transazioni</div>
                        </div>
                        <div style="max-height:300px;overflow-y:auto;">
                            <table class="holdings-table">
                                <thead><tr><th>DATA</th><th>TIPO</th><th>TOKEN</th><th>QUANTIT√Ä</th></tr></thead>
                                <tbody>`;
                
                for (const tx of recentChainTx) {
                    const isIn = tx.t === 'in';
                    const color = isIn ? 'var(--green)' : 'var(--red)';
                    const arrow = isIn ? '‚Üì' : '‚Üë';
                    const formattedAmt = tx.a >= 1000000 
                        ? (tx.a / 1000000).toFixed(2) + 'M'
                        : tx.a >= 1000 
                            ? (tx.a / 1000).toFixed(2) + 'K'
                            : tx.a < 0.0001 
                                ? tx.a.toExponential(2)
                                : tx.a.toFixed(4);
                    
                    html += `
                        <tr>
                            <td style="font-size:11px;">${tx.d || '-'}</td>
                            <td style="color:${color};font-weight:600;font-size:12px;">${arrow} ${isIn ? 'IN' : 'OUT'}</td>
                            <td style="font-weight:500;">${tx.s || '???'}</td>
                            <td class="text-right text-mono" style="color:${color};font-size:12px;">${isIn ? '+' : '-'}${formattedAmt}</td>
                        </tr>`;
                }
                
                html += '</tbody></table></div>';
                
                if (chainTx.length > 50) {
                    html += `<div style="text-align:center;padding:8px;font-size:11px;color:var(--text-secondary);">
                        ... e altre ${chainTx.length - 50} transazioni
                    </div>`;
                }
                
                html += '</div>';
            }
            
            // Info download
            if (txData.lastDownload) {
                const downloadDate = new Date(txData.lastDownload).toLocaleString('it-IT');
                html += `<div style="text-align:center;padding:12px;font-size:12px;color:var(--text-secondary);">
                    üì• Scaricate il ${downloadDate} | Totale: ${allTx.length} transazioni
                </div>`;
            }
            
            container.innerHTML = html;
        }
        
        async function scanDetailWallet() {
            if (!currentDetailWallet) return;
            
            const etherscanKey = apiKeys.etherscan;
            if (!etherscanKey && !apiKeys.moralis) { 
                alert('Configura almeno una API in API Connect'); 
                return; 
            }
            if (selectedChains.length === 0) { alert('Seleziona almeno una chain nella Dashboard'); return; }
            
            // Scan del wallet
            const addr = currentDetailWallet.address;
            const results = [];
            
            await fetchEurUsd();
            await fetchNativePrices();
            
            for (const chainKey of selectedChains) {
                const chain = CHAINS[chainKey];
                
                // Try Moralis first for supported chains
                if (apiKeys.moralis && MORALIS_CHAINS[chainKey]) {
                    const moralisResults = await scanWithMoralis(addr, chainKey);
                    if (moralisResults && moralisResults.length > 0) {
                        results.push(...moralisResults);
                        await new Promise(r => setTimeout(r, 100));
                        continue;
                    }
                }
                
                // Fallback to Etherscan/PulseScan/Solana RPC
                if (!etherscanKey && chainKey !== 'pulse' && chainKey !== 'solana') {
                    continue;
                }
                
                // Native balance
                const nativeWei = await fetchNativeBalance(addr, etherscanKey, chain.id, chainKey);
                const nativeDecimals = chainKey === 'solana' ? 9 : 18;
                const nativeBal = Number(nativeWei) / Math.pow(10, nativeDecimals);
                const nativePrice = NATIVE_PRICES[chain.symbol] || NATIVE_PRICES.ETH;
                
                if (nativeBal > 0.0001) {
                    results.push({
                        symbol: chain.symbol,
                        name: `${chain.symbol} (${chain.name})`,
                        balance: nativeBal,
                        price: nativePrice,
                        valueUSD: nativeBal * nativePrice,
                        contract: `native-${chainKey}`,
                        logo: TOKEN_ICONS[chain.symbol],
                        chain: chainKey
                    });
                }
                
                // Token balances
                const tokens = await fetchTokenTransfers(addr, etherscanKey, chain.id, chainKey);
                
                for (const [c, t] of Object.entries(tokens)) {
                    if (isBlacklisted(c) || isSpam(t.name, t.symbol) || t.balance <= 0n) continue;
                    
                    const bal = Number(t.balance) / Math.pow(10, t.decimals);
                    let price = 0, logo = TOKEN_ICONS[t.symbol?.toUpperCase()] || null;
                    
                    const pd = await fetchTokenPrice(c, chain.dex);
                    if (pd) { price = pd.price; if (pd.logo) logo = pd.logo; }
                    
                    results.push({
                        symbol: t.symbol,
                        name: t.name,
                        balance: bal,
                        price,
                        valueUSD: bal * price,
                        contract: c,
                        logo,
                        chain: chainKey
                    });
                    
                    await new Promise(r => setTimeout(r, 150));
                }
                
                await new Promise(r => setTimeout(r, 200));
            }
            
            // Salva risultati
            walletResults[addr.toLowerCase()] = {
                name: currentDetailWallet.name,
                results: results,
                scannedAt: Date.now()
            };
            
            // Download transazioni se Moralis disponibile
            // Download transazioni se API disponibile (Moralis o Etherscan)
            if ((apiKeys.moralis || apiKeys.etherscan) && addr.startsWith('0x')) {
                const scanDateEl = document.getElementById('detailScanDate');
                
                // Progress bar HTML
                scanDateEl.innerHTML = `
                    <div style="margin-top:8px;">
                        <div style="display:flex;align-items:center;gap:8px;margin-bottom:4px;">
                            <div class="spinner" style="width:16px;height:16px;border:2px solid var(--accent);border-top-color:transparent;border-radius:50%;animation:spin 1s linear infinite;"></div>
                            <span id="txProgressText">üì• Download transazioni...</span>
                        </div>
                        <div style="height:6px;background:var(--bg-primary);border-radius:3px;overflow:hidden;">
                            <div id="txProgressBar" style="width:0%;height:100%;background:var(--accent);transition:width 0.3s;"></div>
                        </div>
                    </div>
                `;
                
                let progress = 0;
                const txData = await downloadWalletTransactions(addr, (status) => {
                    progress += 2;
                    if (progress > 95) progress = 95;
                    document.getElementById('txProgressText').textContent = `üì• ${status}`;
                    document.getElementById('txProgressBar').style.width = `${progress}%`;
                });
                
                walletTransactions[addr.toLowerCase()] = txData;
                saveWalletTransactions();
                
                const txCount = txData.nativeTx.length + txData.tokenTx.length;
                scanDateEl.innerHTML = `<span style="color:var(--green);">‚úÖ ${txCount} transazioni scaricate</span>`;
            }
            
            // Aggiorna display
            displayWalletDetail();
            updateWalletsList();
            aggregateAndDisplay();
            saveToFirebase();
        }
        
        function initChainSelector() {
            const container = document.getElementById('chainSelector');
            let html = '';
            for (const [key, chain] of Object.entries(CHAINS)) {
                const active = selectedChains.includes(key) ? 'active' : '';
                html += `<button class="chain-btn ${active}" data-chain="${key}" onclick="toggleChain('${key}')">
                    <span class="chain-dot" style="background:${chain.color}"></span>${chain.name}
                </button>`;
            }
            container.innerHTML = html;
        }
        
        function toggleChain(key) {
            const idx = selectedChains.indexOf(key);
            if (idx >= 0) selectedChains.splice(idx, 1);
            else selectedChains.push(key);
            localStorage.setItem('cryptofolio_chains', JSON.stringify(selectedChains));
            initChainSelector();
            saveToFirebase();
        }
        
        function loadSettings() {
            const w = localStorage.getItem('cryptofolio_wallet');
            const oldKey = localStorage.getItem('etherscan_api_key');
            
            if (w) document.getElementById('walletAddress').value = w;
            
            // Backward compatibility: migra vecchia API key a nuovo sistema
            if (oldKey && !apiKeys.etherscan) {
                apiKeys.etherscan = oldKey;
                localStorage.setItem('cryptofolio_apikeys', JSON.stringify(apiKeys));
                localStorage.removeItem('etherscan_api_key'); // Rimuovi vecchia chiave
            }
        }
        
        function saveSettings() {
            const w = document.getElementById('walletAddress').value.trim();
            if (w) localStorage.setItem('cryptofolio_wallet', w);
            saveToFirebase();
        }
        
        // ==================== API ====================
        async function fetchEurUsd() { 
            try { 
                const r = await fetch('https://api.exchangerate-api.com/v4/latest/USD'); 
                const d = await r.json(); 
                EUR_USD = d.rates.EUR; 
                document.getElementById('eurUsdRate').textContent = EUR_USD.toFixed(4); 
            } catch(e) { EUR_USD = 0.849; } 
        }
        
        async function fetchNativePrices() {
            try {
                const r = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=ethereum,binancecoin,matic-network,pulsechain,solana,crypto-com-chain&vs_currencies=usd');
                const d = await r.json();
                NATIVE_PRICES.ETH = d.ethereum?.usd || 3000;
                NATIVE_PRICES.BNB = d.binancecoin?.usd || 600;
                NATIVE_PRICES.MATIC = d['matic-network']?.usd || 0.4;
                NATIVE_PRICES.PLS = d.pulsechain?.usd || 0.00003;
                NATIVE_PRICES.SOL = d.solana?.usd || 150;
                NATIVE_PRICES.CRO = d['crypto-com-chain']?.usd || 0.09;
            } catch(e) {
                NATIVE_PRICES.ETH = 3000; NATIVE_PRICES.BNB = 600; NATIVE_PRICES.MATIC = 0.4;
                NATIVE_PRICES.PLS = 0.00003; NATIVE_PRICES.SOL = 150; NATIVE_PRICES.CRO = 0.09;
            }
        }
        
        async function fetchNativeBalance(addr, apiKey, chainId, chainKey) {
            try {
                // Solana - usa RPC
                if (chainKey === 'solana') {
                    const r = await fetch('https://api.mainnet-beta.solana.com', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            jsonrpc: '2.0', id: 1, method: 'getBalance', params: [addr]
                        })
                    });
                    const d = await r.json();
                    if (d.result?.value) return BigInt(d.result.value);
                    return 0n;
                }
                
                // PulseChain - usa PulseScan API
                if (chainKey === 'pulse') {
                    const r = await fetch(`https://api.scan.pulsechain.com/api?module=account&action=balance&address=${addr}`);
                    const d = await r.json();
                    if (d.status === '1') return BigInt(d.result);
                    return 0n;
                }
                
                // EVM chains - usa Etherscan V2
                const r = await fetch(`https://api.etherscan.io/v2/api?chainid=${chainId}&module=account&action=balance&address=${addr}&tag=latest&apikey=${apiKey}`);
                const d = await r.json();
                if (d.status === '1') return BigInt(d.result);
            } catch(e) { console.error(`Balance error ${chainKey}:`, e); }
            return 0n;
        }
        
        async function fetchTokenTransfers(addr, apiKey, chainId, chainKey) {
            try {
                // Solana - usa RPC per token SPL
                if (chainKey === 'solana') {
                    const r = await fetch('https://api.mainnet-beta.solana.com', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            jsonrpc: '2.0', id: 1, 
                            method: 'getTokenAccountsByOwner',
                            params: [addr, { programId: 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' }, { encoding: 'jsonParsed' }]
                        })
                    });
                    const d = await r.json();
                    const bal = {};
                    if (d.result?.value) {
                        for (const acc of d.result.value) {
                            const info = acc.account?.data?.parsed?.info;
                            if (info && info.tokenAmount?.uiAmount > 0) {
                                const mint = info.mint;
                                bal[mint] = {
                                    symbol: 'SPL', // Will try to get from DexScreener
                                    name: 'Solana Token',
                                    decimals: info.tokenAmount.decimals,
                                    balance: BigInt(info.tokenAmount.amount)
                                };
                            }
                        }
                    }
                    return bal;
                }
                
                // PulseChain - usa PulseScan API
                if (chainKey === 'pulse') {
                    const r = await fetch(`https://api.scan.pulsechain.com/api?module=account&action=tokentx&address=${addr}&startblock=0&endblock=99999999&sort=asc`);
                    const d = await r.json();
                    if (d.status === '1' && d.result) {
                        const bal = {}, w = addr.toLowerCase();
                        for (const tx of d.result) {
                            const c = tx.contractAddress.toLowerCase();
                            if (!bal[c]) bal[c] = { symbol: tx.tokenSymbol, name: tx.tokenName, decimals: parseInt(tx.tokenDecimal||'18'), balance: 0n };
                            const v = BigInt(tx.value||'0');
                            if (tx.to.toLowerCase() === w) bal[c].balance += v;
                            if (tx.from.toLowerCase() === w) bal[c].balance -= v;
                        }
                        return bal;
                    }
                    return {};
                }
                
                // EVM chains - usa Etherscan V2
                const r = await fetch(`https://api.etherscan.io/v2/api?chainid=${chainId}&module=account&action=tokentx&address=${addr}&startblock=0&endblock=99999999&sort=asc&apikey=${apiKey}`);
                const d = await r.json();
                if (d.status === '1' && d.result) {
                    const bal = {}, w = addr.toLowerCase();
                    for (const tx of d.result) {
                        const c = tx.contractAddress.toLowerCase();
                        if (!bal[c]) bal[c] = { symbol: tx.tokenSymbol, name: tx.tokenName, decimals: parseInt(tx.tokenDecimal||'18'), balance: 0n };
                        const v = BigInt(tx.value||'0');
                        if (tx.to.toLowerCase() === w) bal[c].balance += v;
                        if (tx.from.toLowerCase() === w) bal[c].balance -= v;
                    }
                    return bal;
                }
            } catch(e) { console.error(`Token error ${chainKey}:`, e); }
            return {};
        }
        
        async function fetchTokenPrice(contract, dexChain) {
            try {
                const r = await fetch(`https://api.dexscreener.com/latest/dex/tokens/${contract}`);
                const d = await r.json();
                if (d.pairs?.length) {
                    const p = d.pairs.filter(x => x.chainId === dexChain).sort((a,b) => (b.liquidity?.usd||0) - (a.liquidity?.usd||0))[0];
                    if (p) return { price: parseFloat(p.priceUsd), logo: p.info?.imageUrl };
                }
            } catch(e) {}
            return null;
        }
        
        // ==================== SCAN ====================
        async function scanWallet() {
            const addr = document.getElementById('walletAddress').value.trim();
            const etherscanKey = apiKeys.etherscan || document.getElementById('apiKey').value.trim();
            
            if (!addr) { log('‚ùå Inserisci wallet address', 'error'); return; }
            if (!etherscanKey && !apiKeys.moralis) { 
                log('‚ùå Configura almeno una API (Moralis o Etherscan) in API Connect', 'error'); 
                return; 
            }
            if (selectedChains.length === 0) { log('‚ùå Seleziona almeno una chain', 'error'); return; }
            
            // Detect wallet type
            const isSolanaWallet = !addr.startsWith('0x') && /^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(addr);
            
            document.getElementById('statusLog').innerHTML = '';
            log(`üöÄ Scan Multi-Chain...`);
            log(`üìç ${addr.slice(0,8)}...${addr.slice(-6)} ${isSolanaWallet ? '(Solana)' : '(EVM)'}`);
            log(`‚õìÔ∏è ${selectedChains.map(c => CHAINS[c].name).join(', ')}`);
            
            // Mostra quale API sar√† usata
            if (isSolanaWallet) {
                log(`üü£ Usando Solana RPC`, 'info');
            } else if (apiKeys.moralis) {
                log(`üü¢ Usando Moralis API (veloce)`, 'info');
            } else {
                log(`üîµ Usando Etherscan API`, 'info');
            }
            
            saveSettings();
            
            try {
                await fetchEurUsd();
                await fetchNativePrices();
                log(`üí∞ ETH: $${formatNum(NATIVE_PRICES.ETH)} | BNB: $${formatNum(NATIVE_PRICES.BNB)} | SOL: $${formatNum(NATIVE_PRICES.SOL)}`, 'info');
                
                const results = [];
                
                for (const chainKey of selectedChains) {
                    const chain = CHAINS[chainKey];
                    
                    // Skip incompatible chains
                    if (isSolanaWallet && chainKey !== 'solana') {
                        continue; // Wallet Solana pu√≤ solo scansionare Solana
                    }
                    if (!isSolanaWallet && chainKey === 'solana') {
                        continue; // Wallet EVM non pu√≤ scansionare Solana
                    }
                    
                    log(`üì° ${chain.name}...`);
                    
                    // SOLANA: Use Helius API if available
                    if (chainKey === 'solana' && apiKeys.helius) {
                        log(`  üü£ Helius API...`, 'info');
                        const heliusResults = await fetchWithHelius(addr);
                        if (heliusResults && heliusResults.length > 0) {
                            results.push(...heliusResults);
                            const solToken = heliusResults.find(t => t.symbol === 'SOL');
                            if (solToken) {
                                log(`  SOL: ${formatNum(solToken.balance, 4)} ($${formatNum(solToken.valueUSD)})`, 'success');
                            }
                            const tokenCount = heliusResults.filter(t => t.symbol !== 'SOL').length;
                            if (tokenCount > 0) log(`  ${tokenCount} SPL tokens`, 'info');
                            continue;
                        } else {
                            log(`  ‚ö†Ô∏è Helius: nessun risultato`, 'warning');
                        }
                    }
                    
                    // Try Moralis first for supported chains
                    if (apiKeys.moralis && MORALIS_CHAINS[chainKey]) {
                        log(`  ‚ö° Moralis...`, 'info');
                        const moralisResults = await scanWithMoralis(addr, chainKey);
                        if (moralisResults && moralisResults.length > 0) {
                            results.push(...moralisResults);
                            const nativeToken = moralisResults.find(t => t.contract.startsWith('native-'));
                            if (nativeToken) {
                                log(`  ${nativeToken.symbol}: ${formatNum(nativeToken.balance, 4)} ($${formatNum(nativeToken.valueUSD)})`, 'success');
                            }
                            const tokenCount = moralisResults.filter(t => !t.contract.startsWith('native-')).length;
                            if (tokenCount > 0) log(`  ${tokenCount} tokens`, 'info');
                            await new Promise(r => setTimeout(r, 100));
                            continue;
                        }
                    }
                    
                    // Fallback to Etherscan/PulseScan/Solana RPC
                    if (!etherscanKey && chainKey !== 'pulse' && chainKey !== 'solana') {
                        log(`  ‚ö†Ô∏è Skip - nessuna API key`, 'warning');
                        continue;
                    }
                    
                    // Skip Solana RPC fallback if no Helius (too unreliable)
                    if (chainKey === 'solana' && !apiKeys.helius) {
                        log(`  ‚ö†Ô∏è Configura Helius API per Solana`, 'warning');
                        continue;
                    }
                    
                    // Native balance
                    const nativeWei = await fetchNativeBalance(addr, etherscanKey, chain.id, chainKey);
                    const nativeDecimals = chainKey === 'solana' ? 9 : 18;
                    const nativeBal = Number(nativeWei) / Math.pow(10, nativeDecimals);
                    const nativePrice = NATIVE_PRICES[chain.symbol] || NATIVE_PRICES.ETH;
                    
                    if (nativeBal > 0.0001) {
                        results.push({
                            symbol: chain.symbol,
                            name: `${chain.symbol} (${chain.name})`,
                            balance: nativeBal,
                            price: nativePrice,
                            valueUSD: nativeBal * nativePrice,
                            contract: `native-${chainKey}`,
                            logo: TOKEN_ICONS[chain.symbol],
                            chain: chainKey
                        });
                        log(`  ${chain.symbol}: ${formatNum(nativeBal, 4)} ($${formatNum(nativeBal * nativePrice)})`, 'success');
                    }
                    
                    // Token balances
                    const tokens = await fetchTokenTransfers(addr, etherscanKey, chain.id, chainKey);
                    let tokenCount = 0;
                    
                    for (const [c, t] of Object.entries(tokens)) {
                        if (isBlacklisted(c) || isSpam(t.name, t.symbol) || t.balance <= 0n) continue;
                        
                        const bal = Number(t.balance) / Math.pow(10, t.decimals);
                        let price = 0, logo = TOKEN_ICONS[t.symbol?.toUpperCase()] || null;
                        
                        const pd = await fetchTokenPrice(c, chain.dex);
                        if (pd) { price = pd.price; if (pd.logo) logo = pd.logo; }
                        
                        results.push({
                            symbol: t.symbol,
                            name: t.name,
                            balance: bal,
                            price,
                            valueUSD: bal * price,
                            contract: c,
                            logo,
                            chain: chainKey
                        });
                        
                        tokenCount++;
                        if (price > 0 && bal * price >= 1) {
                            log(`  ${t.symbol}: $${formatNum(bal * price)}`, 'success');
                        }
                        
                        await new Promise(r => setTimeout(r, 150));
                    }
                    
                    if (tokenCount > 0) log(`  ${tokenCount} tokens`, 'info');
                    await new Promise(r => setTimeout(r, 200));
                }
                
                results.sort((a, b) => b.valueUSD - a.valueUSD);
                
                // Trova nome wallet se salvato
                const walletName = savedWallets.find(w => w.address.toLowerCase() === addr.toLowerCase())?.name || 'Wallet';
                
                // Salva risultati per questo wallet
                walletResults[addr.toLowerCase()] = {
                    name: walletName,
                    results: results,
                    scannedAt: Date.now()
                };
                
                // Aggrega tutti i wallet per display
                aggregateAndDisplay();
                
                // Salva risultati su Firebase
                saveToFirebase();
                
                log('‚úÖ Completato!', 'success');
                document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString('it-IT');
                
            } catch(e) {
                log(`‚ùå Errore: ${e.message}`, 'error');
                console.error(e);
            }
        }
        
        // ==================== MULTI-WALLET ====================
        function aggregateAndDisplay() {
            // Combina risultati di tutti i wallet
            const allResults = [];
            
            for (const [addr, data] of Object.entries(walletResults)) {
                for (const token of data.results) {
                    // Aggiungi info wallet al token
                    allResults.push({
                        ...token,
                        walletAddress: addr,
                        walletName: data.name
                    });
                }
            }
            
            // Ordina per valore
            allResults.sort((a, b) => b.valueUSD - a.valueUSD);
            lastScanResults = allResults;
            
            displayResults(allResults);
        }
        
        async function scanAllWallets() {
            const etherscanKey = apiKeys.etherscan;
            if (!etherscanKey && !apiKeys.moralis) { 
                log('‚ùå Configura almeno una API (Moralis o Etherscan) in API Connect', 'error'); 
                return; 
            }
            if (savedWallets.length === 0) { log('‚ùå Nessun wallet salvato. Vai su Wallets per aggiungerli.', 'error'); return; }
            if (selectedChains.length === 0) { log('‚ùå Seleziona almeno una chain', 'error'); return; }
            
            document.getElementById('statusLog').innerHTML = '';
            log(`üöÄ Scan di ${savedWallets.length} wallet...`);
            
            // Mostra quale API sar√† usata
            if (apiKeys.moralis) {
                log(`üü¢ Usando Moralis API (veloce)`, 'info');
            } else {
                log(`üîµ Usando Etherscan API`, 'info');
            }
            
            // Reset risultati
            walletResults = {};
            
            await fetchEurUsd();
            await fetchNativePrices();
            log(`üí∞ ETH: $${formatNum(NATIVE_PRICES.ETH)} | BNB: $${formatNum(NATIVE_PRICES.BNB)} | SOL: $${formatNum(NATIVE_PRICES.SOL)}`, 'info');
            
            for (let i = 0; i < savedWallets.length; i++) {
                const wallet = savedWallets[i];
                log(`\nüìç [${i+1}/${savedWallets.length}] ${wallet.name}`);
                log(`   ${wallet.address.slice(0,8)}...${wallet.address.slice(-6)}`);
                
                // Detect wallet type
                const isSolanaWallet = wallet.type === 'solana' || (!wallet.address.startsWith('0x') && /^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(wallet.address));
                
                const results = [];
                
                for (const chainKey of selectedChains) {
                    const chain = CHAINS[chainKey];
                    
                    // Skip incompatible chains
                    if (isSolanaWallet && chainKey !== 'solana') {
                        continue; // Wallet Solana pu√≤ solo scansionare Solana
                    }
                    if (!isSolanaWallet && chainKey === 'solana') {
                        continue; // Wallet EVM non pu√≤ scansionare Solana
                    }
                    
                    log(`   ‚õìÔ∏è ${chain.name}...`);
                    
                    // SOLANA: Use Helius API if available
                    if (chainKey === 'solana' && apiKeys.helius) {
                        const heliusResults = await fetchWithHelius(wallet.address);
                        if (heliusResults && heliusResults.length > 0) {
                            results.push(...heliusResults);
                            const solToken = heliusResults.find(t => t.symbol === 'SOL');
                            if (solToken) {
                                log(`      SOL: ${formatNum(solToken.balance, 4)} ($${formatNum(solToken.valueUSD)})`, 'success');
                            }
                            for (const t of heliusResults.filter(t => t.symbol !== 'SOL' && t.valueUSD >= 1)) {
                                log(`      ${t.symbol}: $${formatNum(t.valueUSD)}`, 'success');
                            }
                            continue;
                        }
                    }
                    
                    // Skip Solana if no Helius
                    if (chainKey === 'solana' && !apiKeys.helius) {
                        log(`      ‚ö†Ô∏è Configura Helius per Solana`, 'warning');
                        continue;
                    }
                    
                    // Try Moralis first for supported chains
                    if (apiKeys.moralis && MORALIS_CHAINS[chainKey]) {
                        const moralisResults = await scanWithMoralis(wallet.address, chainKey);
                        if (moralisResults && moralisResults.length > 0) {
                            results.push(...moralisResults);
                            const nativeToken = moralisResults.find(t => t.contract.startsWith('native-'));
                            if (nativeToken) {
                                log(`      ${nativeToken.symbol}: ${formatNum(nativeToken.balance, 4)} ($${formatNum(nativeToken.valueUSD)})`, 'success');
                            }
                            const tokenCount = moralisResults.filter(t => !t.contract.startsWith('native-') && t.valueUSD >= 1).length;
                            for (const t of moralisResults.filter(t => !t.contract.startsWith('native-') && t.valueUSD >= 1)) {
                                log(`      ${t.symbol}: $${formatNum(t.valueUSD)}`, 'success');
                            }
                            await new Promise(r => setTimeout(r, 100));
                            continue;
                        }
                    }
                    
                    // Fallback to Etherscan/PulseScan
                    if (!etherscanKey && chainKey !== 'pulse') {
                        continue; // Skip silently
                    }
                    
                    // Native balance
                    const nativeWei = await fetchNativeBalance(wallet.address, etherscanKey, chain.id, chainKey);
                    const nativeDecimals = chainKey === 'solana' ? 9 : 18;
                    const nativeBal = Number(nativeWei) / Math.pow(10, nativeDecimals);
                    const nativePrice = NATIVE_PRICES[chain.symbol] || NATIVE_PRICES.ETH;
                    
                    if (nativeBal > 0.0001) {
                        results.push({
                            symbol: chain.symbol,
                            name: `${chain.symbol} (${chain.name})`,
                            balance: nativeBal,
                            price: nativePrice,
                            valueUSD: nativeBal * nativePrice,
                            contract: `native-${chainKey}`,
                            logo: TOKEN_ICONS[chain.symbol],
                            chain: chainKey
                        });
                        log(`      ${chain.symbol}: ${formatNum(nativeBal, 4)} ($${formatNum(nativeBal * nativePrice)})`, 'success');
                    }
                    
                    // Token balances
                    const tokens = await fetchTokenTransfers(wallet.address, etherscanKey, chain.id, chainKey);
                    
                    for (const [c, t] of Object.entries(tokens)) {
                        if (isBlacklisted(c) || isSpam(t.name, t.symbol) || t.balance <= 0n) continue;
                        
                        const bal = Number(t.balance) / Math.pow(10, t.decimals);
                        let price = 0, logo = TOKEN_ICONS[t.symbol?.toUpperCase()] || null;
                        
                        const pd = await fetchTokenPrice(c, chain.dex);
                        if (pd) { price = pd.price; if (pd.logo) logo = pd.logo; }
                        
                        results.push({
                            symbol: t.symbol,
                            name: t.name,
                            balance: bal,
                            price,
                            valueUSD: bal * price,
                            contract: c,
                            logo,
                            chain: chainKey
                        });
                        
                        if (price > 0 && bal * price >= 1) {
                            log(`      ${t.symbol}: $${formatNum(bal * price)}`, 'success');
                        }
                        
                        await new Promise(r => setTimeout(r, 150));
                    }
                    
                    await new Promise(r => setTimeout(r, 200));
                }
                
                // Salva risultati wallet
                walletResults[wallet.address.toLowerCase()] = {
                    name: wallet.name,
                    results: results,
                    scannedAt: Date.now()
                };
                
                const walletTotal = results.reduce((s, t) => s + t.valueUSD, 0);
                log(`   üí∞ Totale ${wallet.name}: $${formatNum(walletTotal)}`, 'success');
                
                // Download transazioni se wallet EVM e API disponibile (Moralis o Etherscan)
                if (!isSolanaWallet && (apiKeys.moralis || apiKeys.etherscan)) {
                    const addrLower = wallet.address.toLowerCase();
                    const existingTx = walletTransactions[addrLower];
                    const txAge = existingTx ? (Date.now() - (existingTx.lastDownload || 0)) / 3600000 : 999;
                    
                    // Scarica solo se > 24h o non esistono
                    if (txAge > 24) {
                        log(`   üì• Download transazioni...`);
                        const txData = await downloadWalletTransactions(wallet.address, (status) => {
                            // Progress silenzioso
                        });
                        walletTransactions[addrLower] = txData;
                        const txCount = txData.nativeTx.length + txData.tokenTx.length;
                        log(`   ‚úÖ ${txCount} transazioni scaricate`, 'success');
                    } else {
                        const txCount = getWalletTxCount(wallet.address);
                        log(`   üìÇ ${txCount} transazioni in cache`, 'info');
                    }
                }
            }
            
            // Aggrega e mostra
            aggregateAndDisplay();
            
            // Salva risultati su Firebase
            saveToFirebase();
            
            // Salva transazioni
            saveWalletTransactions();
            
            const grandTotal = Object.values(walletResults).reduce((sum, w) => 
                sum + w.results.reduce((s, t) => s + t.valueUSD, 0), 0);
            
            const totalTx = Object.values(walletTransactions).reduce((sum, w) => 
                sum + (w.nativeTx?.length || 0) + (w.tokenTx?.length || 0), 0);
            
            log(`\nüéâ TOTALE PORTFOLIO: $${formatNum(grandTotal)} (‚Ç¨${formatNum(grandTotal * EUR_USD)})`, 'success');
            log(`üìú ${totalTx} transazioni totali salvate`, 'info');
            document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString('it-IT');
        }
        
        function clearWalletResults() {
            walletResults = {};
            lastScanResults = [];
            displayResults([]);
            saveToFirebase();
            log('üóëÔ∏è Risultati cancellati', 'info');
        }
        
        // ==================== DISPLAY ====================
        function displayResults(results) {
            const visible = results.filter(t => !isBlacklisted(t.contract));
            const withVal = visible.filter(t => t.valueUSD >= 0.01);
            const walletsUSD = withVal.reduce((s, t) => s + t.valueUSD, 0);
            
            // Calcola totale exchange da CSV (usa anno pi√π recente disponibile)
            let exchangeTotalEUR = 0;
            let exchangeNames = [];
            for (const exchId of Object.keys(exchangeData)) {
                const data = exchangeData[exchId];
                if (data && data.totals) {
                    // Prendi anno pi√π recente con valore > 0
                    const latestYear = [2025, 2024, 2023, 2022, 2021].find(y => data.totals[y] > 0);
                    if (latestYear && data.totals[latestYear] > 0) {
                        exchangeTotalEUR += data.totals[latestYear];
                        const exchInfo = EXCHANGE_LIST.find(e => e.id === exchId);
                        if (exchInfo) exchangeNames.push(exchInfo.name);
                    }
                }
            }
            
            const totalUSD = walletsUSD + (exchangeTotalEUR / EUR_USD);
            const totalEUR = totalUSD * EUR_USD;
            
            document.getElementById('totalEUR').textContent = '‚Ç¨' + formatEUR(totalEUR);
            document.getElementById('totalUSD').textContent = '$' + formatEUR(totalUSD) + ' USD';
            document.getElementById('tokenCount').textContent = withVal.length;
            
            // Aggiorna card Exchanges
            document.getElementById('exchangeTotalEUR').textContent = '‚Ç¨' + formatEUR(exchangeTotalEUR);
            if (exchangeNames.length > 0) {
                document.getElementById('exchangeNames').textContent = exchangeNames.join(', ') + ' ‚úì';
            } else {
                document.getElementById('exchangeNames').textContent = 'Nessuno';
            }
            
            // Conta wallet scansionati
            const scannedCount = Object.keys(walletResults).length;
            document.getElementById('scannedWallets').textContent = scannedCount;
            const walletNames = Object.values(walletResults).map(w => w.name).join(', ') || '-';
            document.getElementById('chainNames').textContent = walletNames.length > 30 ? walletNames.slice(0, 30) + '...' : walletNames;
            
            const container = document.getElementById('holdingsContent');
            if (!withVal.length) {
                container.innerHTML = '<div class="empty-state"><div class="icon">üì≠</div><h3>Nessun token con valore</h3></div>';
                return;
            }
            
            let html = `<table class="holdings-table">
                <thead><tr><th>TOKEN</th><th>BALANCE</th><th>PREZZO</th><th>VALORE</th></tr></thead>
                <tbody>`;
            
            for (const t of withVal) {
                const chain = CHAINS[t.chain];
                const pct = totalUSD > 0 ? ((t.valueUSD / totalUSD) * 100).toFixed(1) : '0';
                const vEUR = t.valueUSD * EUR_USD;
                
                html += `<tr>
                    <td><div class="token-cell">
                        <button class="hide-btn" onclick="hideToken('${t.contract}','${t.symbol}')">‚úï</button>
                        <div class="token-icon">${t.logo ? `<img src="${t.logo}" onerror="this.parentElement.textContent='${t.symbol.slice(0,2)}'">` : t.symbol.slice(0,2)}</div>
                        <div class="token-info">
                            <div class="symbol">${t.symbol}<span class="chain-badge" style="background:${chain?.color || '#666'}20;color:${chain?.color || '#666'}">${t.chain}</span></div>
                            <div class="name">${t.name}${t.walletName ? ` <span style="color:var(--accent-light);font-size:10px;">‚Ä¢ ${t.walletName}</span>` : ''}</div>
                        </div>
                    </div></td>
                    <td class="text-right text-mono">${formatNum(t.balance, 4)}</td>
                    <td class="text-right text-mono text-secondary">$${t.price > 0 ? formatNum(t.price, 6) : '-'}</td>
                    <td class="text-right">
                        <div class="text-mono" style="color:var(--green);">‚Ç¨${formatEUR(vEUR)}</div>
                        <div class="text-secondary" style="font-size:11px;">${pct}%</div>
                    </td>
                </tr>`;
            }
            
            html += '</tbody></table>';
            container.innerHTML = html;
            
            // Chart
            if (withVal.length > 0) renderChart(withVal, totalUSD);
        }
        
        function renderChart(tokens, total) {
            const ctx = document.getElementById('allocationChart').getContext('2d');
            if (allocationChart) allocationChart.destroy();
            
            const top5 = tokens.slice(0, 5);
            const others = tokens.slice(5);
            const othersVal = others.reduce((s, t) => s + t.valueUSD, 0);
            
            const labels = top5.map(t => t.symbol);
            const data = top5.map(t => t.valueUSD);
            if (othersVal > 0) { labels.push('Altri'); data.push(othersVal); }
            
            const colors = ['#6c5ce7', '#00cec9', '#ffeaa7', '#ff7675', '#74b9ff', '#a29bfe'];
            
            allocationChart = new Chart(ctx, {
                type: 'doughnut',
                data: { labels, datasets: [{ data, backgroundColor: colors.slice(0, data.length), borderWidth: 0 }] },
                options: { responsive: true, cutout: '70%', plugins: { legend: { position: 'bottom', labels: { color: '#a0a0a0', padding: 15 } } } }
            });
        }
        
        // ==================== TAX REPORT ====================
        async function calculateTaxReportAll() {
            const etherscanKey = apiKeys.etherscan;
            
            if (!etherscanKey) { 
                alert('Configura Etherscan API in API Connect prima! (necessaria per storico transazioni)'); 
                return; 
            }
            
            if (savedWallets.length === 0) {
                alert('Nessun wallet salvato! Vai su Wallets per aggiungerne.');
                return;
            }
            
            if (selectedChains.length === 0) {
                alert('Seleziona almeno una chain nella Dashboard!');
                return;
            }
            
            const container = document.getElementById('taxReportContent');
            const detailCard = document.getElementById('taxDetailCard');
            const detailContent = document.getElementById('taxDetailContent');
            
            container.innerHTML = `<div class="empty-state"><div class="icon">‚è≥</div><h3>Caricamento ${savedWallets.length} wallet su ${selectedChains.length} chain...</h3></div>`;
            
            const years = [2021, 2022, 2023, 2024, 2025, 2026];
            
            // Totali aggregati per anno
            const grandTotals = {};
            for (const y of years) grandTotals[y] = { eur: 0, usd: 0 };
            
            // Dettagli per wallet
            const walletDetails = [];
            
            // Chain native symbols
            const CHAIN_NATIVE = {
                eth: 'ETH', bsc: 'BNB', polygon: 'MATIC', arbitrum: 'ETH', 
                optimism: 'ETH', base: 'ETH', pulse: 'PLS', solana: 'SOL'
            };
            
            try {
                for (let wi = 0; wi < savedWallets.length; wi++) {
                    const wallet = savedWallets[wi];
                    const addr = wallet.address;
                    const walletLower = addr.toLowerCase();
                    
                    const balances = {};
                    const allTokens = {};
                    for (const y of years) balances[y] = {};
                    
                    for (const chainKey of selectedChains) {
                        const chain = CHAINS[chainKey];
                        const nativeSym = CHAIN_NATIVE[chainKey];
                        
                        container.innerHTML = `<div class="empty-state"><div class="icon">‚è≥</div><h3>Wallet ${wi + 1}/${savedWallets.length}: ${wallet.name}<br><small style="color:var(--text-secondary);">${chain.name}...</small></h3></div>`;
                        
                        let nativeTx = [], internalTx = [], tokenTx = [];
                        
                        // Fetch transactions based on chain type
                        if (chainKey === 'pulse') {
                            // PulseChain - use PulseScan
                            const [nRes, tRes] = await Promise.all([
                                fetch(`https://api.scan.pulsechain.com/api?module=account&action=txlist&address=${addr}&startblock=0&endblock=99999999&sort=asc`).then(r => r.json()),
                                fetch(`https://api.scan.pulsechain.com/api?module=account&action=tokentx&address=${addr}&startblock=0&endblock=99999999&sort=asc`).then(r => r.json())
                            ]);
                            nativeTx = nRes.status === '1' ? nRes.result : [];
                            tokenTx = tRes.status === '1' ? tRes.result : [];
                        } else if (chainKey === 'solana') {
                            // Solana - skip for now (no easy historical API)
                            continue;
                        } else {
                            // EVM chains - use Etherscan V2
                            const [nRes, iRes, tRes] = await Promise.all([
                                fetch(`https://api.etherscan.io/v2/api?chainid=${chain.id}&module=account&action=txlist&address=${addr}&startblock=0&endblock=99999999&sort=asc&apikey=${etherscanKey}`).then(r => r.json()),
                                fetch(`https://api.etherscan.io/v2/api?chainid=${chain.id}&module=account&action=txlistinternal&address=${addr}&startblock=0&endblock=99999999&sort=asc&apikey=${etherscanKey}`).then(r => r.json()),
                                fetch(`https://api.etherscan.io/v2/api?chainid=${chain.id}&module=account&action=tokentx&address=${addr}&startblock=0&endblock=99999999&sort=asc&apikey=${etherscanKey}`).then(r => r.json())
                            ]);
                            nativeTx = nRes.status === '1' ? nRes.result : [];
                            internalTx = iRes.status === '1' ? iRes.result : [];
                            tokenTx = tRes.status === '1' ? tRes.result : [];
                        }
                        
                        // Get tokens from this chain
                        for (const tx of tokenTx) {
                            const sym = tx.tokenSymbol?.toUpperCase();
                            const c = tx.contractAddress.toLowerCase();
                            const key = `${chainKey}:${c}`;
                            if (!allTokens[key]) {
                                allTokens[key] = { 
                                    symbol: tx.tokenSymbol, 
                                    decimals: parseInt(tx.tokenDecimal || '18'),
                                    chain: chainKey,
                                    chainName: chain.name
                                };
                            }
                        }
                        
                        // Calculate native balance per year
                        for (const y of years) {
                            const ts = new Date(`${y + 1}-01-01T00:00:00Z`).getTime() / 1000;
                            let bal = 0n;
                            
                            for (const tx of nativeTx) {
                                if (parseInt(tx.timeStamp) >= ts || tx.isError === '1') continue;
                                const v = BigInt(tx.value || '0');
                                const g = BigInt(tx.gasUsed || '0') * BigInt(tx.gasPrice || '0');
                                if (tx.to?.toLowerCase() === walletLower) bal += v;
                                if (tx.from?.toLowerCase() === walletLower) { bal -= v; bal -= g; }
                            }
                            
                            for (const tx of internalTx) {
                                if (parseInt(tx.timeStamp) >= ts || tx.isError === '1') continue;
                                const v = BigInt(tx.value || '0');
                                if (tx.to?.toLowerCase() === walletLower) bal += v;
                                if (tx.from?.toLowerCase() === walletLower) bal -= v;
                            }
                            
                            const nativeKey = `${nativeSym} (${chain.name})`;
                            if (!balances[y][nativeKey]) balances[y][nativeKey] = 0;
                            balances[y][nativeKey] += Number(bal < 0n ? 0n : bal) / 1e18;
                        }
                        
                        // Calculate token balances per year
                        for (const tx of tokenTx) {
                            const c = tx.contractAddress.toLowerCase();
                            const key = `${chainKey}:${c}`;
                            const info = allTokens[key];
                            if (!info) continue;
                            
                            for (const y of years) {
                                const ts = new Date(`${y + 1}-01-01T00:00:00Z`).getTime() / 1000;
                                if (parseInt(tx.timeStamp) >= ts) continue;
                                
                                const tokenKey = `${info.symbol} (${chain.name})`;
                                if (!balances[y][tokenKey]) balances[y][tokenKey] = 0;
                                
                                const v = BigInt(tx.value || '0');
                                const amount = Number(v) / Math.pow(10, info.decimals);
                                
                                if (tx.to?.toLowerCase() === walletLower) {
                                    balances[y][tokenKey] += amount;
                                }
                                if (tx.from?.toLowerCase() === walletLower) {
                                    balances[y][tokenKey] -= amount;
                                }
                            }
                        }
                        
                        // Rate limit
                        await new Promise(r => setTimeout(r, 250));
                    }
                    
                    // Fix negative balances
                    for (const y of years) {
                        for (const key of Object.keys(balances[y])) {
                            if (balances[y][key] < 0) balances[y][key] = 0;
                        }
                    }
                    
                    // Calculate wallet totals per year
                    const walletTotals = {};
                    for (const y of years) {
                        walletTotals[y] = { eur: 0, usd: 0 };
                        
                        for (const [tokenKey, bal] of Object.entries(balances[y])) {
                            if (bal <= 0) continue;
                            
                            // Extract symbol and chain from key like "ETH (Ethereum)" or "SHIB (PulseChain)"
                            const sym = tokenKey.split(' (')[0].toUpperCase();
                            const chainMatch = tokenKey.match(/\(([^)]+)\)/);
                            const chain = chainMatch ? chainMatch[1] : '';
                            
                            // PulseChain cloni = prezzo 0 (solo PLS, PLSX, HEX, INC hanno valore)
                            const isPulseClone = chain === 'PulseChain' && !['PLS', 'PLSX', 'HEX', 'INC', 'WPLS'].includes(sym);
                            
                            const cgId = SYMBOL_TO_CG[sym];
                            const price = isPulseClone ? 0 : (HISTORICAL_PRICES[cgId]?.[y] || 0);
                            
                            if (price > 0) {
                                walletTotals[y].usd += bal * price;
                                walletTotals[y].eur += bal * price * EUR_USD;
                            }
                        }
                        
                        // Add to grand totals
                        grandTotals[y].usd += walletTotals[y].usd;
                        grandTotals[y].eur += walletTotals[y].eur;
                    }
                    
                    walletDetails.push({ wallet, balances, totals: walletTotals, tokens: allTokens });
                }
                
                // Prepara struttura dati serializzabile per Firebase
                const chainNames = selectedChains.map(c => CHAINS[c].name).join(', ');
                const serializedWalletDetails = walletDetails.map(wd => {
                    // Get all token keys that have value
                    const tokenKeys = new Set();
                    for (const y of years) {
                        for (const key of Object.keys(wd.balances[y])) {
                            if (wd.balances[y][key] > 0) tokenKeys.add(key);
                        }
                    }
                    
                    const rows = [];
                    for (const tokenKey of tokenKeys) {
                        const sym = tokenKey.split(' (')[0].toUpperCase();
                        const chainMatch = tokenKey.match(/\(([^)]+)\)/);
                        const chain = chainMatch ? chainMatch[1] : '';
                        
                        // PulseChain cloni = prezzo 0
                        const isPulseClone = chain === 'PulseChain' && !['PLS', 'PLSX', 'HEX', 'INC', 'WPLS'].includes(sym);
                        
                        const cgId = SYMBOL_TO_CG[sym];
                        
                        // Check if has any value
                        const hasValue = years.some(y => {
                            const bal = wd.balances[y][tokenKey] || 0;
                            const price = isPulseClone ? 0 : (HISTORICAL_PRICES[cgId]?.[y] || 0);
                            return bal * price * EUR_USD >= 1;
                        });
                        if (!hasValue) continue;
                        
                        const cells = {};
                        for (const y of years) {
                            const bal = wd.balances[y][tokenKey] || 0;
                            const price = isPulseClone ? 0 : (HISTORICAL_PRICES[cgId]?.[y] || 0);
                            cells[y] = {
                                balance: bal,
                                eur: bal * price * EUR_USD,
                                hasValue: bal > 0 && price > 0
                            };
                        }
                        rows.push({ tokenKey, cells });
                    }
                    
                    return {
                        walletName: wd.wallet.name,
                        walletAddress: wd.wallet.address.slice(0,8) + '...' + wd.wallet.address.slice(-6),
                        totals: wd.totals,
                        rows
                    };
                });
                
                // Salva in memoria e Firebase
                taxReportData = {
                    grandTotals,
                    walletDetails: serializedWalletDetails,
                    walletCount: savedWallets.length,
                    chainNames,
                    calculatedAt: Date.now()
                };
                saveToFirebase();
                
                // Render usando la funzione condivisa
                renderTaxReport(taxReportData);
                
            } catch(e) {
                container.innerHTML = `<div class="empty-state"><div class="icon">‚ùå</div><h3>Errore: ${e.message}</h3></div>`;
                console.error(e);
            }
        }
        
        // ==================== TRANSACTIONS VIEW ====================
        let allTransactions = [];
        let filteredTransactions = [];
        let currentTxPage = 1;
        
        // Conta transazioni per anno (da tutti gli exchange)
        function countTransactionsByYear() {
            const counts = { 2021: 0, 2022: 0, 2023: 0, 2024: 0, 2025: 0, 2026: 0 };
            
            for (const [exchId, data] of Object.entries(exchangeData)) {
                if (data.transactions && data.transactions.length > 0) {
                    for (const tx of data.transactions) {
                        const date = tx.date instanceof Date ? tx.date : new Date(tx.date);
                        const year = date.getFullYear();
                        if (counts[year] !== undefined) {
                            counts[year]++;
                        }
                    }
                }
            }
            
            return counts;
        }
        
        function loadAllTransactions() {
            allTransactions = [];
            
            // Carica transazioni da Exchange
            for (const [exchId, data] of Object.entries(exchangeData)) {
                if (data.transactions && data.transactions.length > 0) {
                    const exchInfo = EXCHANGE_LIST.find(e => e.id === exchId) || { name: exchId, color: '#666' };
                    for (const tx of data.transactions) {
                        allTransactions.push({
                            ...tx,
                            date: tx.date instanceof Date ? tx.date : new Date(tx.date),
                            source: 'exchange',
                            sourceName: exchInfo.name,
                            sourceColor: exchInfo.color,
                            sourceId: exchId
                        });
                    }
                }
            }
            
            return allTransactions;
        }
        
        function formatNumber(num) {
            if (num === undefined || num === null || num === '') return '-';
            const n = parseFloat(num);
            if (isNaN(n)) return '-';
            if (n === 0) return '0';
            if (Math.abs(n) >= 1000000) return n.toLocaleString('it-IT', { maximumFractionDigits: 0 });
            if (Math.abs(n) >= 1000) return n.toLocaleString('it-IT', { maximumFractionDigits: 2 });
            if (Math.abs(n) >= 1) return n.toLocaleString('it-IT', { maximumFractionDigits: 4 });
            if (Math.abs(n) >= 0.0001) return n.toFixed(6);
            return n.toExponential(2);
        }
        
        // ==================== EXCHANGES CSV ====================
        // Mostra dettagli calcolo per un anno specifico
        function showYearDetails(exchId, year) {
            const data = exchangeData[exchId];
            if (!data) {
                alert('Nessun dato disponibile');
                return;
            }
            
            const balances = data.balances?.[year] || {};
            const realBalances = data.realBalances || {};
            
            // Per 2025/2026 usa saldi reali se disponibili
            const useReal = (year >= 2025) && Object.keys(realBalances).length > 0;
            const snapshot = useReal ? realBalances : balances;
            
            let details = `üìä DETTAGLIO ${year} - ${exchId.toUpperCase()}\n`;
            details += `${'‚îÄ'.repeat(40)}\n\n`;
            
            if (useReal) {
                details += `‚úÖ Usando SALDI REALI\n\n`;
            } else {
                details += `üìà Usando saldi calcolati dalle transazioni\n\n`;
            }
            
            let totalEur = 0;
            const items = [];
            let skippedLD = 0;
            
            for (const [coin, amount] of Object.entries(snapshot)) {
                if (!amount || amount <= 0) continue;
                // üö´ Salta token LD* (duplicati Earn)
                if (coin.startsWith('LD')) {
                    skippedLD++;
                    continue;
                }
                const eurValue = amount * getPriceEur(coin, year);
                totalEur += eurValue;
                items.push({ coin, amount, price: getPriceEur(coin, year), eurValue });
            }
            
            // Ordina per valore EUR
            items.sort((a, b) => b.eurValue - a.eurValue);
            
            for (const item of items.slice(0, 15)) {
                const amtStr = item.amount < 1 ? item.amount.toFixed(6) : item.amount.toLocaleString('it-IT', { maximumFractionDigits: 2 });
                const priceStr = item.price < 0.01 ? item.price.toExponential(2) : item.price.toFixed(4);
                details += `${item.coin}: ${amtStr}\n`;
                details += `   Prezzo: $${priceStr} ‚Üí ‚Ç¨${item.eurValue.toFixed(2)}\n\n`;
            }
            
            if (items.length > 15) {
                details += `... e altri ${items.length - 15} token\n\n`;
            }
            
            details += `${'‚îÄ'.repeat(40)}\n`;
            details += `üí∞ TOTALE: ‚Ç¨${totalEur.toFixed(2)}\n`;
            if (skippedLD > 0) {
                details += `\n‚ö†Ô∏è Esclusi ${skippedLD} token LD* (duplicati Earn)`;
            }
            details += `\nüí° I prezzi sono stime storiche.`;
            
            alert(details);
        }
        
        // Mostra tutti i saldi di un exchange
        function showExchangeBalances(exchId) {
            const data = exchangeData[exchId];
            if (!data) {
                alert('Nessun dato disponibile');
                return;
            }
            
            const realBalances = data.realBalances || {};
            const hasReal = Object.keys(realBalances).length > 0;
            
            let details = `üíé SALDI ${exchId.toUpperCase()}\n`;
            details += `${'‚îÄ'.repeat(40)}\n\n`;
            
            if (hasReal) {
                // Separa token normali da token LD* (Earn)
                const normalTokens = [];
                const earnTokens = [];
                let totalEur = 0;
                
                for (const [coin, amount] of Object.entries(realBalances)) {
                    if (amount <= 0) continue;
                    if (coin.startsWith('LD')) {
                        earnTokens.push([coin, amount]);
                    } else {
                        normalTokens.push([coin, amount]);
                        totalEur += amount * getPriceEur(coin, 2026);
                    }
                }
                
                // Ordina per quantit√†
                normalTokens.sort((a, b) => b[1] - a[1]);
                earnTokens.sort((a, b) => b[1] - a[1]);
                
                details += `‚úÖ SALDI REALI (Spot + Earn):\n\n`;
                for (const [coin, amount] of normalTokens) {
                    const amtStr = amount < 1 ? amount.toFixed(6) : amount.toLocaleString('it-IT', { maximumFractionDigits: 2 });
                    const eurValue = amount * getPriceEur(coin, 2026);
                    details += `${coin}: ${amtStr}`;
                    if (eurValue > 0) {
                        details += ` ‚Üí ‚Ç¨${eurValue.toFixed(2)}`;
                    }
                    details += `\n`;
                }
                
                if (earnTokens.length > 0) {
                    details += `\nüîí TOKEN IN EARN (gi√† inclusi sopra):\n`;
                    for (const [coin, amount] of earnTokens.slice(0, 10)) {
                        const realCoin = coin.substring(2); // Rimuovi "LD"
                        const amtStr = amount < 1 ? amount.toFixed(6) : amount.toLocaleString('it-IT', { maximumFractionDigits: 2 });
                        details += `${coin} (=${realCoin}): ${amtStr}\n`;
                    }
                    if (earnTokens.length > 10) {
                        details += `... e altri ${earnTokens.length - 10}\n`;
                    }
                }
                
                details += `\n${'‚îÄ'.repeat(40)}\n`;
                details += `üí∞ TOTALE: ‚Ç¨${totalEur.toFixed(2)}\n`;
                details += `üìä Token: ${normalTokens.length} (+ ${earnTokens.length} in Earn)`;
            } else {
                details += `‚ö†Ô∏è Nessun saldo reale disponibile.\n`;
                details += `I saldi sono calcolati dalle transazioni.`;
            }
            
            alert(details);
        }
        
        // ==================== EXCHANGE DETAIL VIEW ====================
        let currentDetailExchange = null;
        let exchDetailTxPage = 1;
        let exchDetailFilteredTx = [];
        
        function initExchangeGrid() {
            const grid = document.getElementById('exchangeGrid');
            if (!grid) return;
            
            let html = '';
            for (const exch of EXCHANGE_LIST) {
                const data = exchangeData[exch.id] || {};
                const hasTx = (data.transactions && data.transactions.length > 0);
                const hasData = hasTx || data.transactionCount > 0 || data.isZeroed || data.isManual || (data.totals && Object.values(data.totals).some(v => v > 0));
                const txCount = data.transactions ? data.transactions.length : (data.transactionCount || 0);
                const total2025 = data.totals ? (data.totals[2025] || 0) : 0;
                const total2026 = data.totals ? (data.totals[2026] || 0) : 0;
                const displayTotal = total2026 > 0 ? total2026 : total2025;
                const displayYear = total2026 > 0 ? '2026' : '2025';
                const isZeroed = data.isZeroed || false;
                const source = data.source || '';
                
                // Card compatta cliccabile
                html += `<div class="card" style="cursor:pointer;transition:all 0.2s;border:2px solid transparent;" 
                         onclick="openExchangeDetail('${exch.id}')"
                         onmouseover="this.style.borderColor='var(--accent)'"
                         onmouseout="this.style.borderColor='transparent'">`;
                html += '<div style="display:flex;align-items:center;gap:12px;">';
                
                // Logo
                if (exch.logo) {
                    html += `<img src="${exch.logo}" style="width:48px;height:48px;border-radius:12px;object-fit:cover;" 
                             onerror="this.outerHTML='<span style=\\'width:48px;height:48px;background:${exch.color};border-radius:12px;display:flex;align-items:center;justify-content:center;font-size:18px;font-weight:bold;color:#fff;\\'>${exch.icon}</span>'">`;
                } else {
                    html += `<span style="width:48px;height:48px;background:${exch.color};border-radius:12px;display:flex;align-items:center;justify-content:center;font-size:18px;font-weight:bold;color:#fff;">${exch.icon}</span>`;
                }
                
                // Info
                html += '<div style="flex:1;min-width:0;">';
                html += `<div style="font-size:15px;font-weight:600;">${exch.name}</div>`;
                
                if (isZeroed) {
                    html += '<div style="font-size:11px;color:var(--yellow);">‚ö†Ô∏è Azzerato</div>';
                } else if (source === 'api') {
                    html += `<div style="font-size:11px;color:var(--green);">‚úì ${txCount} tx via API</div>`;
                } else if (hasData && txCount > 0) {
                    html += `<div style="font-size:11px;color:var(--green);">‚úì ${txCount} transazioni</div>`;
                } else if (hasData) {
                    html += '<div style="font-size:11px;color:var(--accent);">‚úì Dati salvati</div>';
                } else {
                    html += `<div style="font-size:11px;color:var(--text-secondary);">Clicca per configurare</div>`;
                }
                html += '</div>';
                
                // Totale
                if (hasData && displayTotal > 0) {
                    html += `<div style="text-align:right;">
                        <div style="font-size:10px;color:var(--text-secondary);">${displayYear}</div>
                        <div style="font-size:18px;font-weight:700;color:var(--green);">‚Ç¨${Math.round(displayTotal)}</div>
                    </div>`;
                } else if (isZeroed) {
                    html += `<div style="text-align:right;">
                        <div style="font-size:10px;color:var(--text-secondary);">2025</div>
                        <div style="font-size:18px;font-weight:700;color:var(--yellow);">‚Ç¨0</div>
                    </div>`;
                } else {
                    html += '<div style="font-size:24px;color:var(--text-secondary);">‚Üí</div>';
                }
                
                html += '</div></div>';
            }
            
            grid.innerHTML = html;
        }
        
        function openExchangeDetail(exchId) {
            currentDetailExchange = exchId;
            const exch = EXCHANGE_LIST.find(e => e.id === exchId);
            const data = exchangeData[exchId] || {};
            
            if (!exch) return;
            
            // Header
            document.getElementById('exchDetailName').textContent = exch.name;
            
            // Logo
            const logoDiv = document.getElementById('exchDetailLogo');
            if (exch.logo) {
                logoDiv.innerHTML = `<img src="${exch.logo}" style="width:64px;height:64px;border-radius:16px;object-fit:cover;" 
                    onerror="this.outerHTML='<span style=\\'width:64px;height:64px;background:${exch.color};border-radius:16px;display:flex;align-items:center;justify-content:center;font-size:28px;font-weight:bold;color:#fff;\\'>${exch.icon}</span>'">`;
            } else {
                logoDiv.innerHTML = `<span style="width:64px;height:64px;background:${exch.color};border-radius:16px;display:flex;align-items:center;justify-content:center;font-size:28px;font-weight:bold;color:#fff;">${exch.icon}</span>`;
            }
            
            // Status
            const txCount = data.transactions?.length || data.transactionCount || 0;
            const source = data.source || 'csv';
            let statusText = '';
            if (data.isZeroed) {
                statusText = '‚ö†Ô∏è Exchange azzerato (nessun saldo)';
            } else if (source === 'api') {
                statusText = `‚úÖ ${txCount} transazioni importate via API`;
            } else if (txCount > 0) {
                statusText = `‚úÖ ${txCount} transazioni importate da CSV`;
            } else if (data.isManual) {
                statusText = '‚úèÔ∏è Valori inseriti manualmente';
            } else {
                statusText = 'üìÇ Nessun dato importato';
            }
            document.getElementById('exchDetailStatus').textContent = statusText;
            
            // Last update
            if (data.lastImport) {
                const date = new Date(data.lastImport);
                document.getElementById('exchDetailLastUpdate').textContent = `Ultimo aggiornamento: ${date.toLocaleString('it-IT')}`;
            } else {
                document.getElementById('exchDetailLastUpdate').textContent = '';
            }
            
            // Year grid
            renderExchDetailYearGrid(data);
            
            // API section (Binance, Bitget, ecc.)
            const apiSection = document.getElementById('exchDetailApiSection');
            const apiBtn = document.getElementById('exchDetailApiBtn');
            const csvSection = document.getElementById('exchDetailCsvSection');
            const dropzone = document.getElementById('exchDetailDropzone');
            
            if (exch.hasApi) {
                apiSection.style.display = 'block';
                // Configura pulsante in base all'exchange
                if (exchId === 'binance') {
                    apiBtn.textContent = 'üîó Connetti API Binance';
                    apiBtn.style.background = '#f3ba2f';
                    apiBtn.style.color = '#000';
                    // Binance: API + CSV (CSV √® pi√π completo per lo storico!)
                    csvSection.style.display = 'block';
                    dropzone.style.display = 'block';
                } else if (exchId === 'bitget') {
                    apiBtn.textContent = 'üîó Connetti API Bitget';
                    apiBtn.style.background = '#00f0ff';
                    apiBtn.style.color = '#000';
                    csvSection.style.display = 'block';
                    dropzone.style.display = 'block';
                } else if (exchId === 'bitpanda') {
                    apiBtn.textContent = 'üîó Connetti API Bitpanda';
                    apiBtn.style.background = '#08b289';
                    apiBtn.style.color = '#fff';
                    // Bitpanda: meglio CSV per staking
                    csvSection.style.display = 'block';
                    dropzone.style.display = 'block';
                }
                checkBinanceServerStatus();
            } else {
                apiSection.style.display = 'none';
                csvSection.style.display = 'block';
                dropzone.style.display = 'block';
            }
            
            // Balances section
            const balancesSection = document.getElementById('exchDetailBalancesSection');
            if (data.realBalances && Object.keys(data.realBalances).length > 0) {
                balancesSection.style.display = 'block';
                renderExchDetailBalances(data.realBalances);
            } else {
                balancesSection.style.display = 'none';
            }
            
            // Transactions
            document.getElementById('exchDetailTxCount').textContent = txCount;
            exchDetailTxPage = 1;
            filterExchDetailTx();
            
            // üÜï Mostra sezione discrepanze
            renderDiscrepanciesSection(exchId);
            
            showView('exchangeDetail');
        }
        
        function renderExchDetailYearGrid(data) {
            const container = document.getElementById('exchDetailYearGrid');
            const years = [2021, 2022, 2023, 2024, 2025, 2026];
            
            // Conta transazioni per anno
            const txByYear = { 2021: 0, 2022: 0, 2023: 0, 2024: 0, 2025: 0, 2026: 0 };
            if (data.transactions) {
                for (const tx of data.transactions) {
                    const d = tx.date instanceof Date ? tx.date : new Date(tx.date);
                    const y = d.getFullYear();
                    if (txByYear[y] !== undefined) txByYear[y]++;
                }
            }
            
            let html = '';
            const lastTxYear = data.lastYear || 2025;
            const firstTxYear = data.firstYear || 2024;
            
            for (const y of years) {
                const val = data.totals?.[y];
                const txCount = txByYear[y];
                
                // Determina cosa mostrare
                let valueDisplay = '';
                let valueColor = 'var(--green)';
                let subtitle = '';
                
                if (y < firstTxYear) {
                    // Anno prima della prima transazione
                    valueDisplay = '-';
                    valueColor = 'var(--text-secondary)';
                    subtitle = '<div style="font-size:10px;color:var(--text-secondary);">No TX</div>';
                } else if (y > lastTxYear) {
                    // Anno dopo l'ultima transazione (es. 2026 se ultima TX √® 2025)
                    valueDisplay = '-';
                    valueColor = 'var(--text-secondary)';
                    const lastTxDate = data.lastTxDate ? new Date(data.lastTxDate).toLocaleDateString('it-IT') : '';
                    subtitle = `<div style="font-size:9px;color:var(--text-secondary);">Ultima TX: ${lastTxDate}</div>`;
                } else if (val === null || val === undefined) {
                    valueDisplay = '?';
                    valueColor = 'var(--text-secondary)';
                    subtitle = '<div style="font-size:10px;color:var(--text-secondary);">N/D</div>';
                } else {
                    valueDisplay = '‚Ç¨' + Math.round(val).toLocaleString('it-IT');
                    valueColor = val > 0 ? 'var(--green)' : 'var(--text-secondary)';
                    subtitle = txCount > 0 
                        ? `<div style="font-size:10px;color:var(--accent);background:rgba(108,92,231,0.15);padding:3px 6px;border-radius:4px;display:inline-block;">${txCount} tx</div>` 
                        : '<div style="font-size:10px;color:var(--text-secondary);">-</div>';
                }
                
                html += `<div style="background:var(--bg-primary);padding:12px 8px;border-radius:8px;text-align:center;cursor:pointer;" 
                         onclick="showYearDetails('${currentDetailExchange}',${y})" title="Clicca per dettagli">
                    <div style="font-size:13px;font-weight:600;color:var(--text-primary);">${y}</div>
                    <div style="font-size:20px;font-weight:700;color:${valueColor};margin:6px 0;">${valueDisplay}</div>
                    ${subtitle}
                </div>`;
            }
            container.innerHTML = html;
        }
        
        function renderExchDetailBalances(balances) {
            const container = document.getElementById('exchDetailBalances');
            const items = Object.entries(balances)
                .filter(([coin, amt]) => amt > 0 && !coin.startsWith('LD')) // Escludi token LD* (Earn duplicati)
                .sort((a, b) => {
                    const priceA = getPriceEur(a[0], 2026) * a[1];
                    const priceB = getPriceEur(b[0], 2026) * b[1];
                    return priceB - priceA;
                })
                .slice(0, 8);
            
            let html = '';
            for (const [coin, amount] of items) {
                const eurValue = amount * getPriceEur(coin, 2026);
                const amtStr = amount < 1 ? amount.toFixed(4) : amount.toLocaleString('it-IT', { maximumFractionDigits: 2 });
                html += `<div style="background:var(--bg-primary);padding:10px;border-radius:6px;">
                    <div style="font-weight:600;font-size:13px;">${coin}</div>
                    <div style="font-size:12px;color:var(--text-secondary);">${amtStr}</div>
                    <div style="font-size:14px;font-weight:600;color:var(--green);">‚Ç¨${eurValue.toFixed(2)}</div>
                </div>`;
            }
            container.innerHTML = html || '<div style="color:var(--text-secondary);">Nessun saldo</div>';
        }
        
        function showAllExchBalances() {
            if (currentDetailExchange) {
                showExchangeBalances(currentDetailExchange);
            }
        }
        
        function filterExchDetailTx() {
            const data = exchangeData[currentDetailExchange] || {};
            const transactions = data.transactions || [];
            const yearFilter = document.getElementById('exchDetailTxYear')?.value || '';
            const typeFilter = document.getElementById('exchDetailTxType')?.value || '';
            
            exchDetailFilteredTx = transactions.filter(tx => {
                const d = tx.date instanceof Date ? tx.date : new Date(tx.date);
                if (yearFilter && d.getFullYear().toString() !== yearFilter) return false;
                if (typeFilter && tx.type !== typeFilter) return false;
                return true;
            });
            
            // Ordina per data desc
            exchDetailFilteredTx.sort((a, b) => {
                const da = a.date instanceof Date ? a.date : new Date(a.date);
                const db = b.date instanceof Date ? b.date : new Date(b.date);
                return db - da;
            });
            
            exchDetailTxPage = 1;
            renderExchDetailTxTable();
        }
        
        function renderExchDetailTxTable() {
            const tbody = document.getElementById('exchDetailTxTable');
            const perPage = 50;
            
            if (exchDetailFilteredTx.length === 0) {
                tbody.innerHTML = '<tr><td colspan="5" style="text-align:center;padding:40px;color:var(--text-secondary);">Nessuna transazione trovata</td></tr>';
                document.getElementById('exchDetailTxPagination').innerHTML = '';
                return;
            }
            
            const start = (exchDetailTxPage - 1) * perPage;
            const pageTx = exchDetailFilteredTx.slice(start, start + perPage);
            
            const typeColors = {
                deposit: { bg: 'rgba(0,206,201,0.15)', color: 'var(--green)', icon: 'üì•' },
                fiat_deposit: { bg: 'rgba(0,206,201,0.15)', color: 'var(--green)', icon: 'üí∂' },
                withdrawal: { bg: 'rgba(255,107,107,0.15)', color: 'var(--red)', icon: 'üì§' },
                fiat_withdrawal: { bg: 'rgba(255,107,107,0.15)', color: 'var(--red)', icon: 'üí∂' },
                trade: { bg: 'rgba(108,92,231,0.15)', color: 'var(--accent)', icon: 'üìä' },
                buy: { bg: 'rgba(0,206,201,0.15)', color: 'var(--green)', icon: 'üõí' },
                sell: { bg: 'rgba(255,107,107,0.15)', color: 'var(--red)', icon: 'üí∞' },
                convert: { bg: 'rgba(243,186,47,0.15)', color: '#f3ba2f', icon: 'üîÑ' },
                staking: { bg: 'rgba(0,206,201,0.15)', color: 'var(--green)', icon: 'ü•©' },
                interest: { bg: 'rgba(0,206,201,0.15)', color: 'var(--green)', icon: 'üí∞' },
                dividend: { bg: 'rgba(0,206,201,0.15)', color: 'var(--green)', icon: 'üéÅ' },
                fee: { bg: 'rgba(255,107,107,0.15)', color: 'var(--red)', icon: 'üí∏' },
                transfer: { bg: 'rgba(108,92,231,0.15)', color: 'var(--accent)', icon: '‚ÜîÔ∏è' },
                refund: { bg: 'rgba(0,206,201,0.15)', color: 'var(--green)', icon: '‚Ü©Ô∏è' }
            };
            
            let html = '';
            for (const tx of pageTx) {
                const d = tx.timestamp || tx.date;
                const txDate = d instanceof Date ? d : new Date(d);
                const dateStr = txDate.toLocaleDateString('it-IT');
                const timeStr = txDate.toLocaleTimeString('it-IT', { hour: '2-digit', minute: '2-digit' });
                const style = typeColors[tx.type] || { bg: 'rgba(160,160,160,0.15)', color: 'var(--text-secondary)', icon: '‚Ä¢' };
                const amt = parseFloat(tx.amount_in || tx.amount) || 0;
                const change = parseFloat(tx.change) || 0;
                const amtColor = change >= 0 ? 'var(--green)' : 'var(--red)';
                const sign = change >= 0 ? '+' : '';
                
                // Etichette pi√π leggibili
                const typeLabels = {
                    deposit: 'Deposit',
                    withdrawal: 'Withdraw',
                    fiat_deposit: 'Fiat In',
                    fiat_withdrawal: 'Fiat Out',
                    trade: 'Trade',
                    buy: 'Buy',
                    sell: 'Sell',
                    convert: 'Convert',
                    swap: 'Swap',
                    staking: 'Staking',
                    interest: 'Interest',
                    dividend: 'Dividend',
                    reward: 'Reward',
                    fee: 'Fee',
                    dust: 'Dust',
                    transfer: 'Transfer',
                    refund: 'Refund'
                };
                let typeLabel = typeLabels[tx.type] || tx.type || '-';
                
                // üîó Indicatore transfer interno
                if (tx.is_internal || tx.linked_tx_id) {
                    typeLabel = 'üîó ' + typeLabel;
                }
                
                // Coin display (con asset_out per swap)
                const coinDisplay = tx.asset_out && tx.asset_out !== 'EUR' && tx.type === 'swap' 
                    ? `${tx.asset_in || tx.coin} ‚Üí ${tx.asset_out}`
                    : (tx.asset_in || tx.coin || '-');
                
                // Valore EUR - usa nuovi campi se disponibili
                let eurValue = '';
                let eurColor = 'var(--text-secondary)';
                
                // 1. value_eur dalla transazione arricchita
                if (tx.value_eur && tx.value_eur > 0) {
                    eurValue = `‚Ç¨${formatNumber(tx.value_eur)}`;
                    eurColor = 'var(--text-primary)';
                }
                // 2. amountEur legacy
                else if (tx.amountEur && tx.amountEur > 0) {
                    eurValue = `‚Ç¨${formatNumber(tx.amountEur)}`;
                }
                // 3. Calcola da prezzo
                else if (tx.price_eur && tx.price_eur > 0) {
                    const calcEur = amt * tx.price_eur;
                    if (calcEur > 0.001) {
                        eurValue = `~‚Ç¨${formatNumber(calcEur)}`;
                    }
                }
                // 4. Fallback: getPriceEur
                else {
                    const price = getPriceEur(tx.asset_in || tx.coin, txDate);
                    if (price && price > 0) {
                        const calcEur = amt * price;
                        if (calcEur > 0.001) {
                            eurValue = `~‚Ç¨${formatNumber(calcEur)}`;
                        }
                    }
                }
                
                // Fee indicator
                const feeIndicator = tx.fee_eur && tx.fee_eur > 0 
                    ? `<span style="font-size:10px;color:var(--yellow);" title="Fee: ‚Ç¨${tx.fee_eur.toFixed(2)}">üí∏</span>` 
                    : '';
                
                // Row style per transfer interni (sfondo diverso)
                const rowStyle = tx.is_internal ? 'background:rgba(108,92,231,0.05);' : '';
                
                html += `<tr style="${rowStyle}">
                    <td style="white-space:nowrap;">
                        <div style="font-size:14px;font-weight:500;">${dateStr}</div>
                        <div style="font-size:11px;color:var(--text-secondary);">${timeStr}</div>
                    </td>
                    <td>
                        <span class="tx-badge" style="background:${style.bg};color:${style.color};">${style.icon} ${typeLabel}</span>
                    </td>
                    <td style="text-align:center;font-weight:600;font-size:14px;">${coinDisplay}</td>
                    <td style="text-align:right;color:${amtColor};font-weight:600;font-size:14px;font-family:'SF Mono',Monaco,monospace;">${sign}${formatNumber(Math.abs(change) || amt)} ${feeIndicator}</td>
                    <td style="text-align:right;font-size:13px;color:${eurColor};font-family:'SF Mono',Monaco,monospace;">${eurValue}</td>
                </tr>`;
            }
            tbody.innerHTML = html;
            
            // Pagination
            const totalPages = Math.ceil(exchDetailFilteredTx.length / perPage);
            if (totalPages > 1) {
                let pagHtml = '';
                pagHtml += `<button class="btn btn-secondary" style="padding:4px 8px;font-size:11px;" onclick="exchDetailTxPage--;renderExchDetailTxTable()" ${exchDetailTxPage === 1 ? 'disabled' : ''}>‚Üê</button>`;
                pagHtml += `<span style="font-size:12px;color:var(--text-secondary);margin:0 8px;">Pagina ${exchDetailTxPage}/${totalPages}</span>`;
                pagHtml += `<button class="btn btn-secondary" style="padding:4px 8px;font-size:11px;" onclick="exchDetailTxPage++;renderExchDetailTxTable()" ${exchDetailTxPage === totalPages ? 'disabled' : ''}>‚Üí</button>`;
                document.getElementById('exchDetailTxPagination').innerHTML = pagHtml;
            } else {
                document.getElementById('exchDetailTxPagination').innerHTML = '';
            }
        }
        
        function exportExchDetailTx() {
            if (exchDetailFilteredTx.length === 0) {
                alert('Nessuna transazione da esportare');
                return;
            }
            let csv = 'Data,Tipo,Coin,Importo,Change,Operazione\n';
            for (const tx of exchDetailFilteredTx) {
                const d = tx.date instanceof Date ? tx.date : new Date(tx.date);
                csv += `"${d.toISOString()}","${tx.type || ''}","${tx.coin || ''}",${tx.amount || 0},${tx.change || 0},"${tx.operation || ''}"\n`;
            }
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${currentDetailExchange}_transazioni.csv`;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        function clearCurrentExchangeData() {
            if (currentDetailExchange && confirm(`Vuoi eliminare tutti i dati di ${currentDetailExchange}?`)) {
                clearExchangeData(currentDetailExchange);
                showView('exchanges');
            }
        }
        
        function scanCurrentExchange() {
            if (currentDetailExchange === 'binance') {
                openBinanceApiModal();
            } else if (currentDetailExchange === 'bitget') {
                openBitgetApiModal();
            } else if (currentDetailExchange === 'bitpanda') {
                openBitpandaApiModal();
            } else {
                document.getElementById('exchDetailFileInput').click();
            }
        }
        
        function handleExchDetailFileSelect(event) {
            const files = event.target.files;
            if (files.length > 0 && currentDetailExchange) {
                processExchangeFiles(files, currentDetailExchange);
            }
        }
        
        function handleExchDetailDrop(event) {
            event.preventDefault();
            event.target.style.borderColor = 'var(--border)';
            event.target.style.background = 'transparent';
            const files = event.dataTransfer.files;
            if (files.length > 0 && currentDetailExchange) {
                processExchangeFiles(files, currentDetailExchange);
            }
        }
        
        // ==================== EXCHANGE API FUNCTIONS ====================
        
        // Verifica se il server Binance √® attivo
        async function checkBinanceServerStatus() {
            const statusEl = document.getElementById('serverStatus-binance');
            const modalStatusEl = document.getElementById('modalServerStatus');
            
            try {
                const response = await fetch('http://localhost:3457/status', { 
                    method: 'GET',
                    signal: AbortSignal.timeout(2000) 
                });
                
                if (response.ok) {
                    // Aggiorna badge nella card
                    if (statusEl) {
                        statusEl.textContent = 'üü¢ ON';
                        statusEl.style.background = 'var(--green)';
                        statusEl.style.color = '#000';
                    }
                    // Aggiorna badge nel modal
                    if (modalStatusEl) {
                        modalStatusEl.textContent = 'ONLINE';
                        modalStatusEl.className = 'server-status-badge server-on';
                    }
                    console.log('‚úÖ Binance Tax Server attivo');
                    return true;
                }
            } catch (e) {
                // Server non attivo
            }
            
            // Server offline
            if (statusEl) {
                statusEl.textContent = '‚ö´ OFF';
                statusEl.style.background = 'var(--red)';
                statusEl.style.color = '#fff';
            }
            if (modalStatusEl) {
                modalStatusEl.textContent = 'OFFLINE';
                modalStatusEl.className = 'server-status-badge server-off';
            }
            console.log('‚ö†Ô∏è Binance Tax Server non attivo');
            return false;
        }
        
        // Funzioni Modal Binance API
        function openExchangeApiModal() {
            // Apre il modal corretto in base all'exchange corrente
            if (currentDetailExchange === 'binance') {
                openBinanceApiModal();
            } else if (currentDetailExchange === 'bitget') {
                openBitgetApiModal();
            } else if (currentDetailExchange === 'bitpanda') {
                openBitpandaApiModal();
            } else {
                alert('API non supportata per questo exchange');
            }
        }
        
        function openBinanceApiModal() {
            const modal = document.getElementById('binanceApiModal');
            const apiKeyInput = document.getElementById('modalApiKey');
            const secretKeyInput = document.getElementById('modalSecretKey');
            
            // Pre-popola con chiavi salvate
            if (apiKeys.binanceTaxKey) apiKeyInput.value = apiKeys.binanceTaxKey;
            if (apiKeys.binanceTaxSecret) secretKeyInput.value = apiKeys.binanceTaxSecret;
            
            // Reset progress
            document.getElementById('modalProgress').style.display = 'none';
            document.getElementById('modalProgressBar').style.width = '0%';
            document.getElementById('modalProgressText').textContent = '';
            
            modal.classList.add('active');
            checkModalServerStatus();
        }
        
        function closeBinanceApiModal() {
            document.getElementById('binanceApiModal').classList.remove('active');
        }
        
        async function checkModalServerStatus() {
            const statusEl = document.getElementById('modalServerStatus');
            const cardStatusEl = document.getElementById('serverStatus-binance');
            
            try {
                const response = await fetch('http://localhost:3457/status', { 
                    method: 'GET',
                    signal: AbortSignal.timeout(2000) 
                });
                
                if (response.ok) {
                    statusEl.textContent = 'ONLINE';
                    statusEl.className = 'server-status-badge server-on';
                    if (cardStatusEl) {
                        cardStatusEl.textContent = 'üü¢ ON';
                        cardStatusEl.style.background = 'var(--green)';
                        cardStatusEl.style.color = '#000';
                    }
                    return true;
                }
            } catch (e) {}
            
            statusEl.textContent = 'OFFLINE';
            statusEl.className = 'server-status-badge server-off';
            if (cardStatusEl) {
                cardStatusEl.textContent = '‚ö´ OFF';
                cardStatusEl.style.background = 'var(--red)';
                cardStatusEl.style.color = '#fff';
            }
            return false;
        }
        
        async function downloadFromModal() {
            const apiKey = document.getElementById('modalApiKey').value.trim();
            const secretKey = document.getElementById('modalSecretKey').value.trim();
            const progressContainer = document.getElementById('modalProgress');
            const progressBar = document.getElementById('modalProgressBar');
            const progressText = document.getElementById('modalProgressText');
            
            if (!apiKey || !secretKey) {
                alert('‚ö†Ô∏è Inserisci API Key e Secret Key!\n\nVai su Binance ‚Üí Profilo ‚Üí Gestione API ‚Üí "Crea API report fiscale"');
                return;
            }
            
            // Salva le chiavi
            apiKeys.binanceTaxKey = apiKey;
            apiKeys.binanceTaxSecret = secretKey;
            localStorage.setItem('cryptofolio_apikeys', JSON.stringify(apiKeys));
            
            // Mostra progress
            progressContainer.style.display = 'block';
            progressBar.style.width = '5%';
            progressText.textContent = 'Verifica server...';
            
            try {
                // Verifica server
                const serverOnline = await checkModalServerStatus();
                if (!serverOnline) {
                    throw new Error('Server non attivo! Avvia AVVIA_SERVER.command');
                }
                
                progressBar.style.width = '10%';
                progressText.textContent = 'Download in corso... (1-2 minuti)';
                
                // Download
                const downloadUrl = `http://localhost:3457/download?apiKey=${encodeURIComponent(apiKey)}&secretKey=${encodeURIComponent(secretKey)}`;
                const response = await fetch(downloadUrl);
                const data = await response.json();
                
                if (data.error) throw new Error(data.error);
                
                let rawTransactions = data.transactions || [];
                const txCount = data.count || rawTransactions.length;
                
                if (txCount === 0) {
                    progressText.textContent = '‚ö†Ô∏è Nessuna transazione trovata';
                    alert('‚ö†Ô∏è Nessuna transazione.\n\nVerifica di aver usato "API report fiscale"');
                    return;
                }
                
                progressBar.style.width = '70%';
                progressText.textContent = `Elaborazione ${txCount} transazioni...`;
                
                // üîë De-duplicazione transazioni migliorata
                const { unique: uniqueTransactions, duplicates } = deduplicateTransactions(
                    rawTransactions.map(tx => ({
                        ...tx,
                        tx_hash: tx.txId || null,
                        order_id: tx.orderId || null,
                        timestamp: new Date(tx.date)
                    }))
                );
                
                if (duplicates.length > 0) {
                    console.log(`üîë Rimossi ${duplicates.length} duplicati`);
                }
                
                // üÜï Converti in transazioni ARRICCHITE
                const allTransactions = uniqueTransactions.map(tx => {
                    // Inferisci tipo se non specificato
                    let txType = tx.type || 'unknown';
                    const change = tx.change || tx.amount || 0;
                    
                    // Se tipo generico, inferisci da change
                    if (txType === 'unknown' || txType === '') {
                        if (change > 0) txType = 'deposit';
                        else if (change < 0) txType = 'withdrawal';
                    }
                    
                    return createEnrichedTransaction({
                        timestamp: new Date(tx.date),
                        type: txType,
                        asset_in: tx.coin,
                        asset_out: tx.asset_out || (tx.type === 'buy' ? 'EUR' : null),
                        amount_in: Math.abs(tx.amount || tx.change || 0),
                        amount_out: tx.amount_out || 0,
                        price_eur: tx.priceEur || 0,
                        value_eur: tx.amountEur || 0,
                        fee_eur: tx.feeEur || 0,
                        fee_asset: tx.feeAsset || null,
                        fee_amount: tx.feeAmount || 0,
                        tx_hash: tx.txId || null,
                        order_id: tx.orderId || null,
                        source: 'binance',
                        exchange: 'binance',
                        change: change,
                        notes: tx.notes || ''
                    });
                });
                
                allTransactions.sort((a, b) => a.timestamp - b.timestamp);
                
                // üîó Transfer Matching
                matchInternalTransfers(allTransactions, 30);
                
                progressBar.style.width = '85%';
                progressText.textContent = 'Calcolo saldi 31/12...';
                
                // Calcola saldi al 31/12 dalle transazioni
                const balances = {};
                const yearEndSnapshots = {};
                const years = [2021, 2022, 2023, 2024, 2025, 2026];
                let yearIndex = 0;
                
                for (const tx of allTransactions) {
                    const coin = tx.asset_in || tx.coin;
                    if (!balances[coin]) balances[coin] = 0;
                    balances[coin] += tx.change || 0;
                    if (Math.abs(balances[coin]) < 0.00000001) balances[coin] = 0;
                    
                    const txDate = tx.timestamp || tx.date;
                    while (yearIndex < years.length && txDate > new Date(years[yearIndex], 11, 31, 23, 59, 59)) {
                        yearEndSnapshots[years[yearIndex]] = { ...balances };
                        yearIndex++;
                    }
                }
                
                for (let i = yearIndex; i < years.length; i++) {
                    yearEndSnapshots[years[i]] = { ...balances };
                }
                
                // üÜï USA SALDI REALI per 2025 e 2026 se disponibili!
                const realBalances = data.realBalances || {};
                const hasRealBalances = Object.keys(realBalances).length > 0;
                
                if (hasRealBalances) {
                    console.log('‚úÖ Usando SALDI REALI per 2025/2026:', Object.keys(realBalances).length, 'asset');
                    yearEndSnapshots[2025] = { ...realBalances };
                    yearEndSnapshots[2026] = { ...realBalances }; // Saldi attuali = 2026
                }
                
                // Calcola totali EUR
                const yearTotals = {};
                for (const year of years) {
                    let totalEur = 0;
                    const snapshot = yearEndSnapshots[year] || {};
                    for (const [coin, amount] of Object.entries(snapshot)) {
                        if (!amount || amount <= 0) continue;
                        // üö´ Salta i token LD* (sono duplicati dei token in Earn)
                        if (coin.startsWith('LD')) {
                            console.log('‚ö†Ô∏è Saltato token Earn duplicato:', coin);
                            continue;
                        }
                        const priceEur = getPriceEur(coin, year);
                        if (priceEur && !isNaN(priceEur)) {
                            totalEur += amount * priceEur;
                        }
                    }
                    yearTotals[year] = isNaN(totalEur) ? 0 : Math.round(totalEur * 100) / 100;
                }
                
                // üîç Zero-Sum Check
                const zeroCheck = zeroSumCheck(allTransactions, realBalances);
                
                // Salva (includi discrepanze!)
                exchangeData['binance'] = {
                    transactions: allTransactions,
                    balances: yearEndSnapshots,
                    realBalances: hasRealBalances ? realBalances : null,
                    totals: yearTotals,
                    transactionCount: allTransactions.length,
                    discrepancies: zeroCheck.issues || [], // üÜï Salva discrepanze!
                    isManual: false,
                    lastImport: new Date().toISOString(),
                    source: 'api'
                };
                
                progressBar.style.width = '100%';
                const realMsg = hasRealBalances ? ` (con saldi reali!)` : '';
                progressText.textContent = `‚úÖ ${txCount} transazioni importate${realMsg}`;
                
                saveExchangeDataToFirebase();
                initExchangeGrid();
                updateExchangeTotals();
                
                // Mostra dettagli saldi reali
                let alertMsg = `‚úÖ Binance importato!\n\nüìä ${txCount} transazioni`;
                
                // Mostra warning se discrepanze
                if (!zeroCheck.isValid && zeroCheck.issues.length > 0) {
                    alertMsg += `\n\n‚ö†Ô∏è ${zeroCheck.issues.length} discrepanze rilevate!`;
                    alertMsg += `\n(Visibili nella sezione dedicata)`;
                }
                
                if (hasRealBalances) {
                    alertMsg += `\n\nüíé SALDI REALI 2025:`;
                    const topBalances = Object.entries(realBalances)
                        .filter(([_, amt]) => amt > 0)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 5);
                    for (const [coin, amt] of topBalances) {
                        alertMsg += `\n   ${coin}: ${amt.toFixed(amt < 1 ? 6 : 2)}`;
                    }
                    alertMsg += `\n\nüí∞ Totale 2025: ‚Ç¨${yearTotals[2025]?.toLocaleString('it-IT') || '?'}`;
                }
                
                // Chiudi modal dopo 1.5 secondi
                setTimeout(() => {
                    closeBinanceApiModal();
                    // Forza refresh UI
                    initExchangeGrid();
                    updateExchangeTotals();
                    // Riapri dettaglio Binance per mostrare i nuovi dati
                    openExchangeDetail('binance');
                    alert(alertMsg);
                }, 1500);
                
            } catch (e) {
                console.error('Binance API error:', e);
                progressBar.style.width = '0%';
                progressText.textContent = '‚ùå ' + e.message;
                
                if (e.message.includes('Failed to fetch') || e.message.includes('non attivo')) {
                    alert('‚ö†Ô∏è Server non attivo!\n\nAvvia AVVIA_SERVER.command e riprova.');
                } else {
                    alert('‚ùå Errore: ' + e.message);
                }
            }
        }
        
        // ==================== BITGET API FUNCTIONS ====================
        
        function openBitgetApiModal() {
            const modal = document.getElementById('bitgetApiModal');
            const apiKeyInput = document.getElementById('bitgetModalApiKey');
            const secretKeyInput = document.getElementById('bitgetModalSecretKey');
            const passphraseInput = document.getElementById('bitgetModalPassphrase');
            
            // Pre-popola con chiavi salvate
            if (apiKeys.bitgetApiKey) apiKeyInput.value = apiKeys.bitgetApiKey;
            if (apiKeys.bitgetSecretKey) secretKeyInput.value = apiKeys.bitgetSecretKey;
            if (apiKeys.bitgetPassphrase) passphraseInput.value = apiKeys.bitgetPassphrase;
            
            // Reset progress
            document.getElementById('bitgetModalProgress').style.display = 'none';
            document.getElementById('bitgetModalProgressBar').style.width = '0%';
            document.getElementById('bitgetModalProgressText').textContent = '';
            
            modal.classList.add('active');
            checkBitgetServerStatus();
        }
        
        function closeBitgetApiModal() {
            document.getElementById('bitgetApiModal').classList.remove('active');
        }
        
        async function checkBitgetServerStatus() {
            const statusEl = document.getElementById('bitgetModalServerStatus');
            
            try {
                const response = await fetch('http://localhost:3457/status', { 
                    method: 'GET',
                    signal: AbortSignal.timeout(2000) 
                });
                
                if (response.ok) {
                    statusEl.textContent = 'ONLINE';
                    statusEl.className = 'server-status-badge server-on';
                    return true;
                }
            } catch (e) {}
            
            statusEl.textContent = 'OFFLINE';
            statusEl.className = 'server-status-badge server-off';
            return false;
        }
        
        async function downloadFromBitgetModal() {
            const apiKey = document.getElementById('bitgetModalApiKey').value.trim();
            const secretKey = document.getElementById('bitgetModalSecretKey').value.trim();
            const passphrase = document.getElementById('bitgetModalPassphrase').value.trim();
            const progressContainer = document.getElementById('bitgetModalProgress');
            const progressBar = document.getElementById('bitgetModalProgressBar');
            const progressText = document.getElementById('bitgetModalProgressText');
            
            if (!apiKey || !secretKey || !passphrase) {
                alert('‚ö†Ô∏è Inserisci API Key, Secret Key e Passphrase!\n\nVai su Bitget ‚Üí Account ‚Üí API');
                return;
            }
            
            // Salva le chiavi
            apiKeys.bitgetApiKey = apiKey;
            apiKeys.bitgetSecretKey = secretKey;
            apiKeys.bitgetPassphrase = passphrase;
            localStorage.setItem('cryptofolio_apikeys', JSON.stringify(apiKeys));
            saveToFirebase(); // Sync con cloud
            
            // Mostra progress
            progressContainer.style.display = 'block';
            progressBar.style.width = '5%';
            progressText.textContent = 'Verifica server...';
            
            try {
                // Verifica server
                const serverOnline = await checkBitgetServerStatus();
                if (!serverOnline) {
                    throw new Error('Server non attivo! Avvia il server prima');
                }
                
                progressBar.style.width = '10%';
                progressText.textContent = 'Download in corso... (1-2 minuti)';
                
                // Download
                const downloadUrl = `http://localhost:3457/bitget/download?apiKey=${encodeURIComponent(apiKey)}&secretKey=${encodeURIComponent(secretKey)}&passphrase=${encodeURIComponent(passphrase)}`;
                const response = await fetch(downloadUrl);
                const data = await response.json();
                
                if (data.error) throw new Error(data.error);
                
                let rawTransactions = data.transactions || [];
                const txCount = data.count || rawTransactions.length;
                
                if (txCount === 0 && !data.realBalances) {
                    progressText.textContent = '‚ö†Ô∏è Nessun dato trovato';
                    alert('‚ö†Ô∏è Nessuna transazione o saldo trovato.\n\nVerifica che le API abbiano i permessi corretti.');
                    return;
                }
                
                progressBar.style.width = '70%';
                progressText.textContent = `Elaborazione ${txCount} transazioni...`;
                
                // De-duplicazione
                const seenTx = new Set();
                const uniqueTransactions = rawTransactions.filter(tx => {
                    const key = tx.id || `${tx.date}-${tx.coin}-${tx.amount}-${tx.type}`;
                    if (seenTx.has(key)) return false;
                    seenTx.add(key);
                    return true;
                });
                
                // Converti le transazioni
                const allTransactions = uniqueTransactions.map(tx => ({
                    ...tx,
                    date: new Date(tx.date),
                    change: tx.change || tx.amount || 0
                }));
                
                allTransactions.sort((a, b) => a.date - b.date);
                
                progressBar.style.width = '85%';
                progressText.textContent = 'Calcolo saldi 31/12...';
                
                // Calcola saldi al 31/12 dalle transazioni
                const balances = {};
                const yearEndSnapshots = {};
                const years = [2021, 2022, 2023, 2024, 2025, 2026];
                let yearIndex = 0;
                
                for (const tx of allTransactions) {
                    if (!balances[tx.coin]) balances[tx.coin] = 0;
                    balances[tx.coin] += tx.change || 0;
                    if (Math.abs(balances[tx.coin]) < 0.00000001) balances[tx.coin] = 0;
                    
                    while (yearIndex < years.length && tx.date > new Date(years[yearIndex], 11, 31, 23, 59, 59)) {
                        yearEndSnapshots[years[yearIndex]] = { ...balances };
                        yearIndex++;
                    }
                }
                
                for (let i = yearIndex; i < years.length; i++) {
                    yearEndSnapshots[years[i]] = { ...balances };
                }
                
                // USA SALDI REALI per 2025 e 2026 se disponibili!
                const realBalances = data.realBalances || {};
                const hasRealBalances = Object.keys(realBalances).length > 0;
                
                if (hasRealBalances) {
                    console.log('‚úÖ Usando SALDI REALI Bitget per 2025/2026:', Object.keys(realBalances).length, 'asset');
                    yearEndSnapshots[2025] = { ...realBalances };
                    yearEndSnapshots[2026] = { ...realBalances };
                }
                
                // Calcola totali EUR
                const yearTotals = {};
                for (const year of years) {
                    let totalEur = 0;
                    const snapshot = yearEndSnapshots[year] || {};
                    for (const [coin, amount] of Object.entries(snapshot)) {
                        if (!amount || amount <= 0) continue;
                        const priceEur = getPriceEur(coin, year);
                        if (priceEur && !isNaN(priceEur)) {
                            totalEur += amount * priceEur;
                        }
                    }
                    yearTotals[year] = isNaN(totalEur) ? 0 : Math.round(totalEur * 100) / 100;
                }
                
                // Salva
                exchangeData['bitget'] = {
                    transactions: allTransactions,
                    balances: yearEndSnapshots,
                    realBalances: hasRealBalances ? realBalances : null,
                    totals: yearTotals,
                    transactionCount: allTransactions.length,
                    isManual: false,
                    lastImport: new Date().toISOString(),
                    source: 'api'
                };
                
                progressBar.style.width = '100%';
                const realMsg = hasRealBalances ? ` (con saldi reali!)` : '';
                progressText.textContent = `‚úÖ ${txCount} transazioni importate${realMsg}`;
                
                saveExchangeDataToFirebase();
                initExchangeGrid();
                updateExchangeTotals();
                
                // Messaggio finale
                let alertMsg = `‚úÖ Bitget importato!\n\nüìä ${txCount} transazioni`;
                if (hasRealBalances) {
                    alertMsg += `\n\nüíé SALDI REALI:`;
                    const topBalances = Object.entries(realBalances)
                        .filter(([_, amt]) => amt > 0)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 5);
                    for (const [coin, amt] of topBalances) {
                        alertMsg += `\n   ${coin}: ${amt.toFixed(amt < 1 ? 6 : 2)}`;
                    }
                    alertMsg += `\n\nüí∞ Totale 2025: ‚Ç¨${yearTotals[2025]?.toLocaleString('it-IT') || '?'}`;
                }
                
                // Chiudi modal dopo 1.5 secondi
                setTimeout(() => {
                    closeBitgetApiModal();
                    alert(alertMsg);
                    // Aggiorna vista dettaglio se aperta
                    if (currentDetailExchange === 'bitget') {
                        openExchangeDetail('bitget');
                    }
                }, 1500);
                
            } catch (e) {
                console.error('Bitget API error:', e);
                progressBar.style.width = '0%';
                progressText.textContent = '‚ùå ' + e.message;
                
                if (e.message.includes('Failed to fetch') || e.message.includes('non attivo')) {
                    alert('‚ö†Ô∏è Server non attivo!\n\nAvvia il server e riprova.');
                } else {
                    alert('‚ùå Errore: ' + e.message);
                }
            }
        }
        
        // ==================== BITPANDA API FUNCTIONS ====================
        
        function openBitpandaApiModal() {
            const modal = document.getElementById('bitpandaApiModal');
            const apiKeyInput = document.getElementById('bitpandaModalApiKey');
            
            // Pre-popola con chiave salvata
            if (apiKeys.bitpandaApiKey) apiKeyInput.value = apiKeys.bitpandaApiKey;
            
            // Reset progress
            document.getElementById('bitpandaModalProgress').style.display = 'none';
            document.getElementById('bitpandaModalProgressBar').style.width = '0%';
            document.getElementById('bitpandaModalProgressText').textContent = '';
            
            modal.classList.add('active');
        }
        
        function closeBitpandaApiModal() {
            document.getElementById('bitpandaApiModal').classList.remove('active');
        }
        
        async function downloadFromBitpandaModal() {
            const apiKey = document.getElementById('bitpandaModalApiKey').value.trim();
            const progressContainer = document.getElementById('bitpandaModalProgress');
            const progressBar = document.getElementById('bitpandaModalProgressBar');
            const progressText = document.getElementById('bitpandaModalProgressText');
            
            if (!apiKey) {
                alert('‚ö†Ô∏è Inserisci la tua Bitpanda API Key!\n\nVai su Bitpanda ‚Üí Profilo ‚Üí API');
                return;
            }
            
            // Salva la chiave
            apiKeys.bitpandaApiKey = apiKey;
            localStorage.setItem('cryptofolio_apikeys', JSON.stringify(apiKeys));
            saveToFirebase();
            
            // Mostra progress
            progressContainer.style.display = 'block';
            progressBar.style.width = '5%';
            progressText.textContent = 'Connessione a Bitpanda...';
            
            try {
                const allTransactions = [];
                const realBalances = {};
                
                // 1. Fetch crypto wallets (saldi)
                progressBar.style.width = '10%';
                progressText.textContent = 'Caricamento wallet crypto...';
                
                const walletsRes = await fetch('https://api.bitpanda.com/v1/wallets', {
                    headers: { 'X-Api-Key': apiKey }
                });
                
                if (!walletsRes.ok) {
                    if (walletsRes.status === 401) throw new Error('API Key non valida');
                    throw new Error(`Errore wallet: ${walletsRes.status}`);
                }
                
                const walletsData = await walletsRes.json();
                console.log('Bitpanda wallets:', walletsData);
                
                // Estrai saldi reali (inclusi staked)
                for (const wallet of (walletsData.data || [])) {
                    const symbol = wallet.attributes?.cryptocoin_symbol;
                    const balance = parseFloat(wallet.attributes?.balance) || 0;
                    const stakedBalance = parseFloat(wallet.attributes?.staked_balance) || 0;
                    const totalBalance = balance + stakedBalance;
                    
                    if (symbol && totalBalance > 0) {
                        realBalances[symbol] = (realBalances[symbol] || 0) + totalBalance;
                        if (stakedBalance > 0) {
                            console.log(`  üíé ${symbol}: ${balance} + ${stakedBalance} staked = ${totalBalance}`);
                        }
                    }
                }
                
                // 2. Fetch crypto transactions
                progressBar.style.width = '30%';
                progressText.textContent = 'Caricamento transazioni crypto...';
                
                let cursor = null;
                let pageCount = 0;
                const maxPages = 50;
                
                do {
                    let txUrl = 'https://api.bitpanda.com/v1/wallets/transactions?page_size=100';
                    if (cursor) txUrl += `&cursor=${cursor}`;
                    
                    const txRes = await fetch(txUrl, {
                        headers: { 'X-Api-Key': apiKey }
                    });
                    
                    if (!txRes.ok) break;
                    
                    const txData = await txRes.json();
                    
                    for (const tx of (txData.data || [])) {
                        const attrs = tx.attributes;
                        const date = attrs?.time?.date_iso8601 ? new Date(attrs.time.date_iso8601) : new Date();
                        const amount = parseFloat(attrs?.amount) || 0;
                        // Prova vari campi per il valore EUR
                        const amountEur = parseFloat(attrs?.amount_eur) || parseFloat(attrs?.current_fiat_amount) || 0;
                        
                        // Debug primi 3 tx
                        if (allTransactions.length < 3) {
                            console.log('üìã Bitpanda TX attrs:', JSON.stringify(attrs, null, 2));
                        }
                        
                        // Mappa tipo transazione
                        let type = attrs?.type || 'unknown';
                        const inOrOut = attrs?.in_or_out || '';
                        
                        // Normalizza tipi
                        if (type === 'transfer' && inOrOut === 'incoming') type = 'deposit';
                        if (type === 'transfer' && inOrOut === 'outgoing') type = 'withdrawal';
                        if (type === 'reward' || type === 'staking_reward' || type === 'distribution') type = 'staking';
                        if (type === 'best_reward') type = 'staking'; // BEST/VSN rewards
                        
                        // Debug per vedere tutti i tipi
                        if (!['buy', 'sell', 'deposit', 'withdrawal', 'staking', 'transfer'].includes(type)) {
                            console.log(`  üìã Bitpanda tx type: ${attrs?.type} ‚Üí ${type}`);
                        }
                        
                        // Trova simbolo crypto (da cryptocoin_id)
                        const cryptoId = attrs?.cryptocoin_id;
                        const symbol = findBitpandaCryptoSymbol(cryptoId, walletsData.data) || 'UNKNOWN';
                        
                        // Calcola change (positivo per incoming, negativo per outgoing)
                        const isIncoming = inOrOut === 'incoming' || type === 'buy' || type === 'deposit' || type === 'staking';
                        const change = isIncoming ? amount : -amount;
                        
                        allTransactions.push({
                            date: date,
                            type: type,
                            coin: symbol,
                            amount: amount,
                            change: change,
                            amountEur: amountEur,
                            fee: parseFloat(attrs?.fee) || 0,
                            account: 'bitpanda',
                            txHash: tx.id || ''
                        });
                    }
                    
                    // Paginazione
                    cursor = txData.links?.next ? extractCursor(txData.links.next) : null;
                    pageCount++;
                    
                    progressBar.style.width = `${30 + (pageCount / maxPages) * 30}%`;
                    progressText.textContent = `Transazioni crypto: ${allTransactions.length}...`;
                    
                    await new Promise(r => setTimeout(r, 200));
                } while (cursor && pageCount < maxPages);
                
                // 3. Fetch trades
                progressBar.style.width = '65%';
                progressText.textContent = 'Caricamento trades...';
                
                cursor = null;
                pageCount = 0;
                
                do {
                    let tradesUrl = 'https://api.bitpanda.com/v1/trades?page_size=100';
                    if (cursor) tradesUrl += `&cursor=${cursor}`;
                    
                    const tradesRes = await fetch(tradesUrl, {
                        headers: { 'X-Api-Key': apiKey }
                    });
                    
                    if (!tradesRes.ok) break;
                    
                    const tradesData = await tradesRes.json();
                    
                    for (const trade of (tradesData.data || [])) {
                        const attrs = trade.attributes;
                        const date = attrs?.time?.date_iso8601 ? new Date(attrs.time.date_iso8601) : new Date();
                        const amount = parseFloat(attrs?.amount_cryptocoin) || 0;
                        const amountFiat = parseFloat(attrs?.amount_fiat) || 0;
                        const type = attrs?.type || 'trade'; // buy o sell
                        const cryptoId = attrs?.cryptocoin_id;
                        const symbol = findBitpandaCryptoSymbol(cryptoId, walletsData.data) || 'UNKNOWN';
                        
                        // Buy = +crypto, Sell = -crypto
                        const change = type === 'buy' ? amount : -amount;
                        
                        allTransactions.push({
                            date: date,
                            type: type,
                            coin: symbol,
                            amount: amount,
                            change: change,
                            amountEur: amountFiat,
                            fee: parseFloat(attrs?.fee) || 0,
                            account: 'bitpanda',
                            txHash: trade.id || ''
                        });
                    }
                    
                    cursor = tradesData.links?.next ? extractCursor(tradesData.links.next) : null;
                    pageCount++;
                    
                    await new Promise(r => setTimeout(r, 200));
                } while (cursor && pageCount < maxPages);
                
                // 4. Fetch fiat wallets
                progressBar.style.width = '85%';
                progressText.textContent = 'Caricamento wallet fiat...';
                
                try {
                    const fiatWalletsRes = await fetch('https://api.bitpanda.com/v1/fiatwallets', {
                        headers: { 'X-Api-Key': apiKey }
                    });
                    
                    if (fiatWalletsRes.ok) {
                        const fiatData = await fiatWalletsRes.json();
                        console.log('üí∂ Bitpanda fiat wallets:', fiatData);
                        for (const wallet of (fiatData.data || [])) {
                            const symbol = wallet.attributes?.fiat_symbol;
                            const balance = parseFloat(wallet.attributes?.balance) || 0;
                            console.log(`  üíµ ${symbol}: ${balance}`);
                            if (symbol && balance > 0) {
                                realBalances[symbol] = (realBalances[symbol] || 0) + balance;
                            }
                        }
                    } else {
                        console.log('‚ö†Ô∏è Fiat wallets API failed:', fiatWalletsRes.status);
                    }
                } catch (e) {
                    console.log('‚ö†Ô∏è Fiat wallets error:', e.message);
                }
                
                // Ordina per data
                allTransactions.sort((a, b) => new Date(b.date) - new Date(a.date));
                
                // Calcola totali per anno
                const years = [2021, 2022, 2023, 2024, 2025, 2026];
                const yearTotals = {};
                const yearEndSnapshots = {};
                
                for (const year of years) {
                    yearEndSnapshots[year] = {};
                    yearTotals[year] = 0;
                }
                
                // Calcola snapshot fine anno dai trades
                for (const tx of allTransactions) {
                    const txYear = new Date(tx.date).getFullYear();
                    for (const year of years) {
                        if (txYear <= year) {
                            if (!yearEndSnapshots[year][tx.coin]) yearEndSnapshots[year][tx.coin] = 0;
                            // Entrate: buy, deposit, staking rewards
                            if (tx.type === 'buy' || tx.type === 'deposit' || tx.type === 'staking' || tx.type === 'interest' || tx.type === 'reward') {
                                yearEndSnapshots[year][tx.coin] += tx.amount;
                            } else if (tx.type === 'sell' || tx.type === 'withdrawal') {
                                yearEndSnapshots[year][tx.coin] -= tx.amount;
                            }
                        }
                    }
                }
                
                // Calcola se ci sono saldi reali
                const hasRealBalances = Object.keys(realBalances).length > 0;
                
                // Mappa prezzi token da transazioni (per token senza prezzo CoinGecko)
                const tokenPricesFromTx = {};
                for (const tx of allTransactions) {
                    if (tx.amountEur && tx.amount && tx.amount > 0) {
                        const pricePerUnit = tx.amountEur / tx.amount;
                        if (pricePerUnit > 0) {
                            tokenPricesFromTx[tx.coin] = pricePerUnit; // Ultimo prezzo conosciuto
                        }
                    }
                }
                console.log('üí∞ Prezzi token da transazioni:', tokenPricesFromTx);
                
                // Tassi di cambio fiat
                const fiatRates = { 'EUR': 1, 'USD': EUR_USD, 'CHF': 0.95, 'GBP': 1.17 };
                
                // Calcola valore EUR per anno
                const currentYear = new Date().getFullYear();
                console.log('üìÖ Anno corrente:', currentYear);
                console.log('üìä hasRealBalances:', hasRealBalances);
                console.log('üìä realBalances PRIMA del calcolo:', JSON.stringify(realBalances));
                
                for (const year of years) {
                    let totalEur = 0;
                    // Per anno corrente, usa saldi reali se disponibili
                    const balancesToUse = (year === currentYear && hasRealBalances) ? realBalances : yearEndSnapshots[year];
                    
                    if (year === currentYear) {
                        console.log(`üìä ${year} usando realBalances:`, JSON.stringify(balancesToUse));
                    }
                    
                    for (const [coin, amount] of Object.entries(balancesToUse || {})) {
                        if (amount > 0) {
                            // 1. Check se √® fiat
                            if (fiatRates[coin]) {
                                const eurVal = amount * fiatRates[coin];
                                totalEur += eurVal;
                                if (year === currentYear) console.log(`  üíµ ${coin}: ${amount} ‚Üí ‚Ç¨${eurVal.toFixed(2)}`);
                                continue;
                            }
                            
                            // 2. Usa getPriceEur (CryptoCompare ‚Üí CoinGecko ‚Üí cache)
                            let priceEur = getPriceEur(coin, year);
                            
                            // 3. Fallback: prezzo da transazioni
                            if (!priceEur && tokenPricesFromTx[coin]) {
                                priceEur = tokenPricesFromTx[coin];
                            }
                            
                            if (priceEur && priceEur > 0) {
                                const eurVal = amount * priceEur;
                                totalEur += eurVal;
                                if (year === currentYear) console.log(`  ü™ô ${coin}: ${amount} √ó ‚Ç¨${priceEur.toFixed(4)} ‚Üí ‚Ç¨${eurVal.toFixed(2)}`);
                            } else {
                                if (year === currentYear) console.log(`  ‚ùå ${coin}: ${amount} (nessun prezzo)`);
                            }
                        }
                    }
                    yearTotals[year] = Math.round(totalEur * 100) / 100;
                    console.log(`üìä ${year} totale: ‚Ç¨${yearTotals[year]}`);
                }
                
                console.log('üìä Bitpanda yearTotals:', yearTotals);
                console.log('üìä Bitpanda realBalances:', realBalances);
                
                // Se anno corrente ha saldi reali, copia per snapshot
                if (hasRealBalances) {
                    yearEndSnapshots[currentYear] = { ...realBalances };
                }
                
                // Salva
                exchangeData['bitpanda'] = {
                    transactions: allTransactions,
                    balances: yearEndSnapshots,
                    realBalances: hasRealBalances ? realBalances : null,
                    totals: yearTotals,
                    tokenPrices: tokenPricesFromTx, // Salva prezzi token per reload
                    transactionCount: allTransactions.length,
                    isManual: false,
                    lastImport: new Date().toISOString(),
                    source: 'api'
                };
                
                progressBar.style.width = '100%';
                const realMsg = hasRealBalances ? ` (con saldi reali!)` : '';
                progressText.textContent = `‚úÖ ${allTransactions.length} transazioni importate${realMsg}`;
                
                saveExchangeDataToFirebase();
                initExchangeGrid();
                updateExchangeTotals();
                
                // Messaggio finale
                let alertMsg = `‚úÖ Bitpanda importato!\n\nüìä ${allTransactions.length} transazioni`;
                if (hasRealBalances) {
                    alertMsg += `\n\nüíé SALDI REALI:`;
                    const topBalances = Object.entries(realBalances)
                        .filter(([_, amt]) => amt > 0)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 5);
                    for (const [coin, amt] of topBalances) {
                        alertMsg += `\n   ${coin}: ${typeof amt === 'number' ? amt.toFixed(amt < 1 ? 6 : 2) : amt}`;
                    }
                }
                
                setTimeout(() => {
                    closeBitpandaApiModal();
                    alert(alertMsg);
                    if (currentDetailExchange === 'bitpanda') {
                        openExchangeDetail('bitpanda');
                    }
                }, 1500);
                
            } catch (e) {
                console.error('Bitpanda API error:', e);
                progressBar.style.width = '0%';
                
                if (e.message.includes('Failed to fetch') || e.name === 'TypeError') {
                    progressText.textContent = '‚ùå CORS bloccato - serve proxy server';
                    alert('‚ö†Ô∏è Bitpanda blocca le richieste dal browser (CORS).\n\nServe un proxy server per usare l\'API.\n\nAlternativa: importa il CSV da Bitpanda.');
                } else {
                    progressText.textContent = '‚ùå ' + e.message;
                    alert('‚ùå Errore: ' + e.message);
                }
            }
        }
        
        // Helper: trova simbolo crypto da ID
        function findBitpandaCryptoSymbol(cryptoId, wallets) {
            if (!cryptoId || !wallets) return null;
            for (const wallet of wallets) {
                if (wallet.attributes?.cryptocoin_id === cryptoId) {
                    return wallet.attributes?.cryptocoin_symbol;
                }
            }
            // Mapping comune Bitpanda (cryptocoin_id ‚Üí symbol)
            const idMap = { 
                '1': 'BTC', '3': 'ETH', '5': 'LTC', '8': 'XRP', 
                '27': 'ADA', '28': 'DOT', '30': 'LINK', '34': 'UNI',
                '39': 'BEST', '130': 'VSN', // Bitpanda tokens
                '11': 'USDT', '42': 'USDC', '17': 'DOGE', '18': 'TRX',
                '22': 'XLM', '29': 'SOL', '31': 'AVAX', '32': 'MATIC'
            };
            return idMap[cryptoId] || null;
        }
        
        // Helper: estrai cursor da URL
        function extractCursor(url) {
            if (!url) return null;
            const match = url.match(/cursor=([^&]+)/);
            return match ? match[1] : null;
        }
        
        // ==================== AI ANALYSIS FUNCTIONS ====================
        
        function openAIAnalysisModal() {
            const exchId = currentDetailExchange;
            const data = exchangeData[exchId];
            
            if (!data || !data.transactions || data.transactions.length === 0) {
                alert('‚ö†Ô∏è Nessuna transazione da analizzare!\n\nImporta prima i dati CSV o tramite API.');
                return;
            }
            
            // Reset UI
            document.getElementById('aiApiKeySection').style.display = 'block';
            document.getElementById('aiResultsSection').style.display = 'none';
            document.getElementById('aiLoadingSection').style.display = 'none';
            document.getElementById('aiAnalyzeBtn').style.display = 'block';
            document.getElementById('aiAnalyzeBtn').onclick = runAIAnalysis; // Single exchange
            
            // Update modal title
            const modalTitle = document.querySelector('#aiAnalysisModal .modal-header h3');
            if (modalTitle) modalTitle.innerHTML = `ü§ñ Analisi AI - ${exchId.toUpperCase()}`;
            
            // Load saved API key
            const savedKey = localStorage.getItem('claudeApiKey') || '';
            document.getElementById('claudeApiKeyInput').value = savedKey;
            
            // Setup radio button listener for custom question
            document.querySelectorAll('input[name="aiAnalysisType"]').forEach(radio => {
                radio.addEventListener('change', function() {
                    document.getElementById('aiCustomQuestionSection').style.display = 
                        this.value === 'question' ? 'block' : 'none';
                });
            });
            
            document.getElementById('aiAnalysisModal').classList.add('active');
        }
        
        function closeAIAnalysisModal() {
            document.getElementById('aiAnalysisModal').classList.remove('active');
        }
        
        async function runAIAnalysis() {
            const apiKey = document.getElementById('claudeApiKeyInput').value.trim();
            if (!apiKey) {
                alert('‚ö†Ô∏è Inserisci la tua Claude API Key!\n\nOttienila da console.anthropic.com');
                return;
            }
            
            // Save API key
            localStorage.setItem('claudeApiKey', apiKey);
            
            const analysisType = document.querySelector('input[name="aiAnalysisType"]:checked').value;
            const customQuestion = document.getElementById('aiCustomQuestion')?.value || '';
            
            const exchId = currentDetailExchange;
            const data = exchangeData[exchId];
            
            // Show loading
            document.getElementById('aiApiKeySection').style.display = 'none';
            document.getElementById('aiLoadingSection').style.display = 'block';
            document.getElementById('aiAnalyzeBtn').style.display = 'none';
            
            try {
                // Prepare transaction data for Claude
                const txSummary = prepareTransactionsForAI(data.transactions, exchId);
                
                document.getElementById('aiLoadingDetail').textContent = 
                    `${data.transactions.length} transazioni preparate...`;
                
                // Build prompt based on analysis type
                const prompt = buildAIPrompt(analysisType, txSummary, customQuestion, exchId);
                
                // Call Claude API
                const response = await callClaudeAPI(apiKey, prompt);
                
                // Show results
                document.getElementById('aiLoadingSection').style.display = 'none';
                document.getElementById('aiResultsSection').style.display = 'block';
                document.getElementById('aiResultsContent').innerHTML = formatAIResponse(response);
                
            } catch (error) {
                document.getElementById('aiLoadingSection').style.display = 'none';
                document.getElementById('aiApiKeySection').style.display = 'block';
                document.getElementById('aiAnalyzeBtn').style.display = 'block';
                
                if (error.message.includes('401')) {
                    alert('‚ùå API Key non valida!\n\nVerifica la tua Claude API Key.');
                } else if (error.message.includes('429')) {
                    alert('‚ö†Ô∏è Rate limit raggiunto!\n\nRiprova tra qualche secondo.');
                } else {
                    alert('‚ùå Errore: ' + error.message);
                }
                console.error('AI Analysis error:', error);
            }
        }
        
        function prepareTransactionsForAI(transactions, exchId) {
            // Group by token
            const byToken = {};
            let totalBuys = 0, totalSells = 0, totalRewards = 0;
            
            for (const tx of transactions) {
                const coin = tx.coin;
                if (!byToken[coin]) {
                    byToken[coin] = {
                        bought: 0, boughtValue: 0,
                        sold: 0, soldValue: 0,
                        rewards: 0, rewardsValue: 0,
                        deposits: 0, withdrawals: 0,
                        balance: 0,
                        transactions: []
                    };
                }
                
                const t = byToken[coin];
                const value = tx.amountEur || 0;
                
                // Track transaction
                t.transactions.push({
                    date: tx.date instanceof Date ? tx.date.toISOString().slice(0,10) : tx.date,
                    type: tx.type,
                    amount: tx.amount,
                    value: value,
                    price: tx.priceEur || (value / tx.amount) || 0
                });
                
                // Aggregate
                switch(tx.type) {
                    case 'buy':
                        t.bought += tx.amount;
                        t.boughtValue += value;
                        t.balance += tx.amount;
                        totalBuys += value;
                        break;
                    case 'sell':
                        t.sold += tx.amount;
                        t.soldValue += value;
                        t.balance -= tx.amount;
                        totalSells += value;
                        break;
                    case 'reward':
                    case 'staking':
                        t.rewards += tx.amount;
                        t.rewardsValue += value;
                        t.balance += tx.amount;
                        totalRewards += value;
                        break;
                    case 'deposit':
                        t.deposits += tx.amount;
                        t.balance += tx.amount;
                        break;
                    case 'withdrawal':
                        t.withdrawals += tx.amount;
                        t.balance -= tx.amount;
                        break;
                }
            }
            
            // Find anomalies
            const anomalies = [];
            for (const tx of transactions) {
                // Stablecoin with wrong price
                if (['USDT','USDC','BUSD','DAI'].includes(tx.coin) && tx.priceEur > 2) {
                    anomalies.push({
                        date: tx.date,
                        coin: tx.coin,
                        issue: `Prezzo stablecoin anomalo: ‚Ç¨${tx.priceEur?.toFixed(2)}`
                    });
                }
                // Negative balance (shouldn't happen)
                if (byToken[tx.coin]?.balance < -0.001) {
                    anomalies.push({
                        coin: tx.coin,
                        issue: `Saldo negativo: ${byToken[tx.coin].balance.toFixed(4)}`
                    });
                }
            }
            
            return {
                exchange: exchId,
                totalTransactions: transactions.length,
                dateRange: {
                    from: transactions[0]?.date,
                    to: transactions[transactions.length - 1]?.date
                },
                summary: {
                    totalBuys: totalBuys.toFixed(2),
                    totalSells: totalSells.toFixed(2),
                    totalRewards: totalRewards.toFixed(2),
                    netFlow: (totalSells - totalBuys + totalRewards).toFixed(2)
                },
                tokens: Object.fromEntries(
                    Object.entries(byToken)
                        .filter(([_, v]) => Math.abs(v.balance) > 0.0001 || v.boughtValue > 1)
                        .map(([k, v]) => [k, {
                            balance: v.balance.toFixed(4),
                            bought: v.bought.toFixed(4),
                            boughtValue: v.boughtValue.toFixed(2),
                            sold: v.sold.toFixed(4),
                            soldValue: v.soldValue.toFixed(2),
                            rewards: v.rewards.toFixed(4),
                            rewardsValue: v.rewardsValue.toFixed(2),
                            avgBuyPrice: v.bought > 0 ? (v.boughtValue / v.bought).toFixed(4) : '0',
                            txCount: v.transactions.length
                        }])
                ),
                anomalies: anomalies.slice(0, 10) // Max 10 anomalies
            };
        }
        
        function buildAIPrompt(type, txSummary, customQuestion, exchId) {
            const baseContext = `
Sei un assistente fiscale crypto esperto in normativa italiana. Analizza questi dati dell'exchange ${exchId.toUpperCase()}.

DATI TRANSAZIONI:
${JSON.stringify(txSummary, null, 2)}

NOTA: I prezzi sono in EUR. Per le tasse italiane conta il valore al 31/12.
`;
            
            if (type === 'quick') {
                return baseContext + `
ANALISI RICHIESTA (rapida):
1. üö® ANOMALIE: Elenca eventuali problemi nei dati (prezzi anomali, saldi negativi, etc.)
2. üìä RIEPILOGO: Totale acquisti, vendite, rewards in formato tabella
3. üí° SUGGERIMENTI: 1-2 consigli basati sui dati

Rispondi in italiano, usa emoji, sii conciso.`;
            }
            
            if (type === 'full') {
                return baseContext + `
ANALISI RICHIESTA (completa):
1. üö® ANOMALIE: Tutti i problemi rilevati nei dati
2. üìä RIEPILOGO PER TOKEN: Per ogni token con valore > ‚Ç¨1:
   - Quantit√† posseduta
   - Costo medio di acquisto
   - Valore rewards ricevuti
   - P&L stimato (se ha venduto)
3. üìã REPORT FISCALE:
   - Valore portfolio stimato
   - Plusvalenze realizzate (vendite)
   - Rewards tassabili
   - Note per Quadro RW
4. üí° SUGGERIMENTI: Azioni consigliate per ottimizzazione fiscale

Rispondi in italiano, usa emoji e tabelle dove utile.`;
            }
            
            if (type === 'question') {
                return baseContext + `
DOMANDA UTENTE:
${customQuestion}

Rispondi in italiano, in modo chiaro e dettagliato. Usa i dati forniti per rispondere.`;
            }
            
            return baseContext;
        }
        
        async function callClaudeAPI(apiKey, prompt) {
            const response = await fetch('https://api.anthropic.com/v1/messages', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-api-key': apiKey,
                    'anthropic-version': '2023-06-01',
                    'anthropic-dangerous-direct-browser-access': 'true'
                },
                body: JSON.stringify({
                    model: 'claude-sonnet-4-20250514',
                    max_tokens: 2000,
                    messages: [{
                        role: 'user',
                        content: prompt
                    }]
                })
            });
            
            if (!response.ok) {
                const error = await response.json().catch(() => ({}));
                throw new Error(error.error?.message || `HTTP ${response.status}`);
            }
            
            const data = await response.json();
            return data.content[0].text;
        }
        
        function formatAIResponse(text) {
            // Convert markdown-style formatting to HTML
            return text
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\n\n/g, '<br><br>')
                .replace(/\n/g, '<br>')
                .replace(/#{1,3}\s?(.*?)(<br>|$)/g, '<strong style="font-size:1.1em;">$1</strong>$2')
                .replace(/`([^`]+)`/g, '<code style="background:var(--bg-secondary);padding:2px 6px;border-radius:4px;">$1</code>');
        }
        
        // ==================== END AI ANALYSIS ====================
        
        // ==================== GLOBAL AI ANALYSIS ====================
        
        function openGlobalAIAnalysis() {
            // Raccogli tutti i dati
            let totalTransactions = 0;
            let hasData = false;
            
            // Check exchanges
            for (const exchId of Object.keys(exchangeData)) {
                if (exchangeData[exchId].transactions?.length > 0) {
                    totalTransactions += exchangeData[exchId].transactions.length;
                    hasData = true;
                }
            }
            
            // Check wallets
            const hasWallets = walletData && walletData.results && walletData.results.length > 0;
            
            if (!hasData && !hasWallets) {
                alert('‚ö†Ô∏è Nessun dato da analizzare!\n\nImporta prima i dati da Exchange o scansiona i Wallet.');
                return;
            }
            
            // Reset UI
            document.getElementById('aiApiKeySection').style.display = 'block';
            document.getElementById('aiResultsSection').style.display = 'none';
            document.getElementById('aiLoadingSection').style.display = 'none';
            document.getElementById('aiAnalyzeBtn').style.display = 'block';
            document.getElementById('aiAnalyzeBtn').onclick = runGlobalAIAnalysis;
            
            // Load saved API key
            const savedKey = localStorage.getItem('claudeApiKey') || '';
            document.getElementById('claudeApiKeyInput').value = savedKey;
            
            // Update modal title
            const modalTitle = document.querySelector('#aiAnalysisModal .modal-header h3');
            if (modalTitle) modalTitle.innerHTML = 'ü§ñ Analisi AI Portfolio COMPLETO';
            
            // Setup radio button listener
            document.querySelectorAll('input[name="aiAnalysisType"]').forEach(radio => {
                radio.addEventListener('change', function() {
                    document.getElementById('aiCustomQuestionSection').style.display = 
                        this.value === 'question' ? 'block' : 'none';
                });
            });
            
            document.getElementById('aiAnalysisModal').classList.add('active');
        }
        
        async function runGlobalAIAnalysis() {
            const apiKey = document.getElementById('claudeApiKeyInput').value.trim();
            if (!apiKey) {
                alert('‚ö†Ô∏è Inserisci la tua Claude API Key!');
                return;
            }
            
            localStorage.setItem('claudeApiKey', apiKey);
            
            const analysisType = document.querySelector('input[name="aiAnalysisType"]:checked').value;
            const customQuestion = document.getElementById('aiCustomQuestion')?.value || '';
            
            // Show loading
            document.getElementById('aiApiKeySection').style.display = 'none';
            document.getElementById('aiLoadingSection').style.display = 'block';
            document.getElementById('aiAnalyzeBtn').style.display = 'none';
            
            try {
                // Prepare ALL data
                const globalData = prepareGlobalDataForAI();
                
                document.getElementById('aiLoadingDetail').textContent = 
                    `${globalData.totalTransactions} transazioni da ${globalData.exchangeCount} exchange + ${globalData.walletCount} wallet...`;
                
                // Build prompt
                const prompt = buildGlobalAIPrompt(analysisType, globalData, customQuestion);
                
                // Call Claude API
                const response = await callClaudeAPI(apiKey, prompt);
                
                // Show results
                document.getElementById('aiLoadingSection').style.display = 'none';
                document.getElementById('aiResultsSection').style.display = 'block';
                document.getElementById('aiResultsContent').innerHTML = formatAIResponse(response);
                
            } catch (error) {
                document.getElementById('aiLoadingSection').style.display = 'none';
                document.getElementById('aiApiKeySection').style.display = 'block';
                document.getElementById('aiAnalyzeBtn').style.display = 'block';
                
                if (error.message.includes('401')) {
                    alert('‚ùå API Key non valida!');
                } else if (error.message.includes('429')) {
                    alert('‚ö†Ô∏è Rate limit! Riprova tra qualche secondo.');
                } else {
                    alert('‚ùå Errore: ' + error.message);
                }
                console.error('Global AI Analysis error:', error);
            }
        }
        
        function prepareGlobalDataForAI() {
            const result = {
                totalTransactions: 0,
                exchangeCount: 0,
                walletCount: 0,
                exchanges: {},
                wallets: {},
                portfolioTotals: {
                    '2024': { exchanges: 0, wallets: 0, total: 0 },
                    '2025': { exchanges: 0, wallets: 0, total: 0 }
                },
                allTokens: {},
                anomalies: []
            };
            
            // Process exchanges
            for (const exchId of Object.keys(exchangeData)) {
                const data = exchangeData[exchId];
                if (!data.transactions || data.transactions.length === 0) continue;
                
                result.exchangeCount++;
                result.totalTransactions += data.transactions.length;
                
                // Get exchange summary
                const summary = prepareTransactionsForAI(data.transactions, exchId);
                result.exchanges[exchId] = {
                    transactions: summary.totalTransactions,
                    summary: summary.summary,
                    tokens: summary.tokens,
                    totals: data.totals || {}
                };
                
                // Add to portfolio totals
                if (data.totals) {
                    result.portfolioTotals['2024'].exchanges += data.totals[2024] || 0;
                    result.portfolioTotals['2025'].exchanges += data.totals[2025] || 0;
                }
                
                // Merge tokens
                for (const [token, info] of Object.entries(summary.tokens)) {
                    if (!result.allTokens[token]) {
                        result.allTokens[token] = { exchanges: {}, totalBalance: 0, totalValue: 0 };
                    }
                    result.allTokens[token].exchanges[exchId] = info;
                    result.allTokens[token].totalBalance += parseFloat(info.balance) || 0;
                }
                
                // Add anomalies
                result.anomalies.push(...summary.anomalies.map(a => ({ ...a, source: exchId })));
            }
            
            // Process wallets
            if (walletData && walletData.results) {
                for (const wallet of walletData.results) {
                    result.walletCount++;
                    
                    const addr = wallet.address?.substring(0, 10) + '...';
                    result.wallets[addr] = {
                        chain: wallet.chain,
                        valueUSD: wallet.valueUSD || 0,
                        tokens: wallet.tokens?.length || 0
                    };
                    
                    // Add to portfolio totals (current value)
                    result.portfolioTotals['2025'].wallets += (wallet.valueUSD || 0) * EUR_USD;
                }
            }
            
            // Calculate totals
            result.portfolioTotals['2024'].total = 
                result.portfolioTotals['2024'].exchanges + result.portfolioTotals['2024'].wallets;
            result.portfolioTotals['2025'].total = 
                result.portfolioTotals['2025'].exchanges + result.portfolioTotals['2025'].wallets;
            
            return result;
        }
        
        function buildGlobalAIPrompt(type, data, customQuestion) {
            const baseContext = `
Sei un consulente fiscale crypto esperto in normativa italiana. Analizza il PORTFOLIO COMPLETO di questo utente.

üìä PANORAMICA PORTFOLIO:
- Exchange attivi: ${data.exchangeCount} (${Object.keys(data.exchanges).join(', ')})
- Wallet: ${data.walletCount}
- Transazioni totali: ${data.totalTransactions}

üí∞ VALORI PORTFOLIO:
- 31/12/2024: ‚Ç¨${data.portfolioTotals['2024'].total.toFixed(2)} (Exchange: ‚Ç¨${data.portfolioTotals['2024'].exchanges.toFixed(2)}, Wallet: ‚Ç¨${data.portfolioTotals['2024'].wallets.toFixed(2)})
- 31/12/2025: ‚Ç¨${data.portfolioTotals['2025'].total.toFixed(2)} (Exchange: ‚Ç¨${data.portfolioTotals['2025'].exchanges.toFixed(2)}, Wallet: ‚Ç¨${data.portfolioTotals['2025'].wallets.toFixed(2)})

üìà DATI PER EXCHANGE:
${JSON.stringify(data.exchanges, null, 2)}

üîó WALLET:
${JSON.stringify(data.wallets, null, 2)}

üö® ANOMALIE RILEVATE:
${JSON.stringify(data.anomalies.slice(0, 15), null, 2)}

NOTA: Prezzi in EUR. Per tasse italiane conta valore al 31/12. Soglia Quadro RW = ‚Ç¨15.000.
`;
            
            if (type === 'quick') {
                return baseContext + `
ANALISI RICHIESTA (rapida):
1. üö® ANOMALIE: Problemi critici da risolvere
2. üìä RIEPILOGO: Totali per exchange, valore portfolio
3. üìã QUADRO RW: Devo compilarlo? (soglia ‚Ç¨15.000)
4. üí° AZIONI URGENTI: Cosa fare subito

Rispondi in italiano, usa emoji, sii conciso ma completo.`;
            }
            
            if (type === 'full') {
                return baseContext + `
ANALISI RICHIESTA (completa):

1. üö® ANOMALIE CRITICHE
   - Tutti i problemi nei dati
   - Priorit√† di risoluzione

2. üìä RIEPILOGO PER EXCHANGE
   - Valore al 31/12/2024 e 31/12/2025
   - Transazioni e operativit√†
   - Token principali

3. üìã REPORT FISCALE COMPLETO
   a) QUADRO RW (Monitoraggio):
      - Obbligo compilazione? (soglia ‚Ç¨15.000)
      - Valore da dichiarare per ogni exchange/wallet
      - IVAFE dovuta (0,2%)
   
   b) PLUSVALENZE/MINUSVALENZE:
      - Gains realizzati
      - Perdite compensabili
      - Tassazione 26%
   
   c) ALTRI REDDITI:
      - Rewards staking (tassabili)
      - Airdrop (valore al momento ricezione)

4. üí∞ CALCOLO TASSE STIMATO
   - IVAFE
   - Imposta plusvalenze
   - Tasse su rewards
   - TOTALE DOVUTO

5. üí° OTTIMIZZAZIONE FISCALE
   - Strategie per ridurre il carico fiscale
   - Scadenze importanti
   - Documenti da conservare

Rispondi in italiano con tabelle dove utile. Sii dettagliato e preciso.`;
            }
            
            if (type === 'question') {
                return baseContext + `
DOMANDA UTENTE:
${customQuestion}

Rispondi in italiano in modo chiaro e dettagliato usando tutti i dati del portfolio.`;
            }
            
            return baseContext;
        }
        
        // ==================== END GLOBAL AI ANALYSIS ====================
        
        // ==================== QUADRO RW GENERATOR ====================
        
        let generatedQuadriRW = {}; // { 2024: { data, html }, 2025: { data, html }, ... }
        
        function generateQuadroRW() {
            const year = parseInt(document.getElementById('rwYearSelect').value);
            
            // Raccogli tutti i dati per l'anno
            const rwData = collectDataForYear(year);
            
            if (rwData.totalValue === 0) {
                alert(`‚ö†Ô∏è Nessun dato trovato per l'anno ${year}.\n\nAssicurati di aver importato le transazioni e calcolato i totali.`);
                return;
            }
            
            // Genera HTML del report
            const html = renderQuadroRW(year, rwData);
            
            // Salva nello storico
            generatedQuadriRW[year] = {
                data: rwData,
                html: html,
                generatedAt: new Date().toISOString()
            };
            saveQuadriRWHistory();
            
            // Mostra
            document.getElementById('quadroRWContainer').style.display = 'block';
            document.getElementById('quadroRWTitle').textContent = `üìÑ Quadro RW - Anno ${year}`;
            document.getElementById('quadroRWContent').innerHTML = html;
            
            // Aggiorna storico
            updateRWHistoryList();
        }
        
        function collectDataForYear(year) {
            const data = {
                year: year,
                exchanges: [],
                wallets: [],
                totalExchanges: 0,
                totalWallets: 0,
                totalValue: 0,
                ivafe: 0,
                needsRW: false,
                details: []
            };
            
            // Raccogli dati exchange
            for (const [exchId, exchData] of Object.entries(exchangeData)) {
                const value = exchData.totals?.[year] || 0;
                if (value > 0) {
                    data.exchanges.push({
                        name: exchId.charAt(0).toUpperCase() + exchId.slice(1),
                        id: exchId,
                        value: value,
                        country: getExchangeCountry(exchId),
                        transactions: exchData.transactions?.filter(tx => {
                            const txYear = tx.date instanceof Date ? tx.date.getFullYear() : new Date(tx.date).getFullYear();
                            return txYear === year;
                        }).length || 0
                    });
                    data.totalExchanges += value;
                }
            }
            
            // Valore manuale exchange se presente
            const manualExchange = parseFloat(document.getElementById(`exchange${year}`)?.value) || 0;
            if (manualExchange > 0 && data.totalExchanges === 0) {
                data.exchanges.push({
                    name: 'Altri Exchange (manuale)',
                    id: 'manual',
                    value: manualExchange,
                    country: '-'
                });
                data.totalExchanges = manualExchange;
            }
            
            // Raccogli dati wallet (usa taxReportData se disponibile)
            if (taxReportData && taxReportData.grandTotals && taxReportData.grandTotals[year]) {
                data.totalWallets = taxReportData.grandTotals[year].eur || 0;
                
                // Dettaglio per wallet se disponibile
                if (taxReportData.walletDetails) {
                    const chainTotals = {};
                    for (const wd of taxReportData.walletDetails) {
                        if (wd.totals && wd.totals[year]) {
                            const chain = wd.wallet?.chain || 'Unknown';
                            if (!chainTotals[chain]) {
                                chainTotals[chain] = { value: 0, addresses: 0 };
                            }
                            chainTotals[chain].value += wd.totals[year].eur || 0;
                            chainTotals[chain].addresses++;
                        }
                    }
                    for (const [chain, info] of Object.entries(chainTotals)) {
                        if (info.value > 0) {
                            data.wallets.push({
                                chain: chain,
                                value: info.value,
                                addresses: info.addresses
                            });
                        }
                    }
                }
            }
            
            // Totale
            data.totalValue = data.totalExchanges + data.totalWallets;
            
            // IVAFE (0.2% = 2 per mille)
            data.ivafe = data.totalValue * 0.002;
            
            // Soglia RW
            data.needsRW = data.totalValue >= 15000;
            
            return data;
        }
        
        function getExchangeCountry(exchId) {
            const countries = {
                'binance': 'Malta/Seychelles',
                'bitpanda': 'Austria',
                'bitget': 'Seychelles',
                'coinbase': 'USA',
                'kraken': 'USA',
                'crypto.com': 'Singapore',
                'bybit': 'Dubai'
            };
            return countries[exchId.toLowerCase()] || 'Estero';
        }
        
        function renderQuadroRW(year, data) {
            const needsRWClass = data.needsRW ? 'color:var(--red);' : 'color:var(--green);';
            const needsRWText = data.needsRW ? '‚ö†Ô∏è S√å - Obbligo dichiarazione' : '‚úÖ NO - Sotto soglia ‚Ç¨15.000';
            
            let html = `
            <div style="font-family:Arial,sans-serif;">
                <!-- INTESTAZIONE -->
                <div style="background:linear-gradient(135deg,#1a1a2e 0%,#16213e 100%);color:#fff;padding:20px;border-radius:12px;margin-bottom:20px;">
                    <div style="display:flex;justify-content:space-between;align-items:center;">
                        <div>
                            <h2 style="margin:0;font-size:24px;">QUADRO RW - Anno ${year}</h2>
                            <p style="margin:8px 0 0;opacity:0.8;">Monitoraggio Attivit√† Finanziarie Estere</p>
                        </div>
                        <div style="text-align:right;">
                            <div style="font-size:32px;font-weight:bold;">‚Ç¨${data.totalValue.toLocaleString('it-IT', {minimumFractionDigits: 2})}</div>
                            <div style="font-size:12px;opacity:0.8;">Valore al 31/12/${year}</div>
                        </div>
                    </div>
                </div>
                
                <!-- OBBLIGO RW -->
                <div style="background:var(--bg-secondary);padding:16px;border-radius:8px;margin-bottom:20px;border-left:4px solid ${data.needsRW ? 'var(--red)' : 'var(--green)'};">
                    <strong>Obbligo Quadro RW:</strong> <span style="${needsRWClass}font-weight:bold;">${needsRWText}</span>
                    <div style="font-size:12px;color:var(--text-secondary);margin-top:4px;">
                        Soglia: ‚Ç¨15.000 | Il tuo valore: ‚Ç¨${data.totalValue.toLocaleString('it-IT', {minimumFractionDigits: 2})}
                    </div>
                </div>
                
                <!-- RIEPILOGO -->
                <table style="width:100%;border-collapse:collapse;margin-bottom:20px;">
                    <tr style="background:var(--bg-primary);">
                        <th style="padding:12px;text-align:left;border-bottom:2px solid var(--border);">Categoria</th>
                        <th style="padding:12px;text-align:right;border-bottom:2px solid var(--border);">Valore ‚Ç¨</th>
                        <th style="padding:12px;text-align:right;border-bottom:2px solid var(--border);">%</th>
                    </tr>
                    <tr>
                        <td style="padding:10px;border-bottom:1px solid var(--border);">üè¶ Exchange</td>
                        <td style="padding:10px;text-align:right;border-bottom:1px solid var(--border);font-weight:bold;">‚Ç¨${data.totalExchanges.toLocaleString('it-IT', {minimumFractionDigits: 2})}</td>
                        <td style="padding:10px;text-align:right;border-bottom:1px solid var(--border);">${data.totalValue > 0 ? ((data.totalExchanges / data.totalValue) * 100).toFixed(1) : 0}%</td>
                    </tr>
                    <tr>
                        <td style="padding:10px;border-bottom:1px solid var(--border);">üîó Wallet DeFi</td>
                        <td style="padding:10px;text-align:right;border-bottom:1px solid var(--border);font-weight:bold;">‚Ç¨${data.totalWallets.toLocaleString('it-IT', {minimumFractionDigits: 2})}</td>
                        <td style="padding:10px;text-align:right;border-bottom:1px solid var(--border);">${data.totalValue > 0 ? ((data.totalWallets / data.totalValue) * 100).toFixed(1) : 0}%</td>
                    </tr>
                    <tr style="background:var(--bg-primary);font-weight:bold;">
                        <td style="padding:12px;">üìä TOTALE</td>
                        <td style="padding:12px;text-align:right;color:var(--green);font-size:18px;">‚Ç¨${data.totalValue.toLocaleString('it-IT', {minimumFractionDigits: 2})}</td>
                        <td style="padding:12px;text-align:right;">100%</td>
                    </tr>
                </table>
                
                <!-- DETTAGLIO EXCHANGE -->
                ${data.exchanges.length > 0 ? `
                <h3 style="margin:20px 0 12px;">üè¶ Dettaglio Exchange</h3>
                <table style="width:100%;border-collapse:collapse;margin-bottom:20px;">
                    <tr style="background:var(--bg-primary);">
                        <th style="padding:10px;text-align:left;border-bottom:1px solid var(--border);">Exchange</th>
                        <th style="padding:10px;text-align:left;border-bottom:1px solid var(--border);">Paese</th>
                        <th style="padding:10px;text-align:right;border-bottom:1px solid var(--border);">Transazioni</th>
                        <th style="padding:10px;text-align:right;border-bottom:1px solid var(--border);">Valore 31/12</th>
                    </tr>
                    ${data.exchanges.map(e => `
                    <tr>
                        <td style="padding:10px;border-bottom:1px solid var(--border);">${e.name}</td>
                        <td style="padding:10px;border-bottom:1px solid var(--border);color:var(--text-secondary);">${e.country}</td>
                        <td style="padding:10px;text-align:right;border-bottom:1px solid var(--border);">${e.transactions || '-'}</td>
                        <td style="padding:10px;text-align:right;border-bottom:1px solid var(--border);font-weight:bold;">‚Ç¨${e.value.toLocaleString('it-IT', {minimumFractionDigits: 2})}</td>
                    </tr>
                    `).join('')}
                </table>
                ` : ''}
                
                <!-- DETTAGLIO WALLET -->
                ${data.wallets.length > 0 ? `
                <h3 style="margin:20px 0 12px;">üîó Dettaglio Wallet</h3>
                <table style="width:100%;border-collapse:collapse;margin-bottom:20px;">
                    <tr style="background:var(--bg-primary);">
                        <th style="padding:10px;text-align:left;border-bottom:1px solid var(--border);">Blockchain</th>
                        <th style="padding:10px;text-align:right;border-bottom:1px solid var(--border);">Indirizzi</th>
                        <th style="padding:10px;text-align:right;border-bottom:1px solid var(--border);">Valore 31/12</th>
                    </tr>
                    ${data.wallets.map(w => `
                    <tr>
                        <td style="padding:10px;border-bottom:1px solid var(--border);">${w.chain}</td>
                        <td style="padding:10px;text-align:right;border-bottom:1px solid var(--border);">${w.addresses}</td>
                        <td style="padding:10px;text-align:right;border-bottom:1px solid var(--border);font-weight:bold;">‚Ç¨${w.value.toLocaleString('it-IT', {minimumFractionDigits: 2})}</td>
                    </tr>
                    `).join('')}
                </table>
                ` : ''}
                
                <!-- IVAFE -->
                <div style="background:var(--bg-secondary);padding:16px;border-radius:8px;margin-bottom:20px;">
                    <h3 style="margin:0 0 12px;">üí∞ IVAFE Dovuta</h3>
                    <div style="display:flex;justify-content:space-between;align-items:center;">
                        <div>
                            <div style="color:var(--text-secondary);font-size:13px;">Imposta 0,2% sul valore al 31/12</div>
                            <div style="font-size:12px;color:var(--text-secondary);margin-top:4px;">
                                ‚Ç¨${data.totalValue.toLocaleString('it-IT')} √ó 0,2% = ‚Ç¨${data.ivafe.toFixed(2)}
                            </div>
                        </div>
                        <div style="font-size:28px;font-weight:bold;color:var(--yellow);">
                            ‚Ç¨${data.ivafe.toFixed(2)}
                        </div>
                    </div>
                </div>
                
                <!-- NOTE -->
                <div style="background:var(--bg-primary);padding:16px;border-radius:8px;font-size:12px;color:var(--text-secondary);">
                    <strong>üìå Note importanti:</strong>
                    <ul style="margin:8px 0 0;padding-left:20px;">
                        <li>Questi dati sono indicativi e vanno verificati con la documentazione ufficiale</li>
                        <li>Il Quadro RW va compilato se il valore supera ‚Ç¨15.000 anche per un solo giorno</li>
                        <li>L'IVAFE si calcola sul valore medio annuo (qui mostrato valore al 31/12)</li>
                        <li>Conserva tutti gli estratti conto degli exchange e le ricevute delle transazioni</li>
                    </ul>
                </div>
                
                <!-- FOOTER -->
                <div style="text-align:center;margin-top:20px;padding-top:16px;border-top:1px solid var(--border);font-size:11px;color:var(--text-secondary);">
                    Report generato da CryptoFolio il ${new Date().toLocaleDateString('it-IT')} alle ${new Date().toLocaleTimeString('it-IT')}
                </div>
            </div>
            `;
            
            return html;
        }
        
        async function generateQuadroRWWithAI() {
            const apiKey = localStorage.getItem('claudeApiKey');
            if (!apiKey) {
                alert('‚ö†Ô∏è Inserisci prima la Claude API Key!\n\nClicca su "ü§ñ Analisi AI Completa" per configurarla.');
                return;
            }
            
            const year = parseInt(document.getElementById('rwYearSelect').value);
            const rwData = collectDataForYear(year);
            
            if (rwData.totalValue === 0) {
                alert(`‚ö†Ô∏è Nessun dato trovato per l'anno ${year}.`);
                return;
            }
            
            // Show loading
            document.getElementById('quadroRWContainer').style.display = 'block';
            document.getElementById('quadroRWTitle').textContent = `üìÑ Quadro RW - Anno ${year} (Generazione AI...)`;
            document.getElementById('quadroRWContent').innerHTML = `
                <div style="text-align:center;padding:40px;">
                    <div style="font-size:48px;animation:pulse 1.5s infinite;">ü§ñ</div>
                    <div style="margin-top:16px;color:var(--text-secondary);">Claude sta preparando il Quadro RW ${year}...</div>
                </div>
            `;
            
            try {
                const prompt = `
Sei un commercialista esperto in criptovalute e normativa fiscale italiana.
Genera un QUADRO RW completo e dettagliato per l'anno ${year} basandoti su questi dati:

DATI PORTFOLIO AL 31/12/${year}:
${JSON.stringify(rwData, null, 2)}

GENERA UN REPORT CHE INCLUDA:

1. üìã INTESTAZIONE
   - Anno fiscale
   - Totale patrimonio estero
   - Obbligo dichiarazione (soglia ‚Ç¨15.000)

2. üè¶ SEZIONE RW - EXCHANGE
   Per ogni exchange:
   - Codice paese (secondo codice ISO)
   - Codice investimento (14 per cripto)
   - Valore iniziale (01/01)
   - Valore finale (31/12)
   - Giorni di detenzione (365 o meno se aperto in corso d'anno)

3. üîó SEZIONE RW - WALLET DEFI
   - Tipo: Wallet non custodial
   - Valore aggregato per blockchain

4. üí∞ CALCOLO IVAFE
   - Base imponibile
   - Aliquota 0,2%
   - Imposta dovuta
   - Codice tributo per F24

5. ‚ö†Ô∏è ADEMPIMENTI RICHIESTI
   - Scadenze
   - Documenti da conservare
   - Sanzioni per omissione

6. üí° SUGGERIMENTI
   - Ottimizzazione fiscale
   - Errori comuni da evitare

Formatta il report in modo chiaro e professionale, usa tabelle dove utile.
Rispondi in italiano.`;

                const response = await callClaudeAPI(apiKey, prompt);
                
                // Mostra risultato AI + report standard
                const standardHtml = renderQuadroRW(year, rwData);
                const aiHtml = `
                    <div style="background:linear-gradient(135deg,#667eea22 0%,#764ba222 100%);padding:20px;border-radius:12px;margin-bottom:20px;border:1px solid #667eea;">
                        <h3 style="margin:0 0 16px;display:flex;align-items:center;gap:8px;">
                            <span style="font-size:24px;">ü§ñ</span> Report Generato da Claude AI
                        </h3>
                        <div style="white-space:pre-wrap;line-height:1.6;">
                            ${formatAIResponse(response)}
                        </div>
                    </div>
                    <hr style="border:none;border-top:2px dashed var(--border);margin:30px 0;">
                    <h3 style="margin-bottom:16px;">üìä Dati Calcolati da CryptoFolio</h3>
                    ${standardHtml}
                `;
                
                document.getElementById('quadroRWTitle').textContent = `üìÑ Quadro RW - Anno ${year}`;
                document.getElementById('quadroRWContent').innerHTML = aiHtml;
                
                // Salva
                generatedQuadriRW[year] = {
                    data: rwData,
                    html: aiHtml,
                    aiGenerated: true,
                    generatedAt: new Date().toISOString()
                };
                saveQuadriRWHistory();
                updateRWHistoryList();
                
            } catch (error) {
                console.error('AI generation error:', error);
                alert('‚ùå Errore generazione AI: ' + error.message);
                // Fallback a report standard
                generateQuadroRW();
            }
        }
        
        function printQuadroRW() {
            const year = document.getElementById('rwYearSelect').value;
            const content = document.getElementById('quadroRWContent').innerHTML;
            
            if (!content || content.includes('empty-state')) {
                alert('‚ö†Ô∏è Genera prima il Quadro RW!');
                return;
            }
            
            const printWindow = window.open('', '_blank');
            printWindow.document.write(`
                <!DOCTYPE html>
                <html>
                <head>
                    <title>Quadro RW ${year} - CryptoFolio</title>
                    <style>
                        body { font-family: Arial, sans-serif; padding: 20px; max-width: 800px; margin: 0 auto; }
                        table { width: 100%; border-collapse: collapse; }
                        th, td { padding: 8px; border: 1px solid #ddd; }
                        th { background: #f5f5f5; }
                        @media print { body { padding: 0; } }
                    </style>
                </head>
                <body>
                    <h1 style="text-align:center;">üìã QUADRO RW - Anno ${year}</h1>
                    <p style="text-align:center;color:#666;">Generato da CryptoFolio - ${new Date().toLocaleDateString('it-IT')}</p>
                    <hr>
                    ${content}
                </body>
                </html>
            `);
            printWindow.document.close();
            printWindow.print();
        }
        
        function exportQuadroRWCSV() {
            const year = document.getElementById('rwYearSelect').value;
            const data = generatedQuadriRW[year]?.data;
            
            if (!data) {
                alert('‚ö†Ô∏è Genera prima il Quadro RW!');
                return;
            }
            
            let csv = 'Tipo,Nome,Paese,Valore EUR,Note\n';
            
            for (const e of data.exchanges) {
                csv += `Exchange,${e.name},${e.country},${e.value.toFixed(2)},${e.transactions || 0} transazioni\n`;
            }
            for (const w of data.wallets) {
                csv += `Wallet,${w.chain},-,${w.value.toFixed(2)},${w.addresses} indirizzi\n`;
            }
            csv += `TOTALE,-,-,${data.totalValue.toFixed(2)},-\n`;
            csv += `IVAFE,-,-,${data.ivafe.toFixed(2)},0.2%\n`;
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `QuadroRW_${year}.csv`;
            a.click();
        }
        
        function copyQuadroRW() {
            const content = document.getElementById('quadroRWContent');
            if (!content) return;
            
            // Copia testo
            const text = content.innerText;
            navigator.clipboard.writeText(text).then(() => {
                alert('‚úÖ Quadro RW copiato negli appunti!');
            }).catch(err => {
                console.error('Copy failed:', err);
            });
        }
        
        function updateRWHistoryList() {
            const container = document.getElementById('rwHistoryList');
            const years = Object.keys(generatedQuadriRW).sort((a, b) => b - a);
            
            if (years.length === 0) {
                container.innerHTML = `
                    <div class="empty-state" style="padding:20px;">
                        <div style="color:var(--text-secondary);">Nessun Quadro RW generato ancora.</div>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = years.map(year => {
                const rw = generatedQuadriRW[year];
                const date = new Date(rw.generatedAt).toLocaleDateString('it-IT');
                const value = rw.data?.totalValue || 0;
                const aiLabel = rw.aiGenerated ? 'ü§ñ' : 'üìä';
                
                return `
                <div style="display:flex;justify-content:space-between;align-items:center;padding:12px;background:var(--bg-primary);border-radius:8px;margin-bottom:8px;">
                    <div>
                        <strong>${aiLabel} Anno ${year}</strong>
                        <div style="font-size:12px;color:var(--text-secondary);">Generato il ${date}</div>
                    </div>
                    <div style="display:flex;align-items:center;gap:12px;">
                        <span style="font-weight:bold;color:var(--green);">‚Ç¨${value.toLocaleString('it-IT', {minimumFractionDigits: 2})}</span>
                        <button class="btn btn-secondary" onclick="loadQuadroRW(${year})" style="padding:4px 12px;font-size:12px;">üëÅÔ∏è Visualizza</button>
                    </div>
                </div>
                `;
            }).join('');
        }
        
        function loadQuadroRW(year) {
            const rw = generatedQuadriRW[year];
            if (!rw) return;
            
            document.getElementById('rwYearSelect').value = year;
            document.getElementById('quadroRWContainer').style.display = 'block';
            document.getElementById('quadroRWTitle').textContent = `üìÑ Quadro RW - Anno ${year}`;
            document.getElementById('quadroRWContent').innerHTML = rw.html;
        }
        
        function saveQuadriRWHistory() {
            try {
                // Salva solo i dati essenziali (non l'HTML per risparmiare spazio)
                const toSave = {};
                for (const [year, rw] of Object.entries(generatedQuadriRW)) {
                    toSave[year] = {
                        data: rw.data,
                        aiGenerated: rw.aiGenerated || false,
                        generatedAt: rw.generatedAt
                    };
                }
                localStorage.setItem('cryptofolio_quadriRW', JSON.stringify(toSave));
            } catch (e) {
                console.error('Error saving Quadri RW:', e);
            }
        }
        
        function loadQuadriRWHistory() {
            try {
                const saved = localStorage.getItem('cryptofolio_quadriRW');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    for (const [year, rw] of Object.entries(parsed)) {
                        // Rigenera HTML dai dati
                        generatedQuadriRW[year] = {
                            ...rw,
                            html: renderQuadroRW(parseInt(year), rw.data)
                        };
                    }
                    updateRWHistoryList();
                }
            } catch (e) {
                console.error('Error loading Quadri RW:', e);
            }
        }
        
        // ==================== END QUADRO RW GENERATOR ====================
        
        async function testExchangeApi(exchId) {
            if (exchId === 'binance') {
                const apiKey = document.getElementById('apiKey-binance')?.value.trim();
                const secretKey = document.getElementById('secretKey-binance')?.value.trim();
                
                if (!apiKey || !secretKey || apiKey.includes('...') || secretKey.includes('‚Ä¢‚Ä¢')) {
                    alert('‚ö†Ô∏è Inserisci API Key e Secret Key valide!');
                    return;
                }
                
                try {
                    // Prima verifica che il server sia attivo
                    const statusResponse = await fetch('http://localhost:3457/status');
                    if (!statusResponse.ok) throw new Error('Server non attivo');
                    
                    // Test connessione Binance
                    const testUrl = `http://localhost:3457/test?apiKey=${encodeURIComponent(apiKey)}&secretKey=${encodeURIComponent(secretKey)}`;
                    const response = await fetch(testUrl);
                    const data = await response.json();
                    
                    if (data.success) {
                        alert('‚úÖ Connessione riuscita! API valida.');
                    } else {
                        alert('‚ùå Errore: ' + (data.error || 'Sconosciuto'));
                    }
                } catch (e) {
                    if (e.message.includes('Failed to fetch') || e.message.includes('non attivo')) {
                        alert('‚ö†Ô∏è Server non attivo!\n\n1. Scarica il file "binance-tax-server.js"\n2. Apri terminale nella cartella\n3. Esegui: node binance-tax-server.js\n4. Riprova');
                    } else {
                        alert('‚ùå Errore: ' + e.message);
                    }
                }
            }
        }
        
        async function saveAndDownloadExchangeApi(exchId) {
            if (exchId === 'binance') {
                const apiKey = document.getElementById('apiKey-binance')?.value.trim();
                const secretKey = document.getElementById('secretKey-binance')?.value.trim();
                
                if (!apiKey || !secretKey || apiKey.includes('...') || secretKey.includes('‚Ä¢‚Ä¢')) {
                    alert('‚ö†Ô∏è Inserisci API Key e Secret Key valide!\n\nVai su Binance ‚Üí Profilo ‚Üí Gestione API ‚Üí "Crea API report fiscale"');
                    return;
                }
                
                // Salva le chiavi
                apiKeys.binanceTaxKey = apiKey;
                apiKeys.binanceTaxSecret = secretKey;
                localStorage.setItem('cryptofolio_apikeys', JSON.stringify(apiKeys));
                
                // Mostra progresso
                const progress = document.getElementById('apiProgress-binance');
                const progressBar = document.getElementById('apiProgressBar-binance');
                const progressText = document.getElementById('apiProgressText-binance');
                if (progress) progress.style.display = 'block';
                
                try {
                    // Verifica server
                    if (progressText) progressText.textContent = 'Verifica server...';
                    if (progressBar) progressBar.style.width = '5%';
                    
                    const serverOnline = await checkBinanceServerStatus();
                    if (!serverOnline) {
                        throw new Error('Server non attivo');
                    }
                    
                    // Download dati da server
                    if (progressText) progressText.textContent = 'Download in corso... (pu√≤ richiedere 1-2 minuti)';
                    if (progressBar) progressBar.style.width = '10%';
                    
                    const downloadUrl = `http://localhost:3457/download?apiKey=${encodeURIComponent(apiKey)}&secretKey=${encodeURIComponent(secretKey)}`;
                    const response = await fetch(downloadUrl);
                    const data = await response.json();
                    
                    // Gestisce diversi formati di risposta
                    if (data.error) {
                        throw new Error(data.error);
                    }
                    
                    // Estrai transazioni (supporta entrambi i formati)
                    let rawTransactions = data.transactions || [];
                    const txCount = data.count || rawTransactions.length;
                    
                    if (txCount === 0) {
                        if (progressText) progressText.textContent = '‚ö†Ô∏è Nessuna transazione trovata';
                        alert('‚ö†Ô∏è Nessuna transazione trovata.\n\nVerifica che:\n1. Hai usato "API report fiscale" (non API normale)\n2. Hai transazioni su Binance');
                        return;
                    }
                    
                    if (progressBar) progressBar.style.width = '80%';
                    if (progressText) progressText.textContent = `Elaborazione ${txCount} transazioni...`;
                    
                    // Converti le transazioni
                    const allTransactions = rawTransactions.map(tx => ({
                        ...tx,
                        date: new Date(tx.date),
                        change: tx.change || tx.amount || 0
                    }));
                    
                    // Ordina per data
                    allTransactions.sort((a, b) => a.date - b.date);
                    
                    // Calcola saldi al 31/12
                    if (progressText) progressText.textContent = 'Calcolo saldi 31/12...';
                    if (progressBar) progressBar.style.width = '90%';
                    
                    const balances = {};
                    const yearEndSnapshots = {};
                    const years = [2021, 2022, 2023, 2024, 2025, 2026];
                    let yearIndex = 0;
                    
                    for (const tx of allTransactions) {
                        if (!balances[tx.coin]) balances[tx.coin] = 0;
                        balances[tx.coin] += tx.change || 0;
                        if (Math.abs(balances[tx.coin]) < 0.00000001) balances[tx.coin] = 0;
                        
                        while (yearIndex < years.length && tx.date > new Date(years[yearIndex], 11, 31, 23, 59, 59)) {
                            yearEndSnapshots[years[yearIndex]] = { ...balances };
                            yearIndex++;
                        }
                    }
                    
                    for (let i = yearIndex; i < years.length; i++) {
                        yearEndSnapshots[years[i]] = { ...balances };
                    }
                    
                    // Calcola totali EUR
                    const yearTotals = {};
                    for (const year of years) {
                        let totalEur = 0;
                        const snapshot = yearEndSnapshots[year] || {};
                        for (const [coin, amount] of Object.entries(snapshot)) {
                            if (amount <= 0) continue;
                            // üö´ Salta token LD* (duplicati Earn)
                            if (coin.startsWith('LD')) continue;
                            const priceEur = getPriceEur(coin, year);
                            totalEur += amount * priceEur;
                        }
                        yearTotals[year] = Math.round(totalEur * 100) / 100;
                    }
                    
                    // Salva
                    exchangeData['binance'] = {
                        transactions: allTransactions,
                        balances: yearEndSnapshots,
                        totals: yearTotals,
                        transactionCount: allTransactions.length,
                        isManual: false,
                        lastImport: new Date().toISOString(),
                        source: 'api'
                    };
                    
                    if (progressBar) progressBar.style.width = '100%';
                    if (progressText) progressText.textContent = `‚úÖ ${allTransactions.length} transazioni importate!`;
                    
                    saveExchangeDataToFirebase();
                    initExchangeGrid();
                    updateExchangeTotals();
                    
                    // Conta tipi di transazione
                    const summary = data.summary || {};
                    const deposits = summary.deposits || allTransactions.filter(t => t.type === 'deposit').length;
                    const withdrawals = summary.withdrawals || allTransactions.filter(t => t.type === 'withdrawal').length;
                    const dividends = summary.dividend || summary.dividends || allTransactions.filter(t => t.type === 'dividend').length;
                    const staking = summary.staking || allTransactions.filter(t => t.type === 'staking').length;
                    const earn = summary.earn || allTransactions.filter(t => t.type === 'interest').length;
                    const converts = summary.conversions || summary.converts || allTransactions.filter(t => t.type === 'convert' || t.type === 'dust').length;
                    const trades = summary.trades || allTransactions.filter(t => t.type === 'trade').length;
                    
                    setTimeout(() => {
                        alert(`‚úÖ Binance Tax API completato!\n\nüìä ${allTransactions.length} transazioni totali\nüì• ${deposits} depositi\nüì§ ${withdrawals} prelievi\nüéÅ ${dividends} distribuzione\nüîÑ ${converts} conversioni\nüìà ${trades} trades\nü•© ${staking} staking\nüí∞ ${earn} earn`);
                    }, 500);
                    
                } catch (e) {
                    console.error('Binance Tax API error:', e);
                    if (progressText) progressText.textContent = '‚ùå Errore: ' + e.message;
                    
                    if (e.message.includes('Failed to fetch') || e.message.includes('non attivo')) {
                        alert('‚ö†Ô∏è Server non attivo!\n\nPer usare l\'API Binance:\n\n1. Scarica "binance-tax-server.js"\n2. Apri terminale nella cartella\n3. Esegui: node binance-tax-server.js\n4. Riprova\n\nOppure usa il metodo CSV/ZIP.');
                    } else {
                        alert('‚ùå Errore: ' + e.message);
                    }
                }
            }
        }
        
        function toggleExchangeDropzone(exchId) {
            const dropzone = document.getElementById('dropzone-' + exchId);
            if (dropzone) {
                dropzone.style.display = dropzone.style.display === 'none' ? 'block' : 'none';
            }
        }
        
        function handleDragOver(e, exchId) {
            e.preventDefault();
            const dropzone = document.getElementById('dropzone-' + exchId);
            if (dropzone) {
                dropzone.style.borderColor = 'var(--green)';
                dropzone.style.background = 'rgba(0,230,118,0.1)';
            }
        }
        
        function handleDragLeave(e, exchId) {
            e.preventDefault();
            const dropzone = document.getElementById('dropzone-' + exchId);
            if (dropzone) {
                dropzone.style.borderColor = 'var(--border)';
                dropzone.style.background = 'transparent';
            }
        }
        
        async function handleDrop(e, exchId) {
            e.preventDefault();
            handleDragLeave(e, exchId);
            const files = e.dataTransfer.files;
            await processExchangeFiles(files, exchId);
        }
        
        async function handleFileSelect(e, exchId) {
            const files = e.target.files;
            await processExchangeFiles(files, exchId);
        }
        
        async function processExchangeFiles(files, exchId) {
            console.log('Processing files for', exchId, files.length, 'files');
            
            // Mostra stato caricamento
            const dropzone = document.getElementById('dropzone-' + exchId);
            if (dropzone) {
                dropzone.innerHTML = '<div style="font-size:32px;margin-bottom:8px;">‚è≥</div><div style="color:var(--accent);font-size:13px;">Elaborazione in corso...</div>';
            }
            
            let allTransactions = [];
            
            try {
                for (const file of files) {
                    console.log('Processing file:', file.name, 'size:', file.size);
                    
                    if (file.name.endsWith('.zip')) {
                        // Estrai ZIP
                        const transactions = await processZipFile(file, exchId);
                        console.log('ZIP parsed:', transactions.length, 'transactions');
                        allTransactions.push(...transactions);
                    } else if (file.name.endsWith('.csv')) {
                        // Parse CSV direttamente
                        const text = await file.text();
                        console.log('CSV loaded, length:', text.length);
                        const transactions = parseExchangeCSV(text, exchId);
                        console.log('CSV parsed:', transactions.length, 'transactions');
                        allTransactions.push(...transactions);
                    }
                }
                
                console.log('Total transactions:', allTransactions.length);
                
                if (allTransactions.length > 0) {
                    // Salva transazioni (solo totali per risparmiare spazio)
                    if (!exchangeData[exchId]) {
                        exchangeData[exchId] = { transactions: [], balances: {}, totals: {} };
                    }
                    exchangeData[exchId].transactions = allTransactions;
                    
                    // Calcola saldi al 31/12
                    calculateExchangeBalances(exchId);
                    
                    // Calcola Cost Basis (prezzo di acquisto)
                    if (exchId === 'binance') {
                        calculateCostBasisFromBinance(allTransactions);
                    } else if (exchId === 'bitpanda') {
                        calculateCostBasisFromBitpanda(allTransactions);
                    }
                    
                    // Aggiorna UI
                    initExchangeGrid();
                    updateExchangeTotals();
                    saveExchangeDataToFirebase();
                    
                    // Aggiorna il dettaglio exchange se siamo nella pagina dettaglio
                    if (currentDetailExchange === exchId) {
                        openExchangeDetail(exchId);
                    }
                    
                    alert('‚úÖ ' + exchId.toUpperCase() + ': Importate ' + allTransactions.length + ' transazioni!');
                } else {
                    alert('‚ùå Nessuna transazione trovata nei file. Controlla la console (F12) per i dettagli.');
                    initExchangeGrid(); // Ripristina dropzone
                }
            } catch (err) {
                console.error('Error processing files:', err);
                alert('‚ùå Errore: ' + err.message);
                initExchangeGrid(); // Ripristina dropzone
            }
        }
        
        async function processZipFile(file, exchId) {
            // Usa JSZip (gi√† caricato nell'head)
            try {
                console.log('Processing ZIP file:', file.name);
                const zip = await JSZip.loadAsync(file);
                let allTransactions = [];
                
                for (const [path, zipEntry] of Object.entries(zip.files)) {
                    console.log('ZIP entry:', path);
                    if (path.endsWith('.csv') && !path.includes('__MACOSX') && !path.includes('.DS_Store')) {
                        const text = await zipEntry.async('text');
                        console.log('Parsing CSV:', path, 'length:', text.length);
                        const transactions = parseExchangeCSV(text, exchId);
                        console.log('Parsed', transactions.length, 'transactions from', path);
                        allTransactions.push(...transactions);
                    }
                }
                
                return allTransactions;
            } catch (e) {
                console.error('ZIP processing error:', e);
                alert('Errore lettura ZIP: ' + e.message);
                return [];
            }
        }
        
        function loadScript(src) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = src;
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }
        
        function parseExchangeCSV(text, exchId) {
            // Parser generico che adatta al formato dell'exchange
            // Rimuovi BOM (byte order mark) se presente
            const cleanText = text.replace(/^\uFEFF/, '').trim();
            const lines = cleanText.split('\n');
            console.log('parseExchangeCSV for', exchId, '- lines:', lines.length);
            
            if (lines.length < 2) {
                console.log('Not enough lines in CSV');
                return [];
            }
            
            // Pulisci header da BOM e caratteri speciali
            let header = lines[0].toLowerCase().replace(/^\uFEFF/, '').replace(/[^\x20-\x7E,]/g, '').trim();
            console.log('Header (cleaned):', header.substring(0, 120));
            
            // === BINANCE ===
            if (header.includes('utc_time') && header.includes('coin')) {
                console.log('Detected Binance format');
                return parseBinanceCSV(lines);
            }
            
            // === BITGET ===
            if (header.includes('order') && header.includes('date') && header.includes('coin') && header.includes('amount')) {
                console.log('Detected Bitget format');
                return parseBitgetCSV(lines);
            }
            
            // === CRYPTO.COM APP ===
            if (header.includes('timestamp') && header.includes('transaction description') && header.includes('currency')) {
                console.log('Detected Crypto.com App format');
                return parseCryptoComAppCSV(lines);
            }
            
            // === CRYPTO.COM EXCHANGE ===
            if (header.includes('event_time_display') && header.includes('instrument_name') && header.includes('journal_type')) {
                console.log('Detected Crypto.com Exchange format');
                return parseCryptoComExchangeCSV(lines);
            }
            
            // === COINBASE ===
            if (header.includes('transaction type') && header.includes('asset') && header.includes('quantity')) {
                console.log('Detected Coinbase format');
                return parseCoinbaseCSV(lines);
            }
            // Coinbase - cerca header nelle prime righe
            for (let i = 0; i < Math.min(10, lines.length); i++) {
                const testHeader = lines[i].toLowerCase();
                if (testHeader.includes('transaction type') && testHeader.includes('asset') && testHeader.includes('quantity')) {
                    console.log('Detected Coinbase format at line', i);
                    return parseCoinbaseCSV(lines.slice(i));
                }
            }
            
            // === COSMOS ===
            if (header.includes('tx_type') && header.includes('received_amount') && header.includes('received_currency')) {
                console.log('Detected Cosmos format');
                return parseCosmosCSV(lines);
            }
            
            // === BYBIT AssetChangeDetails ===
            if (header.includes('uid') && header.includes('currency') && header.includes('change') && header.includes('wallet balance')) {
                console.log('Detected Bybit AssetChangeDetails format');
                return parseBybitAssetChangeCSV(lines);
            }
            // Bybit - cerca header nelle prime righe (salta riga UID)
            for (let i = 0; i < Math.min(5, lines.length); i++) {
                const testHeader = lines[i].toLowerCase();
                if (testHeader.includes('uid') && testHeader.includes('currency') && testHeader.includes('change')) {
                    console.log('Detected Bybit AssetChangeDetails at line', i);
                    return parseBybitAssetChangeCSV(lines.slice(i));
                }
            }
            
            // === BYBIT Deposit/Withdraw History ===
            for (let i = 0; i < Math.min(5, lines.length); i++) {
                const testHeader = lines[i].toLowerCase();
                if (testHeader.includes('uid') && testHeader.includes('date') && testHeader.includes('type') && testHeader.includes('asset') && testHeader.includes('amount')) {
                    console.log('Detected Bybit DepositWithdraw at line', i);
                    return parseBybitDepositWithdrawCSV(lines.slice(i));
                }
            }
            
            // === BITPANDA ===
            // Cerca header nelle prime 10 righe (salta disclaimer)
            for (let i = 0; i < Math.min(10, lines.length); i++) {
                const testHeader = lines[i].toLowerCase();
                if (testHeader.includes('transaction id') && testHeader.includes('transaction type') && testHeader.includes('amount asset')) {
                    console.log('Detected Bitpanda format at line', i);
                    return parseBitpandaCSV(lines.slice(i));
                }
            }
            
            // === TATAX FORMAT ===
            // Symbol,TokenAddress,TimeStamp,MovementType,Quantity,Countervalue,...
            if (header.includes('symbol') && header.includes('movementtype') && header.includes('quantity')) {
                console.log('Detected Tatax format');
                return parseTataxCSV(lines);
            }
            
            console.log('No matching parser found, using generic');
            return parseGenericCSV(lines, exchId);
        }
        
        // === CRYPTO.COM APP PARSER ===
        function parseCryptoComAppCSV(lines) {
            // Timestamp (UTC),Transaction Description,Currency,Amount,To Currency,To Amount,...,Transaction Kind
            const transactions = [];
            console.log('Parsing Crypto.com App CSV, lines:', lines.length);
            
            for (let i = 1; i < lines.length; i++) {
                const cols = parseCSVLine(lines[i]);
                if (cols.length < 10) continue;
                
                const [timestamp, description, currency, amount, toCurrency, toAmount, nativeCurrency, nativeAmount, nativeUsd, txKind] = cols;
                const date = new Date(timestamp);
                if (isNaN(date.getTime())) continue;
                
                // Prima valuta (pu√≤ essere + o -)
                const amountNum = parseFloat(amount) || 0;
                if (amountNum !== 0 && currency && currency !== '-') {
                    transactions.push({
                        date: date,
                        account: 'app',
                        operation: description,
                        coin: currency,
                        change: amountNum,
                        remark: txKind || ''
                    });
                }
                
                // Seconda valuta (To Currency / To Amount) - solo se presente e diversa dalla prima
                const toAmountNum = parseFloat(toAmount) || 0;
                if (toAmountNum !== 0 && toCurrency && toCurrency !== '-' && toCurrency !== currency) {
                    transactions.push({
                        date: date,
                        account: 'app',
                        operation: description,
                        coin: toCurrency,
                        change: toAmountNum, // To Amount √® sempre positivo (ricevuto)
                        remark: txKind || ''
                    });
                }
            }
            console.log('Parsed', transactions.length, 'Crypto.com App transactions');
            return transactions;
        }
        
        // === CRYPTO.COM EXCHANGE PARSER ===
        function parseCryptoComExchangeCSV(lines) {
            // event_time_display,instrument_name,journal_id,journal_type,...,transaction_qty,...
            const transactions = [];
            console.log('Parsing Crypto.com Exchange CSV, lines:', lines.length);
            
            for (let i = 1; i < lines.length; i++) {
                const cols = parseCSVLine(lines[i]);
                if (cols.length < 8) continue;
                
                const [eventTime, instrumentName, journalId, journalType, orderId, side, takerSide, transactionQty] = cols;
                const date = new Date(eventTime);
                if (isNaN(date.getTime())) continue;
                
                const qty = parseFloat(transactionQty) || 0;
                if (qty === 0) continue;
                
                transactions.push({
                    date: date,
                    account: 'exchange',
                    operation: journalType,
                    coin: instrumentName,
                    change: qty,
                    remark: ''
                });
            }
            console.log('Parsed', transactions.length, 'Crypto.com Exchange transactions');
            return transactions;
        }
        
        // === COINBASE PARSER ===
        function parseCoinbaseCSV(lines) {
            // ID,Timestamp,Transaction Type,Asset,Quantity Transacted,...
            const transactions = [];
            console.log('Parsing Coinbase CSV, lines:', lines.length);
            
            for (let i = 1; i < lines.length; i++) {
                const cols = parseCSVLine(lines[i]);
                if (cols.length < 5) continue;
                
                const [id, timestamp, txType, asset, quantity] = cols;
                const date = new Date(timestamp);
                if (isNaN(date.getTime())) continue;
                
                let qty = parseFloat(quantity) || 0;
                if (qty === 0) continue;
                
                // Determina segno basato sul tipo
                const txTypeLower = txType.toLowerCase();
                if (txTypeLower.includes('sell') || txTypeLower.includes('send') || txTypeLower.includes('withdraw')) {
                    qty = -Math.abs(qty);
                } else {
                    qty = Math.abs(qty);
                }
                
                transactions.push({
                    date: date,
                    account: 'coinbase',
                    operation: txType,
                    coin: asset,
                    change: qty,
                    remark: ''
                });
            }
            console.log('Parsed', transactions.length, 'Coinbase transactions');
            return transactions;
        }
        
        // === COSMOS PARSER ===
        function parseCosmosCSV(lines) {
            // timestamp,tx_type,received_amount,received_currency,sent_amount,sent_currency,...
            const transactions = [];
            console.log('Parsing Cosmos CSV, lines:', lines.length);
            
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].replace(/\r/g, '');
                const cols = parseCSVLine(line);
                if (cols.length < 6) continue;
                
                const [timestamp, txType, receivedAmount, receivedCurrency, sentAmount, sentCurrency] = cols;
                const date = new Date(timestamp);
                if (isNaN(date.getTime())) continue;
                
                // Received
                const recvAmt = parseFloat(receivedAmount) || 0;
                if (recvAmt > 0 && receivedCurrency) {
                    transactions.push({
                        date: date,
                        account: 'cosmos',
                        operation: txType,
                        coin: receivedCurrency.toUpperCase(),
                        change: recvAmt,
                        remark: ''
                    });
                }
                
                // Sent
                const sentAmt = parseFloat(sentAmount) || 0;
                if (sentAmt > 0 && sentCurrency) {
                    transactions.push({
                        date: date,
                        account: 'cosmos',
                        operation: txType,
                        coin: sentCurrency.toUpperCase(),
                        change: -sentAmt,
                        remark: ''
                    });
                }
            }
            console.log('Parsed', transactions.length, 'Cosmos transactions');
            return transactions;
        }
        
        // === BYBIT ASSET CHANGE DETAILS PARSER ===
        function parseBybitAssetChangeCSV(lines) {
            // Uid,Currency,Contract,Type,Direction,...,Change,...,Time(UTC)
            const transactions = [];
            console.log('Parsing Bybit AssetChange CSV, lines:', lines.length);
            
            // Trova indice colonne
            const header = lines[0].toLowerCase();
            const cols = header.split(',');
            const currencyIdx = cols.findIndex(c => c.includes('currency'));
            const changeIdx = cols.findIndex(c => c === 'change');
            const timeIdx = cols.findIndex(c => c.includes('time'));
            const typeIdx = cols.findIndex(c => c === 'type');
            
            if (currencyIdx === -1 || changeIdx === -1 || timeIdx === -1) {
                console.log('Cannot find required columns in Bybit CSV');
                return [];
            }
            
            for (let i = 1; i < lines.length; i++) {
                const parts = lines[i].split(',');
                if (parts.length <= Math.max(currencyIdx, changeIdx, timeIdx)) continue;
                
                const currency = parts[currencyIdx];
                const change = parseFloat(parts[changeIdx]) || 0;
                const timeStr = parts[timeIdx];
                const txType = typeIdx >= 0 ? parts[typeIdx] : '';
                
                const date = new Date(timeStr);
                if (isNaN(date.getTime()) || change === 0) continue;
                
                transactions.push({
                    date: date,
                    account: 'bybit',
                    operation: txType,
                    coin: currency,
                    change: change,
                    remark: ''
                });
            }
            console.log('Parsed', transactions.length, 'Bybit AssetChange transactions');
            return transactions;
        }
        
        // === BYBIT DEPOSIT/WITHDRAW PARSER ===
        function parseBybitDepositWithdrawCSV(lines) {
            // Uid,Date,Type,Asset,Chain,Amount,...
            const transactions = [];
            console.log('Parsing Bybit DepositWithdraw CSV, lines:', lines.length);
            
            for (let i = 1; i < lines.length; i++) {
                const cols = lines[i].split(',');
                if (cols.length < 6) continue;
                
                const [uid, dateStr, txType, asset, chain, amount] = cols;
                const date = new Date(dateStr);
                if (isNaN(date.getTime())) continue;
                
                let qty = parseFloat(amount) || 0;
                if (qty === 0) continue;
                
                // Withdraw = negativo
                if (txType.toLowerCase().includes('withdraw')) {
                    qty = -Math.abs(qty);
                }
                
                transactions.push({
                    date: date,
                    account: 'bybit',
                    operation: txType,
                    coin: asset,
                    change: qty,
                    remark: chain
                });
            }
            console.log('Parsed', transactions.length, 'Bybit DepositWithdraw transactions');
            return transactions;
        }
        
        // === BITPANDA PARSER - CONTABILIT√Ä PRECISA ===
        function parseBitpandaCSV(lines) {
            // Colonne CSV Bitpanda:
            // 0: Transaction ID, 1: Timestamp, 2: Transaction Type, 3: In/Out
            // 4: Amount Fiat, 5: Fiat, 6: Amount Asset, 7: Asset
            // 8: Asset market price, 9: Asset market price currency
            // 10: Asset class, 11: Product ID, 12: Fee, 13: Fee asset
            // 14: Fee percent, 15: Spread, 16: Spread Currency, 17: Tax Fiat
            
            const transactions = [];
            const priceHistory = {}; // { "VSN": [{ date, price, currency }, ...] }
            
            console.log('üîç Parsing Bitpanda CSV (PRECISIONE CONTABILE)');
            console.log('üìã Righe da processare:', lines.length);
            
            for (let i = 1; i < lines.length; i++) {
                const cols = parseCSVLine(lines[i]);
                if (cols.length < 8) continue;
                
                const txId = cols[0];
                const timestamp = cols[1];
                const txType = cols[2];
                const inOut = cols[3];
                const amountFiat = parseFloat(cols[4]) || 0;
                const fiatCurrency = cols[5] || 'EUR';
                const amountAsset = parseFloat(cols[6]) || 0;
                const asset = cols[7];
                const assetPrice = parseFloat(cols[8]) || 0;
                const priceCurrency = cols[9] || 'USD';
                const fee = parseFloat(cols[12]) || 0;
                const feeAsset = cols[13] || '';
                const taxFiat = parseFloat(cols[17]) || 0;
                
                const date = new Date(timestamp);
                if (isNaN(date.getTime())) continue;
                if (amountAsset === 0 || !asset || asset === '-') continue;
                
                // Converti prezzo in EUR se necessario
                let priceEur = assetPrice;
                if (priceCurrency === 'USD' && assetPrice > 0) {
                    priceEur = assetPrice * EUR_USD;
                }
                
                // Converti valore fiat in EUR
                let valueEur = amountFiat;
                if (fiatCurrency === 'USD' && amountFiat > 0) {
                    valueEur = amountFiat * EUR_USD;
                }
                
                // Salva prezzo storico per questo asset
                if (assetPrice > 0) {
                    if (!priceHistory[asset]) priceHistory[asset] = [];
                    priceHistory[asset].push({
                        date: date,
                        price: assetPrice,
                        priceEur: priceEur,
                        currency: priceCurrency
                    });
                }
                
                // Determina tipo e direzione
                let type = txType.toLowerCase();
                const typeClean = type.replace(/[()]/g, ''); // Per confronti
                const inOutLower = inOut.toLowerCase();
                let isAssetIncoming = false;
                
                // Logica precisa per ogni tipo
                if (typeClean === 'buy') {
                    isAssetIncoming = true;
                    type = 'buy';
                } else if (typeClean === 'sell') {
                    isAssetIncoming = false;
                    type = 'sell';
                } else if (typeClean === 'reward' || typeClean === 'distribution') {
                    isAssetIncoming = true;
                    type = 'reward';
                } else if (typeClean === 'deposit') {
                    isAssetIncoming = true;
                    type = 'deposit';
                } else if (typeClean === 'withdrawal') {
                    isAssetIncoming = false;
                    type = 'withdrawal';
                } else if (type === 'transfer(stake)' || typeClean === 'transferstake') {
                    // Movimento IN staking - i token sono ancora tuoi!
                    // Questo bilancia il "transfer, outgoing" corrispondente
                    isAssetIncoming = true;
                    type = 'staking';
                } else if (typeClean === 'transfer') {
                    isAssetIncoming = (inOutLower === 'incoming');
                    type = isAssetIncoming ? 'deposit' : 'withdrawal';
                } else {
                    isAssetIncoming = (inOutLower === 'incoming');
                }
                
                const change = isAssetIncoming ? Math.abs(amountAsset) : -Math.abs(amountAsset);
                
                // Calcola valore EUR preciso
                // Priorit√†: 1) amountFiat convertito, 2) quantit√† √ó prezzo
                let finalValueEur = valueEur;
                if (finalValueEur === 0 && priceEur > 0) {
                    finalValueEur = Math.abs(amountAsset) * priceEur;
                }
                
                const tx = {
                    id: txId,
                    date: date,
                    account: 'bitpanda',
                    type: type,
                    operation: txType,
                    coin: asset,
                    amount: Math.abs(amountAsset),
                    change: change,
                    // Prezzi
                    priceAtTx: assetPrice,
                    priceCurrency: priceCurrency,
                    priceEur: priceEur,
                    // Valori
                    amountFiat: amountFiat,
                    fiatCurrency: fiatCurrency,
                    amountEur: finalValueEur,
                    // Costi
                    fee: fee,
                    feeAsset: feeAsset,
                    tax: taxFiat
                };
                
                transactions.push(tx);
                
                // Log dettagliato
                const sign = change >= 0 ? '+' : '';
                console.log(`  ${date.toISOString().slice(0,10)} ${type.padEnd(10)} ${asset.padEnd(6)} ${sign}${change.toFixed(4).padStart(12)} @ ‚Ç¨${priceEur.toFixed(4)} = ‚Ç¨${finalValueEur.toFixed(2)}`);
            }
            
            // Salva price history globalmente per calcoli futuri
            window.bitpandaPriceHistory = priceHistory;
            
            // Calcola statistiche
            const stats = calculateTransactionStats(transactions);
            console.log('\nüìä RIEPILOGO CONTABILE:');
            console.log('  Transazioni totali:', transactions.length);
            console.log('  Token diversi:', Object.keys(priceHistory).length);
            console.log('  Totale acquisti:', '‚Ç¨' + stats.totalBuys.toFixed(2));
            console.log('  Totale vendite:', '‚Ç¨' + stats.totalSells.toFixed(2));
            console.log('  Totale rewards:', '‚Ç¨' + stats.totalRewards.toFixed(2));
            console.log('  Fee totali:', '‚Ç¨' + stats.totalFees.toFixed(2));
            
            // Salva stats
            window.bitpandaStats = stats;
            
            return transactions;
        }
        
        // Calcola statistiche contabili precise
        function calculateTransactionStats(transactions) {
            let totalBuys = 0;      // Acquisti (costo)
            let totalSells = 0;     // Vendite (ricavo)
            let totalRewards = 0;   // Rewards ricevuti
            let totalDeposits = 0;  // Depositi
            let totalWithdrawals = 0; // Prelievi
            let totalFees = 0;      // Fee pagate
            
            const byAsset = {}; // Per asset: { bought, sold, balance, avgCost }
            
            for (const tx of transactions) {
                const asset = tx.coin;
                if (!byAsset[asset]) {
                    byAsset[asset] = {
                        bought: 0,
                        boughtValue: 0,
                        sold: 0,
                        soldValue: 0,
                        rewards: 0,
                        rewardsValue: 0,
                        balance: 0,
                        totalCost: 0
                    };
                }
                
                const a = byAsset[asset];
                const valueEur = tx.amountEur || 0;
                
                switch (tx.type) {
                    case 'buy':
                        totalBuys += valueEur;
                        a.bought += tx.amount;
                        a.boughtValue += valueEur;
                        a.balance += tx.amount;
                        a.totalCost += valueEur;
                        break;
                    case 'sell':
                        totalSells += valueEur;
                        a.sold += tx.amount;
                        a.soldValue += valueEur;
                        a.balance -= tx.amount;
                        break;
                    case 'reward':
                    case 'staking':
                        totalRewards += valueEur;
                        a.rewards += tx.amount;
                        a.rewardsValue += valueEur;
                        a.balance += tx.amount;
                        break;
                    case 'deposit':
                        totalDeposits += valueEur;
                        a.balance += tx.amount;
                        break;
                    case 'withdrawal':
                        totalWithdrawals += valueEur;
                        a.balance -= tx.amount;
                        break;
                }
                
                // Fee
                if (tx.fee && tx.feeAsset) {
                    // Converti fee in EUR se possibile
                    const feePrice = tx.priceEur || 0;
                    if (tx.feeAsset === asset && feePrice > 0) {
                        totalFees += tx.fee * feePrice;
                    } else if (tx.feeAsset === 'EUR') {
                        totalFees += tx.fee;
                    } else if (tx.feeAsset === 'USD') {
                        totalFees += tx.fee * EUR_USD;
                    }
                }
            }
            
            // Calcola prezzo medio di carico per ogni asset
            for (const asset of Object.keys(byAsset)) {
                const a = byAsset[asset];
                if (a.bought > 0) {
                    a.avgCost = a.boughtValue / a.bought;
                }
            }
            
            return {
                totalBuys,
                totalSells,
                totalRewards,
                totalDeposits,
                totalWithdrawals,
                totalFees,
                byAsset,
                profitLoss: totalSells - totalBuys + totalRewards
            };
        }
        
        function parseBitgetCSV(lines) {
            // Formato: order,Date,Coin,Type,Amount,Fee,Available
            const transactions = [];
            console.log('Parsing Bitget CSV, lines:', lines.length);
            console.log('Header:', lines[0]);
            console.log('First data line:', lines[1]);
            
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i];
                if (!line.trim()) continue;
                
                // Parse CSV (pu√≤ avere tab iniziale)
                const cleanLine = line.replace(/^\t/, '').trim();
                const cols = cleanLine.split(',');
                
                if (cols.length < 5) {
                    console.log('Skipping line (not enough cols):', cols.length);
                    continue;
                }
                
                const [order, dateStr, coin, type, amount, fee, available] = cols;
                
                // Parse date (formato: YYYY-MM-DD HH:MM:SS)
                const date = new Date(dateStr);
                if (isNaN(date.getTime())) {
                    console.log('Invalid date:', dateStr);
                    continue;
                }
                
                const amountNum = parseFloat(amount) || 0;
                
                transactions.push({
                    date: date,
                    account: 'spot',
                    operation: type,
                    coin: coin,
                    change: amountNum, // Gi√† con segno corretto
                    remark: ''
                });
            }
            
            console.log('Parsed', transactions.length, 'Bitget transactions');
            if (transactions.length > 0) {
                console.log('First tx:', transactions[0]);
                console.log('Last tx:', transactions[transactions.length - 1]);
            }
            
            return transactions;
        }
        
        function parseBinanceCSV(lines) {
            // Formato: "User_ID","UTC_Time","Account","Operation","Coin","Change","Remark"
            const transactions = [];
            console.log('üî∂ Parsing Binance CSV, lines:', lines.length);
            console.log('Header:', lines[0]);
            
            // Statistiche per debug
            const stats = {
                rewards: 0, buys: 0, sells: 0, deposits: 0, withdrawals: 0, 
                fees: 0, transfers: 0, other: 0, skipped: 0, duplicates: 0
            };
            
            // Track per deduplicazione (stesso timestamp + coin + change + operation)
            const seenTransactions = new Set();
            
            // Track internal transfers to avoid double counting
            const processedTransfers = new Set();
            
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i];
                if (!line.trim()) continue;
                
                // Parse CSV con virgolette
                const cols = parseCSVLine(line);
                if (cols.length < 6) {
                    continue;
                }
                
                const [userId, utcTime, account, operation, coin, change, remark] = cols;
                
                // Parse date
                const date = new Date(utcTime);
                if (isNaN(date.getTime())) {
                    continue;
                }
                
                const changeNum = parseFloat(change) || 0;
                if (changeNum === 0) continue;
                
                // === DEDUPLICAZIONE ===
                // Crea chiave unica per questa transazione
                const txKey = `${utcTime}|${coin}|${changeNum.toFixed(8)}|${operation}`;
                if (seenTransactions.has(txKey)) {
                    stats.duplicates++;
                    continue; // Skip duplicato
                }
                seenTransactions.add(txKey);
                
                const opLower = operation.toLowerCase();
                
                // Skip internal transfers from Funding wallet (already counted in Spot)
                if (opLower.includes('transfer between') && account === 'Funding') {
                    stats.skipped++;
                    continue;
                }
                
                // Normalizza tipo operazione
                let type = 'other';
                let isTaxable = false; // Per rewards
                
                // REWARDS (tassabili)
                if (opLower.includes('staking rewards') || 
                    opLower.includes('earn') && opLower.includes('interest') ||
                    opLower.includes('earn') && opLower.includes('rewards') ||
                    opLower.includes('bnb vault rewards') ||
                    opLower.includes('swap farming rewards') ||
                    opLower.includes('liquidity farming')) {
                    type = 'reward';
                    isTaxable = true;
                    stats.rewards++;
                }
                // AIRDROP / LAUNCHPOOL (tassabili)
                else if (opLower.includes('launchpool') || 
                         opLower.includes('airdrop') ||
                         opLower.includes('distribution') ||
                         opLower.includes('cashback') ||
                         opLower.includes('crypto box') ||
                         opLower.includes('voucher')) {
                    type = 'airdrop';
                    isTaxable = true;
                    stats.rewards++;
                }
                // BUY
                else if (opLower.includes('transaction buy') || 
                         opLower === 'buy' ||
                         opLower.includes('buy crypto')) {
                    type = 'buy';
                    stats.buys++;
                }
                // SELL
                else if (opLower.includes('transaction sold') || 
                         opLower.includes('transaction spend') ||
                         opLower === 'sell') {
                    type = 'sell';
                    stats.sells++;
                }
                // CONVERT (pu√≤ essere buy o sell a seconda del segno)
                else if (opLower.includes('convert') || 
                         opLower.includes('small assets exchange')) {
                    type = changeNum > 0 ? 'buy' : 'sell';
                    if (changeNum > 0) stats.buys++; else stats.sells++;
                }
                // DEPOSIT
                else if (opLower.includes('deposit') || 
                         opLower.includes('fiat') && changeNum > 0) {
                    type = 'deposit';
                    stats.deposits++;
                }
                // WITHDRAWAL
                else if (opLower.includes('withdraw')) {
                    type = 'withdrawal';
                    stats.withdrawals++;
                }
                // FEE
                else if (opLower.includes('fee')) {
                    type = 'fee';
                    stats.fees++;
                }
                // TRANSFER (interno - traccia ma non √® taxable)
                else if (opLower.includes('transfer')) {
                    type = 'transfer';
                    stats.transfers++;
                }
                // SUBSCRIPTION/REDEMPTION (Earn - movimenti Spot ‚Üî Earn)
                // QUESTI VANNO CONTATI perch√© rappresentano token che escono/entrano nel wallet Spot
                // Subscription = token che metti in Earn (escono da Spot = -)
                // Redemption = token che ritiri da Earn (entrano in Spot = +)
                else if (opLower.includes('subscription') || opLower.includes('redemption')) {
                    type = 'earn_movement';
                    stats.transfers++;
                    // NON skip - conta per il saldo!
                }
                // TRANSACTION RELATED / REVENUE (spesso accoppiato con altre TX)
                else if (opLower.includes('transaction related') || opLower.includes('transaction revenue')) {
                    // Determina dal segno
                    type = changeNum > 0 ? 'buy' : 'sell';
                    if (changeNum > 0) stats.buys++; else stats.sells++;
                }
                // CARD SPENDING
                else if (opLower.includes('card spending') || opLower.includes('merchant')) {
                    type = 'spend';
                    stats.sells++;
                }
                else {
                    stats.other++;
                }
                
                transactions.push({
                    date: date,
                    type: type,
                    coin: coin,
                    amount: Math.abs(changeNum),
                    change: changeNum,
                    operation: operation,
                    account: account,
                    remark: remark || '',
                    isTaxable: isTaxable
                });
            }
            
            // Log statistiche
            console.log('üìä Binance parsing stats:');
            console.log(`  ‚úÖ Rewards/Airdrop: ${stats.rewards}`);
            console.log(`  üí∞ Buys: ${stats.buys}`);
            console.log(`  üì§ Sells: ${stats.sells}`);
            console.log(`  üì• Deposits: ${stats.deposits}`);
            console.log(`  üì§ Withdrawals: ${stats.withdrawals}`);
            console.log(`  üí∏ Fees: ${stats.fees}`);
            console.log(`  üîÑ Transfers: ${stats.transfers}`);
            console.log(`  ‚ùì Other: ${stats.other}`);
            console.log(`  ‚è≠Ô∏è Skipped (subscr/redemp): ${stats.skipped}`);
            console.log(`  üîÑ Duplicates removed: ${stats.duplicates}`);
            console.log(`  üìã Total parsed: ${transactions.length}`);
            
            return transactions;
        }
        
        function parseGenericCSV(lines, exchId) {
            // Parser generico - cerca colonne comuni
            console.log('Using generic parser for', exchId);
            return [];
        }
        
        // === TATAX PARSER ===
        function parseTataxCSV(lines) {
            // Format: "Symbol","TokenAddress","TimeStamp","MovementType","Quantity","Countervalue","SymbolCountervalue","SourceCountervalue","SourceSymbolCountervalue"
            const transactions = [];
            console.log('Parsing Tatax CSV, lines:', lines.length);
            
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i];
                if (!line.trim()) continue;
                
                const cols = parseCSVLine(line);
                if (cols.length < 5) continue;
                
                let symbol = cols[0] || '';
                const timestamp = cols[2] || '';
                const moveType = (cols[3] || '').toUpperCase();
                let quantity = cols[4] || '0';
                
                // Parse date
                const date = new Date(timestamp);
                if (isNaN(date.getTime())) continue;
                
                // Pulisci symbol (rimuovi .LENDING@BINANCE, .STAKING@BINANCE)
                symbol = symbol.replace('.LENDING@BINANCE', '').replace('.STAKING@BINANCE', '');
                
                // Parse quantity (gestisce notazione scientifica come "1E+2")
                let qtyNum = parseFloat(quantity);
                if (isNaN(qtyNum)) qtyNum = 0;
                
                // Mappa MovementType alle nostre categorie
                let type = 'other';
                if (moveType === 'DEPOSIT') type = 'deposit';
                else if (moveType === 'WITHDRAWAL') type = 'withdrawal';
                else if (moveType === 'CREDIT') type = 'credit';
                else if (moveType === 'DEBIT') type = 'debit';
                else if (moveType === 'EXCHANGE_FEE') type = 'fee';
                else if (moveType === 'EARN') type = 'earn';
                else if (moveType.includes('FEE')) type = 'fee';
                
                transactions.push({
                    date: date,
                    type: type,
                    coin: symbol,
                    change: qtyNum,
                    operation: moveType
                });
            }
            
            console.log('Tatax parsed', transactions.length, 'transactions');
            if (transactions.length > 0) {
                console.log('First tx:', transactions[0]);
                console.log('Last tx:', transactions[transactions.length - 1]);
            }
            
            return transactions;
        }
        
        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            result.push(current.trim());
            
            return result;
        }
        
        function calculateExchangeBalances(exchId) {
            const data = exchangeData[exchId];
            if (!data || !data.transactions) {
                console.log('No transactions for', exchId);
                return;
            }
            
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('üìä CALCOLO SALDI', exchId.toUpperCase());
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('Transazioni totali:', data.transactions.length);
            
            // Ordina transazioni per data
            data.transactions.sort((a, b) => a.date - b.date);
            
            // Calcola prezzi token dalle transazioni (per token senza prezzo CoinGecko)
            // Usa il PREZZO UNITARIO dal CSV, NON il valore totale diviso quantit√†
            const tokenPricesFromTx = {};
            for (const tx of data.transactions) {
                // priceEur √® il prezzo unitario gi√† convertito in EUR
                if (tx.priceEur && tx.priceEur > 0) {
                    tokenPricesFromTx[tx.coin] = tx.priceEur;
                }
            }
            console.log('Token prices from transactions (unit price EUR):', tokenPricesFromTx);
            
            // Salva i prezzi nell'exchangeData
            data.tokenPrices = tokenPricesFromTx;
            
            // Calcola saldi cumulativi
            const balances = {}; // { coin: amount }
            const yearEndBalances = {}; // { 2021: { BTC: 0.5, ... }, ... }
            const yearEndTotals = {}; // { 2021: 12345, ... }
            
            const years = [2021, 2022, 2023, 2024, 2025, 2026];
            let currentYearIndex = 0;
            
            // Trova la data pi√π vecchia e pi√π recente
            const firstDate = data.transactions[0]?.date;
            const lastDate = data.transactions[data.transactions.length - 1]?.date;
            const firstYear = firstDate ? firstDate.getFullYear() : 2024;
            const lastYear = lastDate ? lastDate.getFullYear() : 2025;
            console.log('Date range:', firstDate, 'to', lastDate);
            console.log('Year range:', firstYear, '-', lastYear);
            
            // Salva info date per UI
            data.firstTxDate = firstDate;
            data.lastTxDate = lastDate;
            data.firstYear = firstYear;
            data.lastYear = lastYear;
            
            // Conta transazioni per anno
            const txByYear = {};
            for (const tx of data.transactions) {
                const year = tx.date.getFullYear();
                txByYear[year] = (txByYear[year] || 0) + 1;
            }
            console.log('Transazioni per anno:', txByYear);
            data.txByYear = txByYear;
            
            for (const tx of data.transactions) {
                // Aggiorna saldo
                if (!balances[tx.coin]) balances[tx.coin] = 0;
                balances[tx.coin] += tx.change;
                
                // Controlla se abbiamo superato la fine dell'anno
                while (currentYearIndex < years.length && tx.date > new Date(years[currentYearIndex], 11, 31, 23, 59, 59)) {
                    // Salva snapshot al 31/12 SOLO se l'anno √® >= firstYear
                    if (years[currentYearIndex] >= firstYear) {
                        yearEndBalances[years[currentYearIndex]] = { ...balances };
                        console.log('Snapshot for', years[currentYearIndex], '- coins:', Object.keys(balances).length);
                    }
                    currentYearIndex++;
                }
            }
            
            // Salva solo per anni con transazioni (fino a lastYear incluso)
            for (let i = currentYearIndex; i < years.length; i++) {
                if (years[i] >= firstYear && years[i] <= lastYear) {
                    yearEndBalances[years[i]] = { ...balances };
                }
                // Per anni futuri (es. 2026 se ultima TX √® 2025), NON salviamo
            }
            
            // Log dei saldi finali con filtro per saldi significativi
            console.log('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
            console.log('üìä SALDI FINALI PER TOKEN (solo > 0):');
            const significantBalances = Object.entries(balances)
                .filter(([c, a]) => Math.abs(a) > 0.0001)
                .sort((a, b) => Math.abs(b[1]) - Math.abs(a[1]));
            
            for (const [coin, amt] of significantBalances) {
                console.log(`  ${coin}: ${amt.toFixed(6)}`);
            }
            
            // Calcola totali EUR per ogni anno (PRECISIONE CONTABILE)
            // Lista stablecoin - prezzo fisso 1 USD
            const STABLECOINS = ['USDT', 'USDC', 'BUSD', 'DAI', 'TUSD', 'USDP', 'GUSD', 'FDUSD', 'FRAX', 'UST', 'USTC'];
            
            // Lista token da ignorare (valore ~0, airdrop spam, ecc)
            const IGNORE_TOKENS = ['NFT', '1MBABYDOGE', 'LUNC', 'USTC', 'SANTOS', 'HIGH', 'MC'];
            
            // Salva dettaglio calcolo per debug UI
            data.yearEndDetails = {};
            
            for (const year of years) {
                // Skip anni prima della prima TX o dopo l'ultima TX
                if (year < firstYear) {
                    yearEndTotals[year] = 0;
                    continue;
                }
                if (year > lastYear) {
                    // Anno futuro - non ci sono TX
                    yearEndTotals[year] = null; // null = non calcolabile
                    continue;
                }
                
                const yb = yearEndBalances[year] || {};
                let totalEur = 0;
                let coinsWithValue = [];
                const yearEnd = new Date(year, 11, 31, 23, 59, 59);
                const details = []; // Per debug UI
                
                for (const [coin, amount] of Object.entries(yb)) {
                    if (amount <= 0.0001) continue;
                    
                    // Skip token da ignorare
                    if (IGNORE_TOKENS.includes(coin.toUpperCase())) {
                        details.push({ coin, amount, priceEur: 0, valueEur: 0, source: 'Ignored token' });
                        continue;
                    }
                    
                    let priceEur = 0;
                    let priceSource = '';
                    
                    // STABLECOIN: prezzo fisso 1 USD = EUR_USD
                    if (STABLECOINS.includes(coin.toUpperCase())) {
                        priceEur = EUR_USD; // ~0.85
                        priceSource = 'Stablecoin (1 USD)';
                    }
                    // 1. Cerca ultimo prezzo dalle transazioni PRIMA del 31/12 (per Bitpanda)
                    else if (tokenPricesFromTx[coin]) {
                        const priceHistory = window.bitpandaPriceHistory?.[coin] || [];
                        let bestPrice = null;
                        let bestDate = null;
                        
                        for (const ph of priceHistory) {
                            if (ph.date <= yearEnd) {
                                if (!bestDate || ph.date > bestDate) {
                                    bestDate = ph.date;
                                    bestPrice = ph.priceEur;
                                }
                            }
                        }
                        
                        if (bestPrice && bestPrice < 100000) {
                            priceEur = bestPrice;
                            priceSource = `TX ${bestDate?.toISOString().slice(0,10)}`;
                        } else if (tokenPricesFromTx[coin] < 100000) {
                            priceEur = tokenPricesFromTx[coin];
                            priceSource = 'TX (ultimo)';
                        }
                    }
                    
                    // 2. Se non trovato, usa sistema unificato (CryptoCompare ‚Üí CoinGecko)
                    if (priceEur <= 0) {
                        priceEur = getPriceEur(coin, year);
                        if (priceEur > 0) {
                            // Determina fonte per log
                            const ccKey = `${coin.toUpperCase()}_${year}`;
                            priceSource = cryptoComparePriceCache[ccKey] ? 'CryptoCompare' : 'CoinGecko';
                        }
                    }
                    
                    // === SANITY CHECK ===
                    // Se il prezzo sembra assurdo (>‚Ç¨100k per un token sconosciuto), ignora
                    const majorCoins = ['BTC', 'ETH', 'BNB', 'SOL', 'XRP', 'ADA', 'DOGE', 'DOT', 'AVAX', 'LINK'];
                    if (priceEur > 100000 && !majorCoins.includes(coin.toUpperCase())) {
                        console.log(`  ‚ö†Ô∏è SANITY CHECK FAIL: ${coin} prezzo ‚Ç¨${priceEur} ignorato`);
                        priceEur = 0;
                        priceSource = 'Price sanity check failed';
                    }
                    
                    if (priceEur > 0) {
                        const valueEur = amount * priceEur;
                        totalEur += valueEur;
                        details.push({ coin, amount, priceEur, valueEur, source: priceSource });
                        if (valueEur > 0.5) {
                            coinsWithValue.push(`${coin}: ${amount.toFixed(2)} √ó ‚Ç¨${priceEur.toFixed(4)} = ‚Ç¨${valueEur.toFixed(2)} (${priceSource})`);
                        }
                    } else {
                        details.push({ coin, amount, priceEur: 0, valueEur: 0, source: 'No price' });
                        console.log(`  ‚ö†Ô∏è ${year} ${coin}: ${amount.toFixed(4)} - NESSUN PREZZO`);
                    }
                }
                
                yearEndTotals[year] = Math.round(totalEur * 100) / 100;
                data.yearEndDetails[year] = details;
                
                console.log(`\nüìÖ ${year} - Valore al 31/12: ‚Ç¨${yearEndTotals[year]} (TX: ${txByYear[year] || 0})`);
                if (coinsWithValue.length > 0) {
                    for (const c of coinsWithValue) {
                        console.log(`  ${c}`);
                    }
                }
            }
            
            data.balances = yearEndBalances;
            data.totals = yearEndTotals;
            
            console.log('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
            console.log('üìä RIEPILOGO TOTALI (EUR):');
            for (const year of years) {
                if (yearEndTotals[year] !== null && yearEndTotals[year] !== undefined) {
                    const txCount = txByYear[year] || 0;
                    console.log(`  ${year}: ‚Ç¨${yearEndTotals[year]} (${txCount} tx)`);
                }
            }
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        }
        
        function getHistoricalPrice(coin, year, chain = '') {
            const coinUpper = coin.toUpperCase();
            const currentYear = new Date().getFullYear();
            
            // PulseChain cloni = prezzo 0 (solo PLS, PLSX, HEX, INC hanno valore)
            if (chain === 'PulseChain' && !['PLS', 'PLSX', 'HEX', 'INC', 'WPLS'].includes(coinUpper)) {
                return 0;
            }
            
            // Stablecoins - sempre $1
            if (['USDT', 'USDC', 'BUSD', 'FDUSD', 'DAI', 'UST', 'USTC', 'TUSD', 'USDP', 'GUSD', 'PAX', 'FRAX'].includes(coinUpper)) {
                return 1.0;
            }
            
            // EUR token
            if (coinUpper === 'EUR' || coinUpper === 'EUROC' || coinUpper === 'EURT') {
                return 1 / EUR_USD;
            }
            
            // Per anni recenti (corrente e precedente), usa CoinGecko cache se disponibile
            if (year >= currentYear - 1) {
                const cachedPrice = getCachedPrice(coinUpper);
                if (cachedPrice && cachedPrice > 0) {
                    return cachedPrice / EUR_USD; // Converti da EUR a USD
                }
            }
            
            // Usa i prezzi storici dalla YEAR_END_PRICES se disponibili
            const cgId = SYMBOL_TO_CG[coinUpper] || EXTENDED_CG_MAP[coinUpper];
            if (cgId && YEAR_END_PRICES[cgId] && YEAR_END_PRICES[cgId][year]) {
                return YEAR_END_PRICES[cgId][year];
            }
            
            // BTC variations
            if (['BTC', 'WBTC', 'BTCB'].includes(coinUpper)) {
                return YEAR_END_PRICES['bitcoin']?.[year] || 50000;
            }
            
            // ETH variations
            if (['ETH', 'WETH', 'BETH', 'STETH'].includes(coinUpper)) {
                return YEAR_END_PRICES['ethereum']?.[year] || 2000;
            }
            
            // BNB variations  
            if (['BNB', 'WBNB'].includes(coinUpper)) {
                return YEAR_END_PRICES['binancecoin']?.[year] || 300;
            }
            
            // Ultimo fallback: prova CoinGecko cache
            const cachedPrice = getCachedPrice(coinUpper);
            if (cachedPrice && cachedPrice > 0) {
                return cachedPrice / EUR_USD; // Converti da EUR a USD
            }
            
            // Monete molto piccole o sconosciute - log per debug
            // console.log('Unknown coin price:', coinUpper, 'year:', year);
            
            return 0;
        }
        
        function updateExchangeTotals() {
            const years = [2021, 2022, 2023, 2024, 2025, 2026];
            const totals = { 2021: 0, 2022: 0, 2023: 0, 2024: 0, 2025: 0, 2026: 0 };
            
            for (const exchId of Object.keys(exchangeData)) {
                const data = exchangeData[exchId];
                if (data && data.totals) {
                    for (const y of years) {
                        const val = data.totals[y];
                        if (val && !isNaN(val)) {
                            totals[y] += val;
                        }
                    }
                }
            }
            
            // Arrotonda a 2 decimali e gestisci NaN
            for (const y of years) {
                totals[y] = isNaN(totals[y]) ? 0 : Math.round(totals[y] * 100) / 100;
            }
            
            // Aggiorna UI
            for (const y of years) {
                const el = document.getElementById('exchTotal' + y);
                if (el) {
                    el.textContent = '‚Ç¨' + formatEUR(totals[y]);
                }
            }
            
            // Aggiorna exchangeValues per Tax Report
            exchangeValues = totals;
            
            // Aggiorna anche gli input nel Tax Report se visibili
            loadExchangeValuesUI();
        }
        
        function clearExchangeData(exchId) {
            if (!confirm('Cancellare i dati di ' + exchId.toUpperCase() + '?')) return;
            delete exchangeData[exchId];
            initExchangeGrid();
            updateExchangeTotals();
            updateExchangeCount();
            saveExchangeDataToFirebase();
        }
        
        function zeroExchangeData(exchId) {
            if (!confirm('Impostare tutti i valori di ' + exchId.toUpperCase() + ' a ‚Ç¨0?\n(Usa se hai prelevato tutto dall\'exchange)')) return;
            
            // Mantieni la struttura ma azzera tutti i totali
            if (!exchangeData[exchId]) {
                exchangeData[exchId] = {};
            }
            exchangeData[exchId].totals = { 2021: 0, 2022: 0, 2023: 0, 2024: 0, 2025: 0, 2026: 0 };
            exchangeData[exchId].balances = {};
            exchangeData[exchId].transactions = [];
            exchangeData[exchId].transactionCount = 0;
            exchangeData[exchId].isZeroed = true; // Flag per indicare che √® stato azzerato manualmente
            exchangeData[exchId].isManual = true;
            
            initExchangeGrid();
            updateExchangeTotals();
            updateExchangeCount();
            saveExchangeDataToFirebase();
            alert('‚úÖ ' + exchId.toUpperCase() + ' impostato a ‚Ç¨0 per tutti gli anni!');
        }
        
        function updateManualExchangeValue(exchId, year, value) {
            // Aggiorna valore in memoria (non salva ancora)
            if (!exchangeData[exchId]) {
                exchangeData[exchId] = { totals: {}, balances: {}, transactions: [], isManual: true };
            }
            if (!exchangeData[exchId].totals) {
                exchangeData[exchId].totals = {};
            }
            exchangeData[exchId].totals[year] = parseFloat(value) || 0;
            exchangeData[exchId].isManual = true;
            exchangeData[exchId].isZeroed = false;
            
            // Aggiorna totali in tempo reale
            updateExchangeTotals();
        }
        
        function saveManualExchangeValues(exchId) {
            // Leggi tutti i valori dagli input
            const years = [2021, 2022, 2023, 2024, 2025, 2026];
            if (!exchangeData[exchId]) {
                exchangeData[exchId] = { totals: {}, balances: {}, transactions: [], isManual: true };
            }
            
            for (const y of years) {
                const input = document.getElementById('manual-' + exchId + '-' + y);
                if (input) {
                    exchangeData[exchId].totals[y] = parseFloat(input.value) || 0;
                }
            }
            exchangeData[exchId].isManual = true;
            exchangeData[exchId].isZeroed = false;
            exchangeData[exchId].transactionCount = 0; // Non basato su CSV
            
            updateExchangeTotals();
            updateExchangeCount();
            saveExchangeDataToFirebase();
            alert('‚úÖ Valori manuali salvati per ' + exchId.toUpperCase() + '!');
        }
        
        function enableManualEntry(exchId) {
            // Abilita inserimento manuale per exchange senza dati
            if (!exchangeData[exchId]) {
                exchangeData[exchId] = { 
                    totals: { 2021: 0, 2022: 0, 2023: 0, 2024: 0, 2025: 0, 2026: 0 }, 
                    balances: {}, 
                    transactions: [], 
                    isManual: true 
                };
            }
            initExchangeGrid();
        }
        
        async function clearAllExchangeData() {
            if (!confirm('Cancellare TUTTI i dati degli exchange (inclusi dati API vecchi)?')) return;
            exchangeData = {};
            await resetAllBinanceLegacyData();
            initExchangeGrid();
            updateExchangeTotals();
            updateExchangeCount();
            saveExchangeDataToFirebase();
            alert('‚úÖ Tutti i dati exchange cancellati!');
        }
        
        function recalculateAllExchanges() {
            let recalculated = 0;
            for (const exchId of Object.keys(exchangeData)) {
                // Solo ricalcola se ci sono transazioni in memoria
                if (exchangeData[exchId].transactions && exchangeData[exchId].transactions.length > 0) {
                    calculateExchangeBalances(exchId);
                    recalculated++;
                }
            }
            initExchangeGrid();
            updateExchangeTotals();
            updateExchangeCount();
            if (recalculated > 0) {
                saveExchangeDataToFirebase();
                alert('‚úÖ Ricalcolati ' + recalculated + ' exchange!');
            } else {
                alert('‚ö†Ô∏è Nessuna transazione in memoria da ricalcolare.\nI totali salvati sono gi√† visualizzati.');
            }
        }
        
        async function saveExchangeDataToFirebase() {
            // PRIMA salva in localStorage (sempre!)
            saveExchangeTransactionsToLocalStorage();
            
            // POI prova a salvare in Firebase
            try {
                const dataToSave = {};
                for (const exchId of Object.keys(exchangeData)) {
                    const data = exchangeData[exchId];
                    dataToSave[exchId] = {
                        totals: data.totals || {},
                        balances: data.balances || {},
                        realBalances: data.realBalances || null,
                        tokenPrices: data.tokenPrices || null,
                        transactionCount: data.transactions ? data.transactions.length : 0,
                        isZeroed: data.isZeroed || false,
                        isManual: data.isManual || false,
                        lastImport: data.lastImport || new Date().toISOString(),
                        source: data.source || 'manual',
                        // Date range transazioni
                        firstYear: data.firstYear || null,
                        lastYear: data.lastYear || null,
                        firstTxDate: data.firstTxDate ? data.firstTxDate.toISOString() : null,
                        lastTxDate: data.lastTxDate ? data.lastTxDate.toISOString() : null
                    };
                }
                
                await db.collection('cryptofolio').doc('exchanges').set({
                    data: dataToSave,
                    lastUpdate: new Date().toISOString()
                });
                console.log('‚úÖ Exchange data saved to Firebase');
            } catch (e) {
                console.error('Exchange Firebase save error:', e);
            }
        }
        
        function saveExchangeTransactionsToLocalStorage() {
            try {
                // Salva TUTTE le transazioni per riconciliazione
                const txToSave = {};
                let totalSaved = 0;
                
                for (const exchId of Object.keys(exchangeData)) {
                    const data = exchangeData[exchId];
                    if (data.transactions && data.transactions.length > 0) {
                        // Salva tutte le transazioni (max 5000 per exchange)
                        const toSave = data.transactions.slice(0, 5000).map(tx => ({
                            date: tx.date instanceof Date ? tx.date.toISOString() : tx.date,
                            operation: tx.operation || '',
                            type: tx.type || '',
                            coin: tx.coin || '',
                            amount: parseFloat(tx.amount) || Math.abs(parseFloat(tx.change)) || 0,
                            change: parseFloat(tx.change) || 0,
                            amountEur: parseFloat(tx.amountEur) || 0
                        }));
                        
                        txToSave[exchId] = toSave;
                        totalSaved += toSave.length;
                        console.log(`üíæ ${exchId}: ${toSave.length} transazioni`);
                    }
                }
                
                localStorage.setItem('cryptofolio_exchange_tx', JSON.stringify(txToSave));
                console.log(`üíæ Totale ${totalSaved} transazioni salvate in localStorage`);
                
                // Conferma visiva
                if (totalSaved > 0) {
                    console.log('‚úÖ Transazioni pronte per riconciliazione!');
                }
            } catch (e) {
                console.warn('Errore salvataggio transazioni localStorage:', e);
                alert('‚ö†Ô∏è Errore salvataggio: ' + e.message);
            }
        }
        
        function loadExchangeTransactionsFromLocalStorage() {
            try {
                const saved = localStorage.getItem('cryptofolio_exchange_tx');
                if (!saved) return;
                
                const txData = JSON.parse(saved);
                let totalLoaded = 0;
                
                for (const exchId of Object.keys(txData)) {
                    if (!exchangeData[exchId]) {
                        exchangeData[exchId] = { transactions: [], totals: {}, balances: {} };
                    }
                    
                    // Converti date da stringa a Date e assicura amount
                    exchangeData[exchId].transactions = txData[exchId].map(tx => ({
                        ...tx,
                        date: new Date(tx.date),
                        amount: parseFloat(tx.amount) || Math.abs(parseFloat(tx.change)) || 0,
                        change: parseFloat(tx.change) || 0,
                        amountEur: parseFloat(tx.amountEur) || 0
                    }));
                    totalLoaded += txData[exchId].length;
                }
                
                console.log(`üìÇ Caricate ${totalLoaded} transazioni exchange da localStorage`);
            } catch (e) {
                console.warn('Errore caricamento transazioni localStorage:', e);
            }
        }
        
        async function loadExchangeDataFromFirebase() {
            try {
                const doc = await db.collection('cryptofolio').doc('exchanges').get();
                if (doc.exists) {
                    const data = doc.data();
                    const savedData = data.data || {};
                    
                    // Carica solo totali e balances da Firebase
                    for (const exchId of Object.keys(savedData)) {
                        exchangeData[exchId] = {
                            transactions: [], // Vuoto - verr√† caricato da localStorage
                            totals: savedData[exchId].totals || {},
                            balances: savedData[exchId].balances || {},
                            realBalances: savedData[exchId].realBalances || null,
                            tokenPrices: savedData[exchId].tokenPrices || null,
                            transactionCount: savedData[exchId].transactionCount || 0,
                            isZeroed: savedData[exchId].isZeroed || false,
                            isManual: savedData[exchId].isManual || false,
                            lastImport: savedData[exchId].lastImport || null,
                            source: savedData[exchId].source || 'manual',
                            // Date range transazioni
                            firstYear: savedData[exchId].firstYear || null,
                            lastYear: savedData[exchId].lastYear || null,
                            firstTxDate: savedData[exchId].firstTxDate ? new Date(savedData[exchId].firstTxDate) : null,
                            lastTxDate: savedData[exchId].lastTxDate ? new Date(savedData[exchId].lastTxDate) : null
                        };
                    }
                    
                    console.log('‚úÖ Exchange data loaded from Firebase:', Object.keys(exchangeData).length, 'exchanges');
                }
                
                // SEMPRE carica transazioni da localStorage (anche se Firebase √® vuoto)
                loadExchangeTransactionsFromLocalStorage();
                
            } catch (e) {
                console.error('Exchange Firebase load error:', e);
                // Prova comunque a caricare da localStorage
                loadExchangeTransactionsFromLocalStorage();
            }
        }
        
        // ==================== LEGACY CLEANUP ====================
        async function cleanupLegacyBinanceData() {
            // Pulisce i vecchi dati API Binance da Firebase
            try {
                const doc = await db.collection('fiscal').doc('binance_live').get();
                if (doc.exists) {
                    await db.collection('fiscal').doc('binance_live').delete();
                    console.log('üßπ Cleaned up legacy Binance API data from Firebase');
                }
                // Reset local data
                binanceData = { balances: { spot: [], earn: [], staking: [] }, totals: { spot: 0, earn: 0, staking: 0 }, lastUpdate: null };
            } catch (e) {
                console.log('No legacy Binance data to clean');
            }
        }
        
        // Funzioni API Binance rimosse - usiamo solo CSV
        
        function updateExchangeCount() {
            // Conta exchange con dati (transazioni in memoria O dati salvati da Firebase O manuali)
            let count = 0;
            for (const exchId of Object.keys(exchangeData)) {
                const data = exchangeData[exchId];
                const hasTx = data.transactions && data.transactions.length > 0;
                const hasData = hasTx || data.transactionCount > 0 || data.isZeroed || data.isManual || (data.totals && Object.values(data.totals).some(v => v > 0));
                if (hasData) count++;
            }
            document.getElementById('exchangeCount').textContent = count;
        }
        
        async function resetAllBinanceLegacyData() {
            // Resetta i vecchi dati API Binance in Firebase
            binanceData = { balances: { spot: [], earn: [], staking: [] }, totals: { spot: 0, earn: 0, staking: 0 }, lastUpdate: null };
            try {
                await db.collection('fiscal').doc('binance_live').delete();
                console.log('‚úÖ Binance legacy API data deleted');
            } catch(e) {
                console.log('No legacy binance data to delete');
            }
            updateExchangeCount();
        }
        
        // ==================== INIT ====================
        async function init() {
            loadSettings();
            await loadFromFirebase();
            await cleanupLegacyBinanceData(); // Pulisce vecchi dati API
            await loadExchangeDataFromFirebase();
            loadWalletTransactions(); // Carica transazioni wallet
            loadQuadriRWHistory(); // Carica storico Quadri RW
            initChainSelector();
            
            // Forza refresh UI dopo un breve delay (fix timing issues)
            setTimeout(() => {
                initExchangeGrid();
                updateExchangeTotals();
                updateWalletsList();
                console.log('üîÑ UI refreshed after init');
            }, 100);
            
            initExchangeGrid();
            updateBlacklist();
            updateWalletsList();
            updateWalletSelect();
            updateApiCount();
            updateExchangeCount();
            updateExchangeTotals();
            loadNFTDataFromLocalStorage(); // Carica NFT salvati
            
            // Mostra API key se configurata
            if (apiKeys.moralis && apiKeys.etherscan) {
                document.getElementById('apiKey').value = '‚úì Moralis + Etherscan';
            } else if (apiKeys.moralis) {
                document.getElementById('apiKey').value = '‚úì Moralis configurato';
            } else if (apiKeys.etherscan) {
                document.getElementById('apiKey').value = '‚úì Etherscan configurato';
            } else {
                document.getElementById('apiKey').value = '';
                document.getElementById('apiKey').placeholder = '‚ö†Ô∏è Configura API...';
            }
            
            // Mostra risultati salvati se presenti
            if (Object.keys(walletResults).length > 0) {
                aggregateAndDisplay();
                const lastScan = Object.values(walletResults).reduce((latest, w) => 
                    w.scannedAt > latest ? w.scannedAt : latest, 0);
                if (lastScan) {
                    document.getElementById('lastUpdate').textContent = 'Ultimo: ' + new Date(lastScan).toLocaleString('it-IT');
                }
                console.log('üìä Loaded', Object.keys(walletResults).length, 'wallet results from Firebase');
            }
            
            // Check Exchange CSV e aggiorna dashboard
            let exchangeTotalEUR = 0;
            let exchangeNames = [];
            for (const exchId of Object.keys(exchangeData)) {
                const data = exchangeData[exchId];
                if (data && data.totals) {
                    const latestYear = [2025, 2024, 2023, 2022, 2021].find(y => data.totals[y] > 0);
                    if (latestYear && data.totals[latestYear] > 0) {
                        exchangeTotalEUR += data.totals[latestYear];
                        const exchInfo = EXCHANGE_LIST.find(e => e.id === exchId);
                        if (exchInfo) exchangeNames.push(exchInfo.name);
                    }
                }
            }
            
            if (exchangeTotalEUR > 0) {
                document.getElementById('exchangeTotalEUR').textContent = '‚Ç¨' + exchangeTotalEUR.toLocaleString('it-IT', {maximumFractionDigits: 2});
                document.getElementById('exchangeNames').textContent = exchangeNames.join(', ') + ' ‚úì';
                console.log('üí∞ Exchanges loaded: ‚Ç¨' + exchangeTotalEUR.toFixed(2));
                
                // Se non ci sono wallet results, mostra comunque il totale Exchange nel portfolio
                if (Object.keys(walletResults).length === 0) {
                    document.getElementById('totalEUR').textContent = '‚Ç¨' + exchangeTotalEUR.toLocaleString('it-IT', {maximumFractionDigits: 2});
                    document.getElementById('totalUSD').textContent = '$' + (exchangeTotalEUR / EUR_USD).toLocaleString('it-IT', {maximumFractionDigits: 2}) + ' USD';
                }
            }
        }
        
        // ==================== RICONCILIAZIONE v2.0 (SMART) ====================
        
        // Configurazione matching a 3 livelli
        const RECONCILE_CONFIG = {
            // Livello 1: Match per TxHash (100% sicuro)
            TXHASH_MATCH: {
                enabled: true,
                confidence: 1.0
            },
            // Livello 2: Match esatto
            EXACT_MATCH: {
                enabled: true,
                amountTolerance: 0.001,  // 0.1% per fee di rete
                timeWindowMs: 2 * 60 * 60 * 1000,  // 2 ore
                confidence: 0.95
            },
            // Livello 3: Match fuzzy (richiede conferma)
            FUZZY_MATCH: {
                enabled: true,
                amountTolerance: 0.05,   // 5% per fee variabili
                timeWindowMs: 24 * 60 * 60 * 1000,  // 24 ore
                minConfidence: 0.70,
                requiresConfirmation: true
            }
        };
        
        let reconcileData = {
            exchangeTx: [],       // Transazioni exchange (deposit/withdraw crypto)
            walletTx: [],         // Transazioni wallet
            matches: [],          // Match confermati
            pendingMatches: [],   // Match fuzzy da confermare
            unmatchedExch: [],
            unmatchedWallet: [],
            currentYearFilter: 'all',
            currentTab: 'matches'
        };
        
        let reconcileLog = [];
        
        // Logging per riconciliazione
        function rLog(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString('it-IT');
            reconcileLog.push({ timestamp, message, type });
            
            const logContainer = document.getElementById('reconcileLog');
            if (logContainer) {
                const colors = { info: 'var(--text-secondary)', success: 'var(--green)', warning: '#f59e0b', error: 'var(--red)', highlight: 'var(--accent)' };
                logContainer.innerHTML += `<div style="color:${colors[type] || colors.info}">[${timestamp}] ${message}</div>`;
                logContainer.scrollTop = logContainer.scrollHeight;
            }
            console.log(`[Reconcile] ${message}`);
        }
        
        function clearReconcileLog() {
            reconcileLog = [];
            const logContainer = document.getElementById('reconcileLog');
            if (logContainer) {
                logContainer.innerHTML = '<div style="color:var(--text-secondary)">[System] Log cancellato</div>';
            }
        }
        
        // Tab navigation
        function showReconcileTab(tabName) {
            reconcileData.currentTab = tabName;
            
            // Nascondi tutti i tab content
            document.querySelectorAll('.reconcile-tab-content').forEach(el => el.style.display = 'none');
            
            // Mostra tab selezionato
            const tabMap = {
                'matches': 'reconcileTabMatches',
                'pending': 'reconcileTabPending',
                'unmatched': 'reconcileTabUnmatched',
                'log': 'reconcileTabLog'
            };
            const tabEl = document.getElementById(tabMap[tabName]);
            if (tabEl) tabEl.style.display = 'block';
            
            // Aggiorna bottoni
            document.querySelectorAll('.reconcile-tab').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tab === tabName);
                if (btn.dataset.tab === tabName) {
                    btn.style.background = 'var(--accent)';
                    btn.style.color = 'white';
                } else {
                    btn.style.background = 'var(--bg-card)';
                    btn.style.color = 'var(--text-primary)';
                }
            });
        }
        
        // Normalizzazione dati
        function normalizeCoin(coin) {
            if (!coin) return '';
            let normalized = coin.toUpperCase()
                .replace('.LENDING@BINANCE', '')
                .replace('.STAKING@BINANCE', '')
                .replace('LD', '')
                .replace('(BSC)', '')
                .replace('(ERC20)', '')
                .replace('(TRC20)', '')
                .trim();
            const mappings = { 'WETH': 'ETH', 'WBTC': 'BTC', 'WBNB': 'BNB', 'WMATIC': 'MATIC' };
            return mappings[normalized] || normalized;
        }
        
        function normalizeType(type, amount) {
            if (!type) return amount >= 0 ? 'deposit' : 'withdraw';
            const t = type.toLowerCase();
            if (t.includes('withdraw') || t.includes('prelievo') || t.includes('send') || t.includes('crypto_withdrawal')) return 'withdraw';
            if (t.includes('deposit') || t.includes('versamento') || t.includes('receive') || t.includes('crypto_deposit')) return 'deposit';
            return amount >= 0 ? 'deposit' : 'withdraw';
        }
        
        function normalizeTxHash(hash) {
            if (!hash) return null;
            let h = hash.trim();
            if (h.startsWith('0x0x')) h = h.slice(2);
            if (h.length < 10) return null;
            return h.toLowerCase();
        }
        
        // Import CSV Exchange per Riconciliazione (supporta Tatax e Binance)
        async function importExchangeCSVForReconcile(file) {
            if (!file) return;
            
            // RESET dati exchange prima di importare
            reconcileData.exchangeTx = [];
            reconcileData.matches = [];
            reconcileData.unmatchedExch = [];
            reconcileData.unmatchedWallet = [];
            
            const text = await file.text();
            const lines = text.split('\n').filter(l => l.trim());
            
            if (lines.length < 2) {
                alert('‚ùå File CSV vuoto o non valido');
                return;
            }
            
            const header = lines[0].toLowerCase();
            console.log('üìÅ Header CSV:', header);
            
            let imported = 0;
            
            // Formato Tatax: Symbol,TokenAddress,TimeStamp,MovementType,Quantity,...
            if (header.includes('movementtype') || header.includes('symbol')) {
                console.log('üìÅ Rilevato formato Tatax');
                
                for (let i = 1; i < lines.length; i++) {
                    try {
                        // Parse CSV con virgolette
                        const row = lines[i].match(/(".*?"|[^,]+)(?=\s*,|\s*$)/g);
                        if (!row || row.length < 5) continue;
                        
                        const clean = (s) => s ? s.replace(/"/g, '').trim() : '';
                        
                        const symbol = clean(row[0]);
                        const timestamp = clean(row[2]);
                        const moveType = clean(row[3]).toUpperCase();
                        const quantity = parseFloat(clean(row[4])) || 0;
                        
                        // Solo DEPOSIT e WITHDRAWAL crypto (non fiat, non fee)
                        if (!['DEPOSIT', 'WITHDRAWAL'].includes(moveType)) continue;
                        if (['EUR', 'USD', 'GBP'].includes(symbol)) continue;
                        if (Math.abs(quantity) < 0.0000001) continue;
                        
                        reconcileData.exchangeTx.push({
                            source: 'exchange',
                            exchange: 'binance',
                            date: new Date(timestamp),
                            type: moveType === 'WITHDRAWAL' ? 'withdraw' : 'deposit',
                            coin: symbol.replace('.LENDING@BINANCE', '').replace('.STAKING@BINANCE', ''),
                            amount: Math.abs(quantity)
                        });
                        imported++;
                        
                    } catch (e) {
                        // Skip invalid rows
                    }
                }
            }
            // Formato Binance diretto: User_ID,UTC_Time,Account,Operation,Coin,Change,Remark
            else if (header.includes('operation') || header.includes('utc_time')) {
                console.log('üìÅ Rilevato formato Binance');
                
                for (let i = 1; i < lines.length; i++) {
                    try {
                        const row = lines[i].match(/(".*?"|[^,]+)(?=\s*,|\s*$)/g);
                        if (!row || row.length < 6) continue;
                        
                        const clean = (s) => s ? s.replace(/"/g, '').trim() : '';
                        
                        const timestamp = clean(row[1]);
                        const operation = clean(row[3]).toLowerCase();
                        const coin = clean(row[4]);
                        const change = parseFloat(clean(row[5])) || 0;
                        
                        // Solo Deposit e Withdraw
                        if (!operation.includes('deposit') && !operation.includes('withdraw')) continue;
                        if (['EUR', 'USD', 'GBP'].includes(coin)) continue;
                        if (Math.abs(change) < 0.0000001) continue;
                        
                        reconcileData.exchangeTx.push({
                            source: 'exchange',
                            exchange: 'binance',
                            date: new Date(timestamp),
                            type: operation.includes('withdraw') ? 'withdraw' : 'deposit',
                            coin: coin,
                            amount: Math.abs(change)
                        });
                        imported++;
                        
                    } catch (e) {
                        // Skip invalid rows
                    }
                }
            }
            else {
                alert('‚ùå Formato CSV non riconosciuto.\nFormati supportati: Tatax, Binance');
                return;
            }
            
            // Ordina per data
            reconcileData.exchangeTx.sort((a, b) => a.date - b.date);
            
            console.log(`‚úÖ Importate ${imported} transazioni exchange (deposit/withdraw)`);
            
            updateReconcileSummary();
            renderReconcileData();
            saveReconcileToLocalStorage(); // Salva in localStorage
            
            alert(`‚úÖ Importato!\n\n‚Ä¢ ${imported} transazioni exchange (deposit/withdraw crypto)\n‚Ä¢ ${reconcileData.exchangeTx.length} totali\n\nOra clicca "Esegui Riconciliazione" per trovare i match.`);
        }
        
        async function loadReconciliationData() {
            console.log('üîó Caricamento dati per riconciliazione...');
            
            // RESET tutti i dati di riconciliazione
            reconcileData.exchangeTx = [];
            reconcileData.walletTx = [];
            reconcileData.matches = [];
            reconcileData.unmatchedExch = [];
            reconcileData.unmatchedWallet = [];
            
            // Mostra loading
            document.getElementById('reconcileMatches').innerHTML = '<div style="color:var(--text-secondary);text-align:center;padding:40px;">‚è≥ Caricamento in corso...</div>';
            
            // DEBUG: Mostra stato exchangeData
            const exchKeys = Object.keys(exchangeData);
            let debugInfo = `üìä Exchange trovati: ${exchKeys.length}\n`;
            let totalTx = 0;
            
            for (const exchId of exchKeys) {
                const data = exchangeData[exchId];
                const txCount = data.transactions?.length || 0;
                totalTx += txCount;
                debugInfo += `  ‚Ä¢ ${exchId}: ${txCount} transazioni\n`;
            }
            
            console.log(debugInfo);
            
            if (totalTx === 0) {
                // Prova a caricare da localStorage
                console.log('‚ö†Ô∏è Nessuna transazione in memoria, provo localStorage...');
                loadExchangeTransactionsFromLocalStorage();
                
                // Ricontrolla
                totalTx = 0;
                for (const exchId of Object.keys(exchangeData)) {
                    totalTx += exchangeData[exchId].transactions?.length || 0;
                }
                console.log(`üìÇ Dopo localStorage: ${totalTx} transazioni`);
            }
            
            // 1. Carica transazioni Exchange (da exchangeData - CSV gi√† importati)
            console.log('üìä Checking exchangeData:', Object.keys(exchangeData));
            
            for (const exchId of Object.keys(exchangeData)) {
                const data = exchangeData[exchId];
                console.log(`  üìä ${exchId}: ${data.transactions?.length || 0} transazioni`);
                
                if (data.transactions && data.transactions.length > 0) {
                    for (const tx of data.transactions) {
                        // Identifica tipo transazione
                        const operation = (tx.operation || '').toLowerCase();
                        const txType = (tx.type || '').toLowerCase();
                        const coin = tx.coin || '';
                        const change = tx.change || tx.amount || 0;
                        
                        // Escludi fiat
                        if (['EUR', 'USD', 'GBP'].includes(coin.toUpperCase())) continue;
                        
                        // Identifica deposit/withdraw
                        let finalType = null;
                        
                        // Metodo 1: dal campo type (Tatax)
                        if (txType === 'withdrawal' || txType === 'withdraw') {
                            finalType = 'withdraw';
                        } else if (txType === 'deposit') {
                            finalType = 'deposit';
                        }
                        // Metodo 2: dal campo operation (Binance, altri)
                        else if (operation.includes('withdraw') || operation.includes('prelievo') || operation.includes('send')) {
                            finalType = 'withdraw';
                        } else if (operation.includes('deposit') || operation.includes('versamento') || operation.includes('receive')) {
                            finalType = 'deposit';
                        }
                        // Metodo 3: crypto_withdrawal/crypto_deposit (Crypto.com)
                        else if (operation.includes('crypto_withdrawal')) {
                            finalType = 'withdraw';
                        } else if (operation.includes('crypto_deposit')) {
                            finalType = 'deposit';
                        }
                        
                        // Solo deposit e withdraw
                        if (!finalType) continue;
                        
                        const amount = Math.abs(change);
                        if (amount < 0.0000001) continue;
                        
                        reconcileData.exchangeTx.push({
                            source: 'exchange',
                            exchange: exchId,
                            date: tx.date instanceof Date ? tx.date : new Date(tx.date),
                            type: finalType,
                            coin: coin.toUpperCase(),
                            amount: amount,
                            raw: tx
                        });
                    }
                }
            }
            
            console.log(`üìä Exchange TX per riconciliazione: ${reconcileData.exchangeTx.length}`);
            
            // Debug: mostra alcuni esempi
            if (reconcileData.exchangeTx.length > 0) {
                console.log('Sample exchange TX:', reconcileData.exchangeTx.slice(0, 5));
            }
            
            // 2. Carica transazioni Wallet (usa walletTransactions gi√† scaricate!)
            
            // Prima carica da localStorage se non in memoria
            if (Object.keys(walletTransactions).length === 0) {
                loadWalletTransactions();
            }
            
            const walletAddresses = Object.keys(walletResults);
            if (walletAddresses.length === 0) {
                alert(`üìä Dati caricati!\n\n‚Ä¢ ${reconcileData.exchangeTx.length} transazioni exchange (dai CSV)\n\n‚ö†Ô∏è Nessun wallet trovato! Vai su "Wallets" e scansiona almeno un indirizzo.`);
                updateReconcileSummary();
                renderReconcileData();
                return;
            }
            
            console.log(`üìä Caricamento storia per ${walletAddresses.length} wallet...`);
            
            // Usa walletTransactions gi√† scaricate
            let totalWalletTx = 0;
            for (const address of walletAddresses) {
                const addrLower = address.toLowerCase();
                const walletName = walletResults[address]?.name || address.slice(0, 8);
                const txData = walletTransactions[addrLower];
                
                if (!txData) {
                    console.log(`  ‚ö†Ô∏è ${walletName}: nessuna transazione salvata (scansiona il wallet)`);
                    continue;
                }
                
                // Converti nativeTx in formato riconciliazione
                const chainSymbols = { eth: 'ETH', bsc: 'BNB', polygon: 'MATIC', arbitrum: 'ETH', base: 'ETH', cronos: 'CRO', pulse: 'PLS' };
                const chainNames = { eth: 'Ethereum', bsc: 'BSC', polygon: 'Polygon', arbitrum: 'Arbitrum', base: 'Base', cronos: 'Cronos', pulse: 'PulseChain' };
                
                for (const tx of (txData.nativeTx || [])) {
                    reconcileData.walletTx.push({
                        source: 'wallet',
                        wallet: walletName,
                        address: address,
                        chain: chainNames[tx.c] || tx.c,
                        date: new Date(tx.d),
                        type: tx.t === 'in' ? 'receive' : 'send',
                        coin: tx.s || chainSymbols[tx.c] || 'ETH',
                        amount: tx.a,
                        txHash: tx.h
                    });
                }
                
                // Converti tokenTx in formato riconciliazione
                for (const tx of (txData.tokenTx || [])) {
                    reconcileData.walletTx.push({
                        source: 'wallet',
                        wallet: walletName,
                        address: address,
                        chain: chainNames[tx.c] || tx.c,
                        date: new Date(tx.d),
                        type: tx.t === 'in' ? 'receive' : 'send',
                        coin: tx.s || 'UNKNOWN',
                        amount: tx.a,
                        txHash: tx.h
                    });
                }
                
                const txCount = (txData.nativeTx?.length || 0) + (txData.tokenTx?.length || 0);
                totalWalletTx += txCount;
                console.log(`  ‚úÖ ${walletName}: ${txCount} transazioni caricate da cache`);
            }
            
            // Se non ci sono transazioni salvate, avvisa l'utente
            if (totalWalletTx === 0) {
                alert(`üìä Dati caricati!\n\n‚Ä¢ ${reconcileData.exchangeTx.length} transazioni exchange\n‚Ä¢ 0 transazioni wallet\n\n‚ö†Ô∏è Scansiona i wallet dalla sezione "Wallets" per scaricare le transazioni!`);
            } else {
                alert(`‚úÖ Caricamento completato!\n\n‚Ä¢ ${reconcileData.exchangeTx.length} transazioni exchange\n‚Ä¢ ${totalWalletTx} transazioni wallet\n\nOra clicca "Esegui Riconciliazione" per trovare i match.`);
            }
            
            reconcileData.walletTx.sort((a, b) => b.date - a.date);
            console.log(`üìä Wallet TX totali: ${reconcileData.walletTx.length}`);
            
            updateReconcileSummary();
            renderReconcileData();
            
            // Salva in localStorage
            saveReconcileToLocalStorage();
        }
        
        function runSmartReconciliation() {
            rLog('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'highlight');
            rLog('AVVIO RICONCILIAZIONE SMART v2.0', 'highlight');
            rLog('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'highlight');
            
            // Controllo dati
            if (reconcileData.exchangeTx.length === 0 && reconcileData.walletTx.length === 0) {
                alert('‚ö†Ô∏è Nessun dato da riconciliare!\n\n1. Clicca "Carica Dati" prima\n2. Poi clicca "Esegui Riconciliazione"');
                return;
            }
            
            if (reconcileData.exchangeTx.length === 0) {
                alert('‚ö†Ô∏è Mancano le transazioni Exchange!\n\nVai su "Exchanges" e importa i CSV.');
                return;
            }
            
            if (reconcileData.walletTx.length === 0) {
                alert('‚ö†Ô∏è Mancano le transazioni Wallet!\n\nClicca "Carica Dati" per scaricare la storia dei tuoi wallet.');
                return;
            }
            
            // Reset risultati
            reconcileData.matches = [];
            reconcileData.pendingMatches = [];
            reconcileData.unmatchedExch = [];
            reconcileData.unmatchedWallet = [];
            
            // Segna tutte le transazioni come non-matched
            reconcileData.exchangeTx.forEach(tx => { tx._matched = false; tx._matchId = null; });
            reconcileData.walletTx.forEach(tx => { tx._matched = false; tx._matchId = null; });
            
            rLog(`Transazioni Exchange: ${reconcileData.exchangeTx.length}`, 'info');
            rLog(`Transazioni Wallet: ${reconcileData.walletTx.length}`, 'info');
            
            // Helper functions
            const isWithdraw = (type) => ['withdraw', 'withdrawal', 'send'].includes((type || '').toLowerCase());
            const isDeposit = (type) => ['deposit', 'receive', 'credit'].includes((type || '').toLowerCase());
            
            let matchIdCounter = 1;
            
            // ===== LIVELLO 1: Match per TxHash =====
            if (RECONCILE_CONFIG.TXHASH_MATCH.enabled) {
                rLog('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ', 'info');
                rLog('LIVELLO 1: Match per TxHash (100% sicuro)', 'info');
                
                const walletByHash = new Map();
                reconcileData.walletTx.forEach(tx => {
                    if (tx.txHash && !tx._matched) {
                        walletByHash.set(tx.txHash.toLowerCase(), tx);
                    }
                });
                
                let txHashMatches = 0;
                for (const exchTx of reconcileData.exchangeTx) {
                    if (exchTx._matched || !exchTx.txHash) continue;
                    
                    const walletMatch = walletByHash.get(exchTx.txHash.toLowerCase());
                    if (walletMatch && !walletMatch._matched) {
                        const isValidPair = 
                            (isWithdraw(exchTx.type) && isDeposit(walletMatch.type)) ||
                            (isDeposit(exchTx.type) && isWithdraw(walletMatch.type));
                        
                        const exchCoin = normalizeCoin(exchTx.coin);
                        const walletCoin = normalizeCoin(walletMatch.coin);
                        
                        if (isValidPair && exchCoin === walletCoin) {
                            const matchId = `MATCH_${matchIdCounter++}`;
                            exchTx._matched = true;
                            exchTx._matchId = matchId;
                            walletMatch._matched = true;
                            walletMatch._matchId = matchId;
                            
                            reconcileData.matches.push({
                                id: matchId,
                                type: 'txhash',
                                exchange: exchTx,
                                wallet: walletMatch,
                                confidence: RECONCILE_CONFIG.TXHASH_MATCH.confidence,
                                timeDiff: 0,
                                coin: exchCoin,
                                amount: exchTx.amount,
                                direction: isWithdraw(exchTx.type) ? 'exchange_to_wallet' : 'wallet_to_exchange'
                            });
                            txHashMatches++;
                            rLog(`üîí TxHash match: ${exchCoin} ${exchTx.amount.toFixed(6)}`, 'success');
                        }
                    }
                }
                rLog(`Livello 1 completato: ${txHashMatches} match`, 'success');
            }
            
            // ===== LIVELLO 2: Match Esatto =====
            if (RECONCILE_CONFIG.EXACT_MATCH.enabled) {
                rLog('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ', 'info');
                rLog('LIVELLO 2: Match esatto (¬±0.1%, ¬±2h)', 'info');
                
                const config = RECONCILE_CONFIG.EXACT_MATCH;
                let exactMatches = 0;
                
                for (const exchTx of reconcileData.exchangeTx) {
                    if (exchTx._matched) continue;
                    
                    const targetType = isWithdraw(exchTx.type) ? 'deposit' : 'send';
                    const exchCoin = normalizeCoin(exchTx.coin);
                    const exchTime = (exchTx.date instanceof Date ? exchTx.date : new Date(exchTx.date)).getTime();
                    
                    for (const walletTx of reconcileData.walletTx) {
                        if (walletTx._matched) continue;
                        
                        const walletCoin = normalizeCoin(walletTx.coin);
                        if (exchCoin !== walletCoin) continue;
                        
                        const matchesType = isWithdraw(exchTx.type) ? isDeposit(walletTx.type) : isWithdraw(walletTx.type);
                        if (!matchesType) continue;
                        
                        // Check importo
                        if (exchTx.amount <= 0 || walletTx.amount <= 0) continue;
                        const amountDiff = Math.abs(exchTx.amount - walletTx.amount) / Math.max(exchTx.amount, walletTx.amount);
                        if (amountDiff > config.amountTolerance) continue;
                        
                        // Check tempo
                        const walletTime = (walletTx.date instanceof Date ? walletTx.date : new Date(walletTx.date)).getTime();
                        const timeDiff = Math.abs(exchTime - walletTime);
                        
                        let validTiming = false;
                        if (isWithdraw(exchTx.type)) {
                            validTiming = walletTime >= exchTime && timeDiff <= config.timeWindowMs;
                        } else {
                            validTiming = walletTime <= exchTime && timeDiff <= config.timeWindowMs;
                        }
                        if (!validTiming) continue;
                        
                        // Match!
                        const matchId = `MATCH_${matchIdCounter++}`;
                        exchTx._matched = true;
                        exchTx._matchId = matchId;
                        walletTx._matched = true;
                        walletTx._matchId = matchId;
                        
                        reconcileData.matches.push({
                            id: matchId,
                            type: 'exact',
                            exchange: exchTx,
                            wallet: walletTx,
                            confidence: config.confidence,
                            timeDiff: Math.round(timeDiff / 60000),
                            coin: exchCoin,
                            amount: exchTx.amount,
                            direction: isWithdraw(exchTx.type) ? 'exchange_to_wallet' : 'wallet_to_exchange'
                        });
                        exactMatches++;
                        rLog(`‚úì Exact match: ${exchCoin} ${exchTx.amount.toFixed(6)} (diff ${(amountDiff*100).toFixed(2)}%, ${Math.round(timeDiff/60000)}min)`, 'success');
                        break;
                    }
                }
                rLog(`Livello 2 completato: ${exactMatches} match`, 'success');
            }
            
            // ===== LIVELLO 3: Match Fuzzy =====
            if (RECONCILE_CONFIG.FUZZY_MATCH.enabled) {
                rLog('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ', 'info');
                rLog('LIVELLO 3: Match fuzzy (¬±5%, ¬±24h)', 'info');
                
                const config = RECONCILE_CONFIG.FUZZY_MATCH;
                let fuzzyFound = 0;
                
                for (const exchTx of reconcileData.exchangeTx) {
                    if (exchTx._matched) continue;
                    
                    const exchCoin = normalizeCoin(exchTx.coin);
                    const exchTime = (exchTx.date instanceof Date ? exchTx.date : new Date(exchTx.date)).getTime();
                    
                    let bestMatch = null;
                    let bestConfidence = 0;
                    
                    for (const walletTx of reconcileData.walletTx) {
                        if (walletTx._matched) continue;
                        
                        const walletCoin = normalizeCoin(walletTx.coin);
                        if (exchCoin !== walletCoin) continue;
                        
                        const matchesType = isWithdraw(exchTx.type) ? isDeposit(walletTx.type) : isWithdraw(walletTx.type);
                        if (!matchesType) continue;
                        
                        if (exchTx.amount <= 0 || walletTx.amount <= 0) continue;
                        const amountDiff = Math.abs(exchTx.amount - walletTx.amount) / Math.max(exchTx.amount, walletTx.amount);
                        if (amountDiff > config.amountTolerance) continue;
                        
                        const walletTime = (walletTx.date instanceof Date ? walletTx.date : new Date(walletTx.date)).getTime();
                        const timeDiff = Math.abs(exchTime - walletTime);
                        if (timeDiff > config.timeWindowMs) continue;
                        
                        // Calcola confidence
                        const amountScore = 1 - (amountDiff / config.amountTolerance);
                        const timeScore = 1 - (timeDiff / config.timeWindowMs);
                        const confidence = (amountScore * 0.6 + timeScore * 0.4);
                        
                        if (confidence >= config.minConfidence && confidence > bestConfidence) {
                            bestMatch = walletTx;
                            bestConfidence = confidence;
                        }
                    }
                    
                    if (bestMatch) {
                        // Aggiungi a pending per conferma manuale
                        reconcileData.pendingMatches.push({
                            id: `PENDING_${fuzzyFound}`,
                            exchange: exchTx,
                            wallet: bestMatch,
                            type: 'fuzzy',
                            confidence: bestConfidence,
                            coin: exchCoin,
                            amount: exchTx.amount
                        });
                        fuzzyFound++;
                        rLog(`~ Fuzzy match: ${exchCoin} ${exchTx.amount.toFixed(6)} (confidence ${(bestConfidence*100).toFixed(0)}%)`, 'warning');
                    }
                }
                rLog(`Livello 3 completato: ${fuzzyFound} match da verificare`, 'warning');
            }
            
            // Raccogli non riconciliati
            reconcileData.unmatchedExch = reconcileData.exchangeTx.filter(tx => !tx._matched && 
                !reconcileData.pendingMatches.some(p => p.exchange === tx));
            reconcileData.unmatchedWallet = reconcileData.walletTx.filter(tx => !tx._matched &&
                !reconcileData.pendingMatches.some(p => p.wallet === tx));
            
            // Report finale
            rLog('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'highlight');
            rLog('RICONCILIAZIONE COMPLETATA', 'highlight');
            rLog(`‚úÖ Match confermati: ${reconcileData.matches.length}`, 'success');
            rLog(`‚è≥ Da verificare: ${reconcileData.pendingMatches.length}`, 'warning');
            rLog(`‚ùì Exchange non riconciliati: ${reconcileData.unmatchedExch.length}`, 'info');
            rLog(`‚ùì Wallet non riconciliati: ${reconcileData.unmatchedWallet.length}`, 'info');
            rLog('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'highlight');
            
            // Aggiorna UI
            updateReconcileSummary();
            renderAllReconcileViews();
            saveReconcileToLocalStorage();
            
            // Mostra tab appropriate
            if (reconcileData.pendingMatches.length > 0) {
                showReconcileTab('pending');
                alert(`‚úÖ Riconciliazione completata!\n\n‚Ä¢ Match confermati: ${reconcileData.matches.length}\n‚Ä¢ Da verificare: ${reconcileData.pendingMatches.length}\n‚Ä¢ Non riconciliati: ${reconcileData.unmatchedExch.length + reconcileData.unmatchedWallet.length}\n\n‚ö†Ô∏è Hai ${reconcileData.pendingMatches.length} match da confermare!`);
            } else {
                showReconcileTab('matches');
                alert(`‚úÖ Riconciliazione completata!\n\n‚Ä¢ Match confermati: ${reconcileData.matches.length}\n‚Ä¢ Non riconciliati: ${reconcileData.unmatchedExch.length + reconcileData.unmatchedWallet.length}`);
            }
        }
        
        // Mantieni compatibilit√† con vecchio nome
        function runReconciliation() {
            runSmartReconciliation();
        }
        
        function updateReconcileSummary() {
            document.getElementById('reconcileExchCount').textContent = reconcileData.exchangeTx.length;
            document.getElementById('reconcileWalletCount').textContent = reconcileData.walletTx.length;
            document.getElementById('reconcileMatchCount').textContent = reconcileData.matches.length;
            
            const pendingEl = document.getElementById('reconcilePendingCount');
            if (pendingEl) pendingEl.textContent = reconcileData.pendingMatches?.length || 0;
            
            document.getElementById('reconcileUnmatchedCount').textContent = 
                reconcileData.unmatchedExch.length + reconcileData.unmatchedWallet.length;
            
            // Badges
            document.getElementById('matchCountBadge').textContent = reconcileData.matches.length;
            
            const pendingBadge = document.getElementById('pendingCountBadge');
            if (pendingBadge) pendingBadge.textContent = reconcileData.pendingMatches?.length || 0;
            
            document.getElementById('unmatchedCountBadge').textContent = 
                reconcileData.unmatchedExch.length + reconcileData.unmatchedWallet.length;
        }
        
        function renderAllReconcileViews() {
            renderMatchesView();
            renderPendingView();
            renderUnmatchedView();
        }
        
        function renderMatchesView() {
            const container = document.getElementById('reconcileMatches');
            if (!container) return;
            
            // Applica filtri
            const typeFilter = document.getElementById('matchTypeFilter')?.value || 'all';
            const yearFilter = document.getElementById('matchYearFilter')?.value || 'all';
            
            let filtered = reconcileData.matches;
            
            if (typeFilter !== 'all') {
                filtered = filtered.filter(m => m.type === typeFilter);
            }
            
            if (yearFilter !== 'all') {
                filtered = filtered.filter(m => {
                    const year = (m.exchange?.date instanceof Date ? m.exchange.date : new Date(m.exchange?.date)).getFullYear();
                    return year.toString() === yearFilter;
                });
            }
            
            if (filtered.length === 0) {
                container.innerHTML = `
                    <div style="color:var(--text-secondary);text-align:center;padding:60px;">
                        <div style="font-size:48px;margin-bottom:16px;opacity:0.5;">üîó</div>
                        <div style="font-size:16px;font-weight:600;margin-bottom:8px;">Nessun match trovato</div>
                        <div style="font-size:13px;">Prova a cambiare i filtri o esegui la riconciliazione</div>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = filtered.map(m => {
                const exchDate = m.exchange?.date instanceof Date ? m.exchange.date : new Date(m.exchange?.date);
                const walletDate = m.wallet?.date instanceof Date ? m.wallet.date : new Date(m.wallet?.date);
                const confidenceClass = m.confidence >= 0.95 ? 'var(--green)' : m.confidence >= 0.8 ? '#f59e0b' : 'var(--red)';
                const typeIcon = m.type === 'txhash' ? 'üîí' : m.type === 'exact' ? '‚úì' : '~';
                const typeLabel = m.type === 'txhash' ? 'TxHash' : m.type === 'exact' ? 'Exact' : 'Fuzzy';
                
                return `
                    <div style="display:grid;grid-template-columns:1fr auto 1fr auto;align-items:center;gap:16px;padding:16px;border-bottom:1px solid var(--border);background:rgba(16,185,129,0.03);">
                        <div style="padding:12px;border-radius:8px;background:rgba(243,186,47,0.1);border-left:3px solid #f3ba2f;">
                            <div style="font-size:11px;color:#f3ba2f;text-transform:uppercase;margin-bottom:4px;">üè¶ ${m.exchange?.exchange || 'Exchange'}</div>
                            <div style="font-size:16px;font-weight:700;font-family:monospace;">
                                ${m.exchange?.type === 'withdraw' ? 'üì§' : 'üì•'} ${(m.exchange?.amount || 0).toFixed(6)} ${m.coin || ''}
                            </div>
                            <div style="font-size:12px;color:var(--text-secondary);margin-top:4px;">${exchDate.toLocaleString('it-IT')}</div>
                        </div>
                        <div style="font-size:24px;color:var(--green);">‚ÜîÔ∏è</div>
                        <div style="padding:12px;border-radius:8px;background:rgba(108,92,231,0.1);border-left:3px solid var(--accent);">
                            <div style="font-size:11px;color:var(--accent);text-transform:uppercase;margin-bottom:4px;">üëõ Wallet</div>
                            <div style="font-size:16px;font-weight:700;font-family:monospace;">
                                ${m.wallet?.type === 'receive' || m.wallet?.type === 'deposit' ? 'üì•' : 'üì§'} ${(m.wallet?.amount || 0).toFixed(6)} ${m.wallet?.coin || ''}
                            </div>
                            <div style="font-size:12px;color:var(--text-secondary);margin-top:4px;">${walletDate.toLocaleString('it-IT')}</div>
                        </div>
                        <div style="text-align:center;padding:8px 16px;">
                            <div style="font-size:24px;font-weight:700;font-family:monospace;color:${confidenceClass};">
                                ${Math.round(m.confidence * 100)}%
                            </div>
                            <div style="font-size:11px;color:var(--text-secondary);">${typeIcon} ${typeLabel}</div>
                            ${m.timeDiff ? `<div style="font-size:10px;color:var(--text-secondary);">${m.timeDiff}min</div>` : ''}
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        function renderPendingView() {
            const container = document.getElementById('reconcilePending');
            if (!container) return;
            
            if (!reconcileData.pendingMatches || reconcileData.pendingMatches.length === 0) {
                container.innerHTML = `
                    <div style="color:var(--text-secondary);text-align:center;padding:60px;">
                        <div style="font-size:48px;margin-bottom:16px;opacity:0.5;">‚ú®</div>
                        <div style="font-size:16px;font-weight:600;margin-bottom:8px;">Nessun match in attesa</div>
                        <div style="font-size:13px;">I match fuzzy appariranno qui per la tua conferma</div>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = reconcileData.pendingMatches.map((m, i) => {
                const exchDate = m.exchange?.date instanceof Date ? m.exchange.date : new Date(m.exchange?.date);
                const walletDate = m.wallet?.date instanceof Date ? m.wallet.date : new Date(m.wallet?.date);
                
                return `
                    <div style="display:grid;grid-template-columns:1fr auto 1fr auto auto;align-items:center;gap:16px;padding:16px;border-bottom:1px solid var(--border);background:rgba(245,158,11,0.03);border-left:3px solid #f59e0b;">
                        <div style="padding:12px;border-radius:8px;background:rgba(243,186,47,0.1);">
                            <div style="font-size:11px;color:#f3ba2f;text-transform:uppercase;margin-bottom:4px;">üè¶ ${m.exchange?.exchange || 'Exchange'}</div>
                            <div style="font-size:16px;font-weight:700;font-family:monospace;">
                                ${m.exchange?.type === 'withdraw' ? 'üì§' : 'üì•'} ${(m.exchange?.amount || 0).toFixed(6)} ${m.coin || ''}
                            </div>
                            <div style="font-size:12px;color:var(--text-secondary);margin-top:4px;">${exchDate.toLocaleString('it-IT')}</div>
                        </div>
                        <div style="font-size:24px;color:#f59e0b;">‚ùì</div>
                        <div style="padding:12px;border-radius:8px;background:rgba(108,92,231,0.1);">
                            <div style="font-size:11px;color:var(--accent);text-transform:uppercase;margin-bottom:4px;">üëõ Wallet</div>
                            <div style="font-size:16px;font-weight:700;font-family:monospace;">
                                ${m.wallet?.type === 'receive' || m.wallet?.type === 'deposit' ? 'üì•' : 'üì§'} ${(m.wallet?.amount || 0).toFixed(6)} ${m.wallet?.coin || ''}
                            </div>
                            <div style="font-size:12px;color:var(--text-secondary);margin-top:4px;">${walletDate.toLocaleString('it-IT')}</div>
                        </div>
                        <div style="text-align:center;padding:8px;">
                            <div style="font-size:24px;font-weight:700;font-family:monospace;color:#f59e0b;">
                                ${Math.round(m.confidence * 100)}%
                            </div>
                            <div style="font-size:11px;color:var(--text-secondary);">~ FUZZY</div>
                        </div>
                        <div style="display:flex;flex-direction:column;gap:8px;">
                            <button class="btn btn-secondary" onclick="confirmPendingMatch(${i})" style="background:var(--green);color:#000;padding:8px 12px;font-size:12px;">‚úÖ Conferma</button>
                            <button class="btn btn-secondary" onclick="rejectPendingMatch(${i})" style="background:var(--red);color:#fff;padding:8px 12px;font-size:12px;">‚ùå Rifiuta</button>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        function renderUnmatchedView() {
            // Exchange non riconciliati
            const exchContainer = document.getElementById('unmatchedExchange');
            if (exchContainer) {
                if (reconcileData.unmatchedExch.length === 0) {
                    exchContainer.innerHTML = '<div style="color:var(--text-secondary);text-align:center;padding:20px;">‚úÖ Tutti riconciliati!</div>';
                } else {
                    exchContainer.innerHTML = reconcileData.unmatchedExch.map(tx => {
                        const date = tx.date instanceof Date ? tx.date : new Date(tx.date);
                        return `
                            <div style="padding:10px;border-bottom:1px solid var(--border);display:flex;justify-content:space-between;align-items:center;">
                                <div>
                                    <span style="color:${tx.type === 'withdraw' ? 'var(--red)' : 'var(--green)'}">${tx.type === 'withdraw' ? 'üì§' : 'üì•'}</span>
                                    <strong>${tx.coin}</strong> ${tx.amount?.toFixed(6) || '0'}
                                </div>
                                <div style="color:var(--text-secondary);font-size:11px;">${date.toLocaleDateString('it-IT')}</div>
                            </div>
                        `;
                    }).join('');
                }
            }
            
            // Wallet non riconciliati
            const walletContainer = document.getElementById('unmatchedWallet');
            if (walletContainer) {
                if (reconcileData.unmatchedWallet.length === 0) {
                    walletContainer.innerHTML = '<div style="color:var(--text-secondary);text-align:center;padding:20px;">‚úÖ Tutti riconciliati!</div>';
                } else {
                    walletContainer.innerHTML = reconcileData.unmatchedWallet.map(tx => {
                        const date = tx.date instanceof Date ? tx.date : new Date(tx.date);
                        return `
                            <div style="padding:10px;border-bottom:1px solid var(--border);display:flex;justify-content:space-between;align-items:center;">
                                <div>
                                    <span style="color:${tx.type === 'send' || tx.type === 'withdraw' ? 'var(--red)' : 'var(--green)'}">${tx.type === 'send' || tx.type === 'withdraw' ? 'üì§' : 'üì•'}</span>
                                    <strong>${tx.coin}</strong> ${tx.amount?.toFixed(6) || '0'}
                                </div>
                                <div style="color:var(--text-secondary);font-size:11px;">${date.toLocaleDateString('it-IT')}</div>
                            </div>
                        `;
                    }).join('');
                }
            }
        }
        
        function filterMatches() {
            renderMatchesView();
        }
        
        // Azioni su pending matches
        function confirmPendingMatch(index) {
            const pending = reconcileData.pendingMatches[index];
            if (!pending) return;
            
            // Marca come matched
            pending.exchange._matched = true;
            pending.wallet._matched = true;
            
            // Sposta in matches confermati
            reconcileData.matches.push({
                ...pending,
                type: 'fuzzy_confirmed'
            });
            
            // Rimuovi da pending
            reconcileData.pendingMatches.splice(index, 1);
            
            rLog(`‚úÖ Match confermato: ${pending.coin} ${pending.amount?.toFixed(6)}`, 'success');
            
            updateReconcileSummary();
            renderAllReconcileViews();
            saveReconcileToLocalStorage();
        }
        
        function rejectPendingMatch(index) {
            const pending = reconcileData.pendingMatches[index];
            if (!pending) return;
            
            // Rimuovi da pending
            reconcileData.pendingMatches.splice(index, 1);
            
            // Aggiungi ai non riconciliati
            reconcileData.unmatchedExch.push(pending.exchange);
            reconcileData.unmatchedWallet.push(pending.wallet);
            
            rLog(`‚ùå Match rifiutato: ${pending.coin} ${pending.amount?.toFixed(6)}`, 'warning');
            
            updateReconcileSummary();
            renderAllReconcileViews();
            saveReconcileToLocalStorage();
        }
        
        function confirmAllPendingMatches() {
            if (!reconcileData.pendingMatches || reconcileData.pendingMatches.length === 0) return;
            
            if (!confirm(`Confermare tutti i ${reconcileData.pendingMatches.length} match in attesa?`)) return;
            
            while (reconcileData.pendingMatches.length > 0) {
                confirmPendingMatch(0);
            }
        }
        
        function rejectAllPendingMatches() {
            if (!reconcileData.pendingMatches || reconcileData.pendingMatches.length === 0) return;
            
            if (!confirm(`Rifiutare tutti i ${reconcileData.pendingMatches.length} match in attesa?`)) return;
            
            while (reconcileData.pendingMatches.length > 0) {
                rejectPendingMatch(0);
            }
        }
        
        function filterReconcileYear(year) {
            reconcileData.currentYearFilter = year;
            
            // Aggiorna bottoni
            document.querySelectorAll('.reconcile-year-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.year === year) btn.classList.add('active');
            });
            
            renderReconcileData();
        }
        
        function renderReconcileData() {
            // Usa le nuove funzioni di rendering
            renderAllReconcileViews();
        }
        
        function resetReconciliationData() {
            if (!confirm('Sei sicuro di voler cancellare tutti i dati di riconciliazione?')) return;
            
            reconcileData.exchangeTx = [];
            reconcileData.walletTx = [];
            reconcileData.matches = [];
            reconcileData.pendingMatches = [];
            reconcileData.unmatchedExch = [];
            reconcileData.unmatchedWallet = [];
            
            // Cancella anche da localStorage
            localStorage.removeItem('reconcileData');
            
            // Reset log
            clearReconcileLog();
            rLog('Dati riconciliazione cancellati', 'info');
            
            updateReconcileSummary();
            renderReconcileData();
            
            alert('‚úÖ Dati riconciliazione cancellati!');
        }
        
        function saveReconcileToLocalStorage() {
            try {
                // Salva tutti i dati della riconciliazione (inclusi i match!)
                const dataToSave = {
                    exchangeTx: reconcileData.exchangeTx.map(tx => ({
                        ...tx,
                        date: tx.date instanceof Date ? tx.date.toISOString() : tx.date,
                        raw: undefined // Rimuovi oggetti complessi
                    })),
                    walletTx: reconcileData.walletTx.map(tx => ({
                        ...tx,
                        date: tx.date instanceof Date ? tx.date.toISOString() : tx.date
                    })),
                    matches: reconcileData.matches.map(m => ({
                        type: m.type,
                        confidence: m.confidence,
                        timeDiff: m.timeDiff,
                        exchange: m.exchange ? {
                            ...m.exchange,
                            date: m.exchange.date instanceof Date ? m.exchange.date.toISOString() : m.exchange.date,
                            raw: undefined
                        } : null,
                        wallet: m.wallet ? {
                            ...m.wallet,
                            date: m.wallet.date instanceof Date ? m.wallet.date.toISOString() : m.wallet.date
                        } : null
                    })),
                    unmatchedExch: reconcileData.unmatchedExch.map(tx => ({
                        ...tx,
                        date: tx.date instanceof Date ? tx.date.toISOString() : tx.date,
                        raw: undefined
                    })),
                    unmatchedWallet: reconcileData.unmatchedWallet.map(tx => ({
                        ...tx,
                        date: tx.date instanceof Date ? tx.date.toISOString() : tx.date
                    })),
                    savedAt: new Date().toISOString()
                };
                localStorage.setItem('reconcileData', JSON.stringify(dataToSave));
                console.log(`üíæ Riconciliazione salvata: ${reconcileData.matches.length} match`);
            } catch (e) {
                console.warn('Errore salvataggio localStorage:', e);
            }
        }
        
        function loadReconcileFromLocalStorage() {
            try {
                const saved = localStorage.getItem('reconcileData');
                if (!saved) return false;
                
                const data = JSON.parse(saved);
                
                reconcileData.exchangeTx = (data.exchangeTx || []).map(tx => ({
                    ...tx,
                    date: new Date(tx.date)
                }));
                reconcileData.walletTx = (data.walletTx || []).map(tx => ({
                    ...tx,
                    date: new Date(tx.date)
                }));
                reconcileData.matches = (data.matches || []).map(m => ({
                    ...m,
                    exchange: m.exchange ? { ...m.exchange, date: new Date(m.exchange.date) } : null,
                    wallet: m.wallet ? { ...m.wallet, date: new Date(m.wallet.date) } : null
                }));
                reconcileData.unmatchedExch = (data.unmatchedExch || []).map(tx => ({
                    ...tx,
                    date: new Date(tx.date)
                }));
                reconcileData.unmatchedWallet = (data.unmatchedWallet || []).map(tx => ({
                    ...tx,
                    date: new Date(tx.date)
                }));
                
                console.log(`üìÇ Caricati da localStorage: ${reconcileData.exchangeTx.length} exchange, ${reconcileData.walletTx.length} wallet, ${reconcileData.matches.length} match`);
                return true;
            } catch (e) {
                console.warn('Errore caricamento localStorage:', e);
                return false;
            }
        }
        
        // ==================== NFT FUNCTIONS ====================
        async function scanAllNFTs() {
            const walletAddresses = Object.keys(walletResults);
            if (walletAddresses.length === 0) {
                alert('‚ö†Ô∏è Nessun wallet trovato!\nVai su "Wallets" e scansiona almeno un indirizzo.');
                return;
            }
            
            const moralisKey = getMoralisKey();
            if (!moralisKey) {
                alert('‚ö†Ô∏è Configura la Moralis API key in "API Connect" per scansionare gli NFT!');
                return;
            }
            
            document.getElementById('nftGrid').innerHTML = '<div style="color:var(--text-secondary);text-align:center;padding:40px;grid-column:1/-1;">‚è≥ Scansione NFT in corso...</div>';
            
            nftData = [];
            
            // Chain da scansionare (EVM)
            const evmChains = [
                { key: 'eth', id: '0x1', name: 'Ethereum' },
                { key: 'polygon', id: '0x89', name: 'Polygon' },
                { key: 'bsc', id: '0x38', name: 'BSC' },
                { key: 'arbitrum', id: '0xa4b1', name: 'Arbitrum' },
                { key: 'base', id: '0x2105', name: 'Base' }
            ];
            
            for (const address of walletAddresses) {
                const walletName = walletResults[address]?.name || address.slice(0, 8);
                console.log(`üñºÔ∏è Scansione NFT per ${walletName}...`);
                
                // Determina se √® EVM o Solana
                if (address.startsWith('0x')) {
                    // EVM - scansiona tutte le chain
                    for (const chain of evmChains) {
                        try {
                            const nfts = await fetchNFTsFromMoralis(address, chain.id, chain.name, walletName);
                            if (nfts && nfts.length > 0) {
                                nftData.push(...nfts);
                                console.log(`  ‚úÖ ${chain.name}: ${nfts.length} NFT`);
                            }
                        } catch (e) {
                            console.warn(`  ‚ö†Ô∏è Errore ${chain.name}:`, e);
                        }
                    }
                } else if (address.length > 30) {
                    // Solana
                    try {
                        const nfts = await fetchNFTsFromHelius(address, walletName);
                        if (nfts && nfts.length > 0) {
                            nftData.push(...nfts);
                            console.log(`  ‚úÖ Solana: ${nfts.length} NFT`);
                        }
                    } catch (e) {
                        console.warn('  ‚ö†Ô∏è Errore Solana:', e);
                    }
                }
            }
            
            // Carica prezzi di acquisto da localStorage
            loadNFTPurchasePrices();
            
            // Aggiorna UI
            updateNFTSummary();
            renderNFTGrid();
            saveNFTDataToLocalStorage();
            
            alert(`‚úÖ Scansione completata!\n\nTrovati ${nftData.length} NFT`);
        }
        
        async function fetchNFTsFromMoralis(address, chainId, chainName, walletName, retryCount = 0) {
            const moralisKey = getMoralisKey();
            if (!moralisKey) return [];
            
            try {
                const url = `https://deep-index.moralis.io/api/v2.2/${address}/nft?chain=${chainId}&format=decimal&media_items=true`;
                const response = await fetch(url, {
                    headers: { 'X-API-Key': moralisKey }
                });
                
                // Rate limit handling
                if (response.status === 429 || response.status === 400) {
                    if (rotateMoralisKey('rate limit') && retryCount < moralisKeys.length) {
                        return fetchNFTsFromMoralis(address, chainId, chainName, walletName, retryCount + 1);
                    }
                    return [];
                }
                
                if (!response.ok) return [];
                
                const data = await response.json();
                const nfts = [];
                
                for (const nft of (data.result || [])) {
                    // Parse metadata
                    let metadata = {};
                    try {
                        if (nft.metadata) {
                            metadata = typeof nft.metadata === 'string' ? JSON.parse(nft.metadata) : nft.metadata;
                        }
                    } catch (e) {}
                    
                    // Get image
                    let image = metadata.image || nft.token_uri || '';
                    if (image.startsWith('ipfs://')) {
                        image = image.replace('ipfs://', 'https://ipfs.io/ipfs/');
                    }
                    
                    nfts.push({
                        tokenId: nft.token_id,
                        name: metadata.name || nft.name || `#${nft.token_id}`,
                        collection: nft.name || 'Unknown Collection',
                        image: image,
                        chain: chainName,
                        chainKey: chainId,
                        contract: nft.token_address,
                        wallet: walletName,
                        floorPrice: 0, // TODO: fetch floor price
                        floorPriceUSD: 0
                    });
                }
                
                return nfts;
            } catch (e) {
                console.error('Moralis NFT error:', e);
                return [];
            }
        }
        
        async function fetchNFTsFromHelius(address, walletName) {
            if (!apiKeys.helius) return [];
            
            try {
                const url = `https://api.helius.xyz/v0/addresses/${address}/nfts?api-key=${apiKeys.helius}`;
                const response = await fetch(url);
                
                if (!response.ok) return [];
                
                const data = await response.json();
                const nfts = [];
                
                for (const nft of (data.nfts || data || [])) {
                    nfts.push({
                        tokenId: nft.mint || nft.id,
                        name: nft.name || 'Solana NFT',
                        collection: nft.collectionName || nft.collection?.name || 'Unknown',
                        image: nft.image || nft.content?.links?.image || '',
                        chain: 'Solana',
                        chainKey: 'solana',
                        contract: nft.mint || nft.id,
                        wallet: walletName,
                        floorPrice: 0,
                        floorPriceUSD: 0
                    });
                }
                
                return nfts;
            } catch (e) {
                console.error('Helius NFT error:', e);
                return [];
            }
        }
        
        function renderNFTGrid(filterChain = 'all') {
            const grid = document.getElementById('nftGrid');
            
            let filteredNFTs = nftData;
            if (filterChain !== 'all') {
                filteredNFTs = nftData.filter(nft => nft.chainKey === filterChain || nft.chain.toLowerCase() === filterChain);
            }
            
            if (filteredNFTs.length === 0) {
                grid.innerHTML = '<div style="color:var(--text-secondary);text-align:center;padding:40px;grid-column:1/-1;">Nessun NFT trovato.</div>';
                return;
            }
            
            let html = '';
            for (const nft of filteredNFTs) {
                const nftKey = `${nft.contract}_${nft.tokenId}`;
                const purchasePrice = nftPurchasePrices[nftKey] || 0;
                const currentValue = nft.floorPriceUSD || 0;
                const pl = currentValue - purchasePrice;
                const plColor = pl >= 0 ? 'var(--green)' : 'var(--red)';
                
                html += `
                <div class="card" style="padding:0;overflow:hidden;">
                    <div style="height:200px;background:var(--bg-primary);display:flex;align-items:center;justify-content:center;overflow:hidden;">
                        ${nft.image ? 
                            `<img src="${nft.image}" alt="${nft.name}" style="max-width:100%;max-height:100%;object-fit:contain;" onerror="this.parentElement.innerHTML='üñºÔ∏è'">` : 
                            '<span style="font-size:48px;">üñºÔ∏è</span>'
                        }
                    </div>
                    <div style="padding:12px;">
                        <div style="font-weight:600;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${nft.name}</div>
                        <div style="font-size:12px;color:var(--text-secondary);margin-bottom:8px;">${nft.collection}</div>
                        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
                            <span style="font-size:11px;padding:4px 8px;background:var(--bg-primary);border-radius:4px;">${nft.chain}</span>
                            <span style="font-size:11px;color:var(--text-secondary);">${nft.wallet}</span>
                        </div>
                        <div style="border-top:1px solid var(--bg-primary);padding-top:8px;margin-top:8px;">
                            <div style="display:flex;justify-content:space-between;font-size:12px;margin-bottom:4px;">
                                <span>Costo:</span>
                                <input type="number" value="${purchasePrice}" 
                                    style="width:80px;background:var(--bg-primary);border:none;color:var(--text-primary);text-align:right;padding:2px 6px;border-radius:4px;"
                                    onchange="setNFTPurchasePrice('${nftKey}', this.value)"
                                    placeholder="‚Ç¨0">
                            </div>
                            ${purchasePrice > 0 ? `
                            <div style="display:flex;justify-content:space-between;font-size:12px;">
                                <span>P/L:</span>
                                <span style="color:${plColor};font-weight:600;">‚Ç¨${pl.toFixed(2)}</span>
                            </div>` : ''}
                        </div>
                    </div>
                </div>`;
            }
            
            grid.innerHTML = html;
        }
        
        function filterNFTsByChain() {
            const filter = document.getElementById('nftChainFilter').value;
            renderNFTGrid(filter);
        }
        
        function setNFTPurchasePrice(nftKey, price) {
            nftPurchasePrices[nftKey] = parseFloat(price) || 0;
            localStorage.setItem('cryptofolio_nft_prices', JSON.stringify(nftPurchasePrices));
            updateNFTSummary();
            console.log(`üíæ NFT ${nftKey}: costo ‚Ç¨${price}`);
        }
        
        function loadNFTPurchasePrices() {
            try {
                const saved = localStorage.getItem('cryptofolio_nft_prices');
                if (saved) {
                    nftPurchasePrices = JSON.parse(saved);
                }
            } catch (e) {}
        }
        
        function updateNFTSummary() {
            const totalCount = nftData.length;
            let totalValue = 0;
            let totalCost = 0;
            
            for (const nft of nftData) {
                const nftKey = `${nft.contract}_${nft.tokenId}`;
                totalValue += nft.floorPriceUSD || 0;
                totalCost += nftPurchasePrices[nftKey] || 0;
            }
            
            const pl = totalValue - totalCost;
            const plColor = pl >= 0 ? 'var(--green)' : 'var(--red)';
            
            document.getElementById('nftTotalCount').textContent = totalCount;
            document.getElementById('nftTotalValue').textContent = '‚Ç¨' + totalValue.toFixed(0);
            document.getElementById('nftTotalCost').textContent = '‚Ç¨' + totalCost.toFixed(0);
            document.getElementById('nftTotalPL').textContent = '‚Ç¨' + pl.toFixed(0);
            document.getElementById('nftTotalPL').style.color = plColor;
            document.getElementById('nftCount').textContent = totalCount;
        }
        
        function saveNFTDataToLocalStorage() {
            try {
                localStorage.setItem('cryptofolio_nfts', JSON.stringify(nftData));
            } catch (e) {}
        }
        
        function loadNFTDataFromLocalStorage() {
            try {
                const saved = localStorage.getItem('cryptofolio_nfts');
                if (saved) {
                    nftData = JSON.parse(saved);
                    loadNFTPurchasePrices();
                    updateNFTSummary();
                }
            } catch (e) {}
        }
        
        function exportReconciliationReport() {
            let report = '=== REPORT RICONCILIAZIONE ===\n';
            report += `Data: ${new Date().toLocaleString('it-IT')}\n\n`;
            
            report += `üìä RIEPILOGO\n`;
            report += `Transazioni Exchange: ${reconcileData.exchangeTx.length}\n`;
            report += `Transazioni Wallet: ${reconcileData.walletTx.length}\n`;
            report += `Match trovati: ${reconcileData.matches.length}\n`;
            report += `Non riconciliati: ${reconcileData.unmatchedExch.length + reconcileData.unmatchedWallet.length}\n\n`;
            
            report += `‚úÖ MATCH TROVATI\n`;
            for (const m of reconcileData.matches) {
                report += `${m.exchange.date.toISOString().split('T')[0]} | ${m.exchange.exchange} ${m.exchange.type} ${m.exchange.amount} ${m.exchange.coin} ‚Üî Wallet ${m.wallet.type} | ${Math.round(m.confidence*100)}%\n`;
            }
            
            report += `\n‚ö†Ô∏è EXCHANGE NON RICONCILIATI\n`;
            for (const tx of reconcileData.unmatchedExch) {
                report += `${tx.date.toISOString().split('T')[0]} | ${tx.exchange} | ${tx.type} ${tx.amount} ${tx.coin}\n`;
            }
            
            report += `\n‚ö†Ô∏è WALLET NON RICONCILIATI\n`;
            for (const tx of reconcileData.unmatchedWallet) {
                report += `${tx.date.toISOString().split('T')[0]} | ${tx.type} ${tx.amount} ${tx.coin}\n`;
            }
            
            // Download
            const blob = new Blob([report], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `riconciliazione_${new Date().toISOString().split('T')[0]}.txt`;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        init();
    </script>
    
    <!-- Modal Binance API -->
    <div id="binanceApiModal" class="modal-overlay" onclick="if(event.target===this)closeBinanceApiModal()">
        <div class="modal-content">
            <div class="modal-header">
                <h3><img src="https://assets.coingecko.com/markets/images/52/small/binance.jpg" style="width:28px;height:28px;border-radius:6px;"> Binance Tax API</h3>
                <button class="modal-close" onclick="closeBinanceApiModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="server-status-box">
                    <span class="server-status-label">üñ•Ô∏è Server Locale</span>
                    <span id="modalServerStatus" class="server-status-badge server-off">OFFLINE</span>
                </div>
                
                <div class="form-group">
                    <label class="form-label">API Key</label>
                    <input type="text" id="modalApiKey" class="form-input" placeholder="Incolla la tua API Key...">
                </div>
                
                <div class="form-group">
                    <label class="form-label">Secret Key</label>
                    <input type="password" id="modalSecretKey" class="form-input" placeholder="Incolla la tua Secret Key...">
                </div>
                
                <a href="https://www.binance.com/it/my/settings/api-management" target="_blank" class="api-help-link">
                    üìã Come creare API Report Fiscale su Binance ‚Üí
                </a>
                
                <div id="modalProgress" class="progress-container">
                    <div class="progress-bar-bg">
                        <div id="modalProgressBar" class="progress-bar-fill"></div>
                    </div>
                    <div id="modalProgressText" class="progress-text">Preparazione...</div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="checkModalServerStatus()">üîÑ Check Server</button>
                <button class="btn btn-primary" onclick="downloadFromModal()" style="background:#f3ba2f;color:#000;">üì• Scarica Storico</button>
            </div>
        </div>
    </div>
    
    <!-- BITGET API MODAL -->
    <div id="bitgetApiModal" class="modal-overlay" onclick="if(event.target===this)closeBitgetApiModal()">
        <div class="modal-content">
            <div class="modal-header">
                <h3><img src="https://assets.coingecko.com/markets/images/540/small/bitget.jpg" style="width:28px;height:28px;border-radius:6px;"> Bitget API</h3>
                <button class="modal-close" onclick="closeBitgetApiModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="server-status-box">
                    <span class="server-status-label">üñ•Ô∏è Server Locale</span>
                    <span id="bitgetModalServerStatus" class="server-status-badge server-off">OFFLINE</span>
                </div>
                
                <div class="form-group">
                    <label class="form-label">API Key</label>
                    <input type="text" id="bitgetModalApiKey" class="form-input" placeholder="Incolla la tua API Key...">
                </div>
                
                <div class="form-group">
                    <label class="form-label">Secret Key</label>
                    <input type="password" id="bitgetModalSecretKey" class="form-input" placeholder="Incolla la tua Secret Key...">
                </div>
                
                <div class="form-group">
                    <label class="form-label">Passphrase</label>
                    <input type="password" id="bitgetModalPassphrase" class="form-input" placeholder="Incolla la tua Passphrase...">
                </div>
                
                <a href="https://www.bitget.com/account/newapi" target="_blank" class="api-help-link">
                    üìã Come creare API su Bitget ‚Üí
                </a>
                
                <div id="bitgetModalProgress" class="progress-container">
                    <div class="progress-bar-bg">
                        <div id="bitgetModalProgressBar" class="progress-bar-fill"></div>
                    </div>
                    <div id="bitgetModalProgressText" class="progress-text">Preparazione...</div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="checkBitgetServerStatus()">üîÑ Check Server</button>
                <button class="btn btn-primary" onclick="downloadFromBitgetModal()" style="background:#00f0ff;color:#000;">üì• Scarica Storico</button>
            </div>
        </div>
    </div>
    
    <!-- BITPANDA API MODAL -->
    <div id="bitpandaApiModal" class="modal-overlay" onclick="if(event.target===this)closeBitpandaApiModal()">
        <div class="modal-content">
            <div class="modal-header">
                <h3><img src="https://assets.coingecko.com/markets/images/237/small/bitpanda.jpg" style="width:28px;height:28px;border-radius:6px;"> Bitpanda API</h3>
                <button class="modal-close" onclick="closeBitpandaApiModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div style="background:var(--bg-primary);padding:12px;border-radius:8px;margin-bottom:16px;font-size:13px;">
                    <strong>‚ÑπÔ∏è Nota:</strong> Bitpanda API √® semplice - serve solo l'API Key!<br>
                    <span style="color:var(--text-secondary);">Scope richiesti: <strong>Transaction</strong> + <strong>Trading</strong></span>
                </div>
                
                <div class="form-group">
                    <label class="form-label">API Key</label>
                    <input type="password" id="bitpandaModalApiKey" class="form-input" placeholder="Incolla la tua Bitpanda API Key...">
                </div>
                
                <a href="https://web.bitpanda.com/apikey" target="_blank" class="api-help-link">
                    üìã Come creare API su Bitpanda ‚Üí
                </a>
                
                <div style="background:var(--yellow);color:#000;padding:10px;border-radius:8px;margin:16px 0;font-size:12px;">
                    ‚ö†Ô∏è <strong>CORS:</strong> Se vedi errore "CORS bloccato", Bitpanda non permette chiamate dirette dal browser. Usa l'import CSV in alternativa.
                </div>
                
                <div id="bitpandaModalProgress" class="progress-container">
                    <div class="progress-bar-bg">
                        <div id="bitpandaModalProgressBar" class="progress-bar-fill"></div>
                    </div>
                    <div id="bitpandaModalProgressText" class="progress-text">Preparazione...</div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeBitpandaApiModal()">Annulla</button>
                <button class="btn btn-primary" onclick="downloadFromBitpandaModal()" style="background:#08b289;color:#fff;">üì• Scarica Storico</button>
            </div>
        </div>
    </div>
    
    <!-- AI ANALYSIS MODAL -->
    <div id="aiAnalysisModal" class="modal-overlay" onclick="if(event.target===this)closeAIAnalysisModal()">
        <div class="modal-content" style="max-width:700px;">
            <div class="modal-header">
                <h3>ü§ñ Analisi AI Transazioni</h3>
                <button class="modal-close" onclick="closeAIAnalysisModal()">&times;</button>
            </div>
            <div class="modal-body">
                <!-- API Key Section -->
                <div id="aiApiKeySection">
                    <div style="background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);padding:16px;border-radius:12px;margin-bottom:16px;color:#fff;">
                        <strong>üîê API Key Anthropic</strong><br>
                        <span style="opacity:0.9;font-size:13px;">Necessaria per usare Claude AI. I dati restano privati.</span>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">Claude API Key</label>
                        <input type="password" id="claudeApiKeyInput" class="form-input" placeholder="sk-ant-api03-...">
                        <div style="font-size:11px;color:var(--text-secondary);margin-top:4px;">
                            <a href="https://console.anthropic.com/settings/keys" target="_blank" style="color:var(--accent);">
                                üîë Ottieni API Key da console.anthropic.com ‚Üí
                            </a>
                        </div>
                    </div>
                    
                    <div style="margin:20px 0;">
                        <label class="form-label">Tipo di Analisi</label>
                        <div style="display:flex;flex-direction:column;gap:10px;">
                            <label style="display:flex;align-items:center;gap:10px;cursor:pointer;padding:12px;background:var(--bg-primary);border-radius:8px;">
                                <input type="radio" name="aiAnalysisType" value="quick" checked>
                                <div>
                                    <strong>‚ö° Analisi Rapida</strong>
                                    <div style="font-size:12px;color:var(--text-secondary);">Anomalie + Riepilogo (~‚Ç¨0.01)</div>
                                </div>
                            </label>
                            <label style="display:flex;align-items:center;gap:10px;cursor:pointer;padding:12px;background:var(--bg-primary);border-radius:8px;">
                                <input type="radio" name="aiAnalysisType" value="full">
                                <div>
                                    <strong>üìä Analisi Completa</strong>
                                    <div style="font-size:12px;color:var(--text-secondary);">+ Report Fiscale + P&L per token (~‚Ç¨0.03)</div>
                                </div>
                            </label>
                            <label style="display:flex;align-items:center;gap:10px;cursor:pointer;padding:12px;background:var(--bg-primary);border-radius:8px;">
                                <input type="radio" name="aiAnalysisType" value="question">
                                <div>
                                    <strong>üí¨ Fai una Domanda</strong>
                                    <div style="font-size:12px;color:var(--text-secondary);">Chiedi qualsiasi cosa sui tuoi dati</div>
                                </div>
                            </label>
                        </div>
                    </div>
                    
                    <!-- Custom Question -->
                    <div id="aiCustomQuestionSection" style="display:none;" class="form-group">
                        <label class="form-label">La tua domanda</label>
                        <textarea id="aiCustomQuestion" class="form-input" rows="3" placeholder="Es: Quanto ho guadagnato/perso su VSN? Quali sono i miei rewards totali?"></textarea>
                    </div>
                </div>
                
                <!-- Results Section -->
                <div id="aiResultsSection" style="display:none;">
                    <div style="background:var(--bg-primary);padding:16px;border-radius:12px;max-height:400px;overflow-y:auto;">
                        <div id="aiResultsContent" style="white-space:pre-wrap;font-family:monospace;font-size:13px;line-height:1.6;"></div>
                    </div>
                </div>
                
                <!-- Loading -->
                <div id="aiLoadingSection" style="display:none;text-align:center;padding:40px;">
                    <div style="font-size:48px;animation:pulse 1.5s infinite;">ü§ñ</div>
                    <div style="margin-top:16px;color:var(--text-secondary);">Claude sta analizzando le transazioni...</div>
                    <div id="aiLoadingDetail" style="font-size:12px;color:var(--text-secondary);margin-top:8px;"></div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeAIAnalysisModal()">Chiudi</button>
                <button id="aiAnalyzeBtn" class="btn btn-primary" onclick="runAIAnalysis()" style="background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);">
                    üöÄ Avvia Analisi
                </button>
            </div>
        </div>
    </div>
</body>
</html>
