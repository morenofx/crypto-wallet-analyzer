<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto Wallet Analyzer v8</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üîó</text></svg>">
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <script>
        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyDAmtceQc0m-KQC7xGmu0IH1cR4tnI8oCQ",
            authDomain: "moreno-crypto-tools.firebaseapp.com",
            projectId: "moreno-crypto-tools",
            storageBucket: "moreno-crypto-tools.firebasestorage.app",
            messagingSenderId: "875997322481",
            appId: "1:875997322481:web:1a012bec2aff2cb5205d50"
        };
        
        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();
    </script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&display=swap');
        
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body {
            min-height: 100vh;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            font-family: 'JetBrains Mono', monospace;
            color: #e0e0e0;
            padding: 24px;
        }
        
        .home-btn {
            position: fixed;
            top: 20px;
            left: 20px;
            padding: 10px 18px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            color: #fff;
            text-decoration: none;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.3s;
            z-index: 1000;
        }
        .home-btn:hover {
            background: rgba(255,255,255,0.2);
            transform: translateY(-2px);
        }
        
        .container { max-width: 1400px; margin: 0 auto; }
        
        .header { text-align: center; margin-bottom: 40px; }
        .header h1 {
            font-size: 28px; font-weight: 700;
            background: linear-gradient(135deg, #f7931a, #627eea, #00d4aa);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            margin-bottom: 8px;
        }
        .header p { color: #888; font-size: 14px; }
        .badge {
            display: inline-block; padding: 3px 10px; border-radius: 12px;
            font-size: 10px; font-weight: 600; margin-left: 8px;
        }
        .badge-live { background: linear-gradient(135deg, #00ff88, #00d4aa); color: #000; }
        .badge-ai { background: linear-gradient(135deg, #a855f7, #6366f1); color: white; }
        .badge-new { background: linear-gradient(135deg, #ff6b6b, #ffa500); color: #fff; }
        
        .card {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px; padding: 24px; margin-bottom: 24px;
        }
        
        .input-group { display: flex; gap: 10px; margin-bottom: 15px; flex-wrap: wrap; }
        .input-wallet {
            flex: 1; min-width: 280px; padding: 14px 18px;
            border: 1px solid rgba(255,255,255,0.2); border-radius: 8px;
            background: rgba(0,0,0,0.3); color: #e0e0e0;
            font-family: inherit; font-size: 14px;
        }
        .input-wallet:focus { outline: none; border-color: #00ff88; }
        
        .btn {
            padding: 14px 28px; border: none; border-radius: 8px;
            cursor: pointer; font-family: inherit; font-weight: 600;
            transition: all 0.3s ease; font-size: 14px;
        }
        .btn-primary { background: linear-gradient(135deg, #00ff88, #00d4aa); color: #000; }
        .btn-ai { background: linear-gradient(135deg, #a855f7, #6366f1); color: white; }
        .btn-warning { background: linear-gradient(135deg, #fbbf24, #f59e0b); color: #000; }
        .btn-info { background: linear-gradient(135deg, #3b82f6, #1d4ed8); color: white; }
        .btn-success { background: linear-gradient(135deg, #10b981, #059669); color: white; }
        .btn:hover { transform: translateY(-2px); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
        .btn-small { padding: 8px 16px; font-size: 12px; }
        
        .api-section {
            background: rgba(0,255,136,0.1); border: 1px solid rgba(0,255,136,0.3);
            border-radius: 8px; padding: 15px; margin-bottom: 20px;
        }
        .api-row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; margin-bottom: 10px; }
        .api-row:last-child { margin-bottom: 0; }
        .api-input {
            flex: 1; min-width: 200px; padding: 10px 14px;
            border: 1px solid rgba(0,255,136,0.3); border-radius: 6px;
            background: rgba(0,0,0,0.3); color: #e0e0e0;
            font-family: inherit; font-size: 12px;
        }
        .api-status { font-size: 11px; padding: 5px 10px; border-radius: 4px; }
        .api-status.on { background: rgba(0,255,136,0.2); color: #00ff88; }
        .api-status.off { background: rgba(255,71,87,0.2); color: #ff4757; }
        
        /* Backup Section */
        .backup-section {
            background: rgba(59,130,246,0.1); border: 1px solid rgba(59,130,246,0.3);
            border-radius: 8px; padding: 15px; margin-bottom: 20px;
        }
        .backup-row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
        .backup-title { font-size: 12px; font-weight: 600; color: #3b82f6; margin-bottom: 10px; }
        
        /* Date Picker */
        .date-section {
            background: rgba(251,191,36,0.1); border: 1px solid rgba(251,191,36,0.3);
            border-radius: 8px; padding: 15px; margin-bottom: 20px;
        }
        .date-row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
        .date-input {
            padding: 10px 14px; border: 1px solid rgba(251,191,36,0.3); border-radius: 6px;
            background: rgba(0,0,0,0.3); color: #e0e0e0;
            font-family: inherit; font-size: 12px;
        }
        .date-label { font-size: 12px; color: #fbbf24; }
        .rate-display { font-size: 11px; color: #888; margin-left: 10px; }
        
        /* Year Buttons */
        .year-buttons { display: flex; gap: 5px; }
        .year-btn {
            padding: 8px 16px;
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(251,191,36,0.3);
            border-radius: 6px;
            color: #888;
            font-family: inherit;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        .year-btn:hover { background: rgba(251,191,36,0.2); color: #fbbf24; }
        .year-btn.active {
            background: rgba(251,191,36,0.3);
            border-color: #fbbf24;
            color: #fbbf24;
        }
        
        /* Staking Section */
        .staking-section {
            background: rgba(168,85,247,0.1); border: 1px solid rgba(168,85,247,0.3);
            border-radius: 8px; padding: 15px; margin-bottom: 20px;
        }
        .staking-header {
            display: flex; justify-content: space-between; align-items: center;
            font-size: 14px; font-weight: 600; color: #a855f7;
        }
        .staking-content { margin-top: 15px; }
        .staking-input-row { display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 15px; }
        .staking-input {
            flex: 1; min-width: 120px; padding: 10px 14px;
            border: 1px solid rgba(168,85,247,0.3); border-radius: 6px;
            background: rgba(0,0,0,0.3); color: #e0e0e0;
            font-family: inherit; font-size: 12px;
        }
        .staking-list { margin-bottom: 15px; }
        .staking-item {
            display: flex; justify-content: space-between; align-items: center;
            padding: 10px 15px; background: rgba(0,0,0,0.2);
            border-radius: 6px; margin-bottom: 8px;
        }
        .staking-item-left { display: flex; align-items: center; gap: 10px; }
        .staking-item-platform { font-size: 11px; color: #a855f7; }
        .staking-item-token { font-weight: 600; }
        .staking-item-amount { color: #888; font-size: 12px; }
        .staking-item-value { font-weight: 600; color: #00ff88; }
        .staking-item-remove {
            background: none; border: none; color: #ff4757;
            cursor: pointer; font-size: 14px; opacity: 0.5;
        }
        .staking-item-remove:hover { opacity: 1; }
        .staking-total {
            padding: 12px 15px; background: rgba(168,85,247,0.2);
            border-radius: 6px; display: flex; justify-content: space-between;
            font-weight: 600;
        }
        
        /* Wallet Preview */
        .wallet-preview-item {
            padding: 12px 16px; background: rgba(255,255,255,0.02);
            border: 1px dashed rgba(0,255,136,0.3); border-radius: 8px;
            margin-bottom: 8px; animation: fadeIn 0.3s ease;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .wallet-preview-left { display: flex; align-items: center; gap: 12px; }
        .wallet-preview-icon {
            width: 36px; height: 36px; border-radius: 50%;
            background: rgba(0,255,136,0.2); border: 1px dashed rgba(0,255,136,0.5);
            display: flex; align-items: center; justify-content: center; font-size: 16px;
        }
        .wallet-preview-name { font-weight: 600; font-size: 13px; color: #fff; }
        .wallet-preview-address { font-size: 11px; color: #888; }
        .wallet-preview-status {
            font-size: 10px; color: #00ff88;
            background: rgba(0,255,136,0.1); padding: 4px 10px; border-radius: 12px;
        }
        .wallet-preview-remove {
            background: none; border: none; color: #ff4757;
            cursor: pointer; font-size: 18px; padding: 5px;
            margin-left: 10px; opacity: 0.7;
        }
        .wallet-preview-remove:hover { opacity: 1; }
        .wallet-tokens-dropdown {
            max-height: 400px;
            overflow-y: auto;
        }
        
        /* Wallet Cards */
        .wallet-card {
            background: rgba(255,255,255,0.02);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px; margin-bottom: 16px; overflow: hidden;
        }
        .wallet-header {
            display: flex; justify-content: space-between; align-items: center;
            padding: 16px 20px; cursor: pointer;
            background: rgba(255,255,255,0.02); transition: background 0.2s;
        }
        .wallet-header:hover { background: rgba(255,255,255,0.05); }
        .wallet-left { display: flex; align-items: center; gap: 12px; }
        .wallet-icon {
            width: 40px; height: 40px; border-radius: 50%;
            background: linear-gradient(135deg, #00ff88, #00d4aa);
            display: flex; align-items: center; justify-content: center; font-size: 18px;
        }
        .wallet-name {
            font-weight: 600; font-size: 14px; color: #fff;
            background: transparent; border: none; padding: 0;
            font-family: inherit; cursor: text; width: 200px;
        }
        .wallet-name:focus { outline: none; border-bottom: 1px solid #00ff88; }
        .wallet-address { font-size: 11px; color: #888; }
        .wallet-right { display: flex; align-items: center; gap: 20px; }
        .wallet-value { font-size: 20px; font-weight: 700; color: #00ff88; }
        .wallet-tokens { font-size: 11px; color: #888; }
        .wallet-toggle { font-size: 14px; color: #00ff88; transition: transform 0.3s; }
        .wallet-toggle.open { transform: rotate(180deg); }
        
        .wallet-content { max-height: 0; overflow: hidden; transition: max-height 0.3s ease; }
        .wallet-content.open { max-height: 5000px; }
        
        /* Chain Cards (inside wallet) */
        .chain-section {
            margin: 10px 15px; border-radius: 10px;
            background: rgba(0,0,0,0.2); overflow: hidden;
        }
        .chain-header {
            display: flex; justify-content: space-between; align-items: center;
            padding: 12px 16px; cursor: pointer;
            background: rgba(255,255,255,0.02); transition: background 0.2s;
        }
        .chain-header:hover { background: rgba(255,255,255,0.05); }
        .chain-left { display: flex; align-items: center; gap: 10px; }
        .chain-icon {
            width: 28px; height: 28px; border-radius: 50%;
            display: flex; align-items: center; justify-content: center; font-size: 14px;
        }
        .chain-name { font-weight: 600; font-size: 13px; }
        .chain-count { font-size: 11px; color: #888; margin-left: 8px; }
        .chain-value { font-size: 14px; font-weight: 600; color: #00ff88; }
        .chain-toggle { font-size: 12px; color: #888; transition: transform 0.3s; margin-left: 10px; }
        .chain-toggle.open { transform: rotate(180deg); }
        
        .chain-content { max-height: 0; overflow: hidden; transition: max-height 0.3s ease; }
        .chain-content.open { max-height: 2000px; }
        
        /* Token rows */
        .token-list { padding: 0 10px 10px 10px; }
        .token-item {
            display: flex; justify-content: space-between; align-items: center;
            padding: 10px 12px; border-radius: 6px;
            background: rgba(255,255,255,0.02); margin-bottom: 6px;
            transition: background 0.2s;
        }
        .token-item:hover { background: rgba(255,255,255,0.05); }
        .token-item.scam { opacity: 0.4; background: rgba(255,71,87,0.1); }
        .token-left { display: flex; align-items: center; gap: 10px; }
        .token-logo {
            width: 28px; height: 28px; border-radius: 50%;
            background: rgba(255,255,255,0.1); object-fit: cover;
            display: flex; align-items: center; justify-content: center; font-size: 10px;
        }
        .token-symbol { font-weight: 600; font-size: 13px; }
        .token-name { font-size: 10px; color: #888; }
        .token-balance { font-size: 12px; color: #888; }
        .token-value { font-size: 13px; font-weight: 600; color: #00ff88; }
        .token-price { font-size: 10px; color: #666; }
        
        .token-badge {
            font-size: 9px; padding: 2px 6px; border-radius: 4px; margin-left: 6px;
        }
        .token-badge.verified { background: rgba(0,255,136,0.2); color: #00ff88; }
        .token-badge.scam { background: rgba(255,71,87,0.2); color: #ff4757; }
        
        .hide-btn {
            background: none; border: none; color: #ff4757; cursor: pointer;
            font-size: 14px; padding: 6px; opacity: 0.3; margin-right: 10px;
            transition: all 0.2s;
        }
        .hide-btn:hover { opacity: 1; transform: scale(1.2); }
        .token-item:hover .hide-btn { opacity: 0.6; }
        
        /* Filters */
        .filter-bar {
            display: flex; gap: 12px; align-items: center;
            padding: 12px 16px; background: rgba(255,71,87,0.1);
            border: 1px solid rgba(255,71,87,0.3); border-radius: 8px;
            margin-bottom: 20px; flex-wrap: wrap;
        }
        .filter-bar label {
            display: flex; align-items: center; gap: 6px;
            font-size: 12px; cursor: pointer; padding: 6px 12px;
            background: rgba(0,0,0,0.2); border-radius: 6px;
        }
        .filter-bar label:hover { background: rgba(0,0,0,0.4); }
        .filter-bar input[type="checkbox"] { accent-color: #00ff88; }
        .filter-title { font-weight: 600; color: #ff4757; font-size: 12px; }
        
        /* Summary */
        .summary-grid {
            display: grid; grid-template-columns: repeat(5, 1fr);
            gap: 15px; margin: 20px 0;
        }
        @media (max-width: 900px) { .summary-grid { grid-template-columns: repeat(3, 1fr); } }
        @media (max-width: 600px) { .summary-grid { grid-template-columns: repeat(2, 1fr); } }
        .summary-box {
            background: rgba(255,255,255,0.05);
            border-radius: 8px; padding: 15px; text-align: center;
        }
        .summary-box .label { font-size: 10px; color: #888; margin-bottom: 5px; text-transform: uppercase; }
        .summary-box .value { font-size: 18px; font-weight: 700; }
        .summary-box .sub { font-size: 10px; color: #666; margin-top: 3px; }
        
        /* Fiscal */
        .fiscal-summary {
            background: rgba(251,191,36,0.1);
            border: 1px solid rgba(251,191,36,0.3);
            border-radius: 12px; padding: 20px; margin-top: 20px;
        }
        .fiscal-summary h3 { color: #fbbf24; margin-bottom: 15px; }
        .fiscal-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; }
        @media (max-width: 768px) { .fiscal-grid { grid-template-columns: 1fr; } }
        .fiscal-box { background: rgba(0,0,0,0.2); border-radius: 8px; padding: 15px; }
        .fiscal-box .title { font-size: 12px; color: #fbbf24; margin-bottom: 8px; }
        .fiscal-box .amount { font-size: 20px; font-weight: 700; }
        .fiscal-box .note { font-size: 11px; color: #888; margin-top: 5px; }
        
        /* AI */
        .ai-section {
            background: rgba(168,85,247,0.1);
            border: 1px solid rgba(168,85,247,0.3);
            border-radius: 12px; padding: 20px; margin-top: 20px;
        }
        .ai-section h3 { color: #a855f7; font-size: 16px; margin-bottom: 15px; }
        .ai-response {
            background: rgba(0,0,0,0.3); border-radius: 8px; padding: 15px;
            font-size: 13px; line-height: 1.7;
            white-space: pre-wrap; max-height: 500px; overflow-y: auto;
        }
        
        .loading { display: flex; align-items: center; gap: 10px; padding: 20px; justify-content: center; }
        .loading-spinner {
            width: 24px; height: 24px;
            border: 3px solid rgba(0,255,136,0.3); border-top-color: #00ff88;
            border-radius: 50%; animation: spin 1s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        
        .hidden { display: none; }
        .footer { text-align: center; margin-top: 40px; color: #444; font-size: 11px; }
        .price-info { font-size: 10px; color: #888; margin-top: 10px; text-align: right; }
        
        /* File input hidden */
        .file-input-hidden { display: none; }
        
        /* Navigation Bar */
        .nav-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(0,0,0,0.9);
            backdrop-filter: blur(10px);
            padding: 10px 20px;
            display: flex;
            align-items: center;
            gap: 15px;
            z-index: 1000;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .nav-logo {
            font-size: 18px;
            font-weight: 700;
            background: linear-gradient(135deg, #f7931a, #627eea);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .nav-links {
            display: flex;
            gap: 5px;
            margin-left: auto;
        }
        .nav-link {
            padding: 8px 16px;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 6px;
            color: #888;
            text-decoration: none;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.3s;
        }
        .nav-link:hover {
            background: rgba(255,255,255,0.1);
            color: #fff;
        }
        .nav-link.active {
            background: rgba(0,255,136,0.2);
            border-color: #00ff88;
            color: #00ff88;
        }
        
        body { padding-top: 60px; }
    </style>
</head>
<body>
    <!-- Navigation Bar -->
    <nav class="nav-bar">
        <span class="nav-logo">ü™ô Crypto Tools</span>
        <div class="nav-links">
            <a href="index.html" class="nav-link">üè† Home</a>
            <a href="Crypto_Fiscal_Manager_v1.html" class="nav-link">üìä Fiscal Manager</a>
            <a href="Crypto_Wallet_Analyzer_v8.html" class="nav-link active">üîó Wallet Analyzer</a>
        </div>
    </nav>
    
    <div class="container">
        <div class="header">
            <h1>üîó Crypto Wallet Analyzer</h1>
            <p>Multi-Chain ‚Ä¢ Prezzi Real-Time ‚Ä¢ Fiscalit√† Italiana</p>
            <div style="margin-top:10px;">
                <span class="badge badge-live">üì° Live Prices</span>
                <span class="badge badge-ai">ü§ñ Claude AI</span>
                <span class="badge badge-new">v8.0</span>
            </div>
        </div>
        
        <!-- API Section - Compatto -->
        <div class="api-section" style="padding:10px 15px;">
            <div style="display:flex;gap:15px;flex-wrap:wrap;align-items:center;">
                <div style="display:flex;align-items:center;gap:6px;">
                    <span style="font-size:11px;">ü¶ä Moralis:</span>
                    <input type="password" id="moralisKey" class="api-input" placeholder="eyJ... (per tutti i token ERC-20)" style="width:180px;padding:5px 8px;font-size:11px;">
                    <button class="btn btn-small" style="background:#00ff88;color:#000;padding:4px 8px;font-size:10px;" onclick="saveMoralisKey()">Salva</button>
                    <button class="btn btn-small" style="background:#ff4757;color:#fff;padding:4px 6px;font-size:10px;" onclick="clearMoralisKey()">‚úï</button>
                    <span id="moralisStatus" class="api-status off" style="font-size:10px;padding:2px 6px;">OFF</span>
                </div>
                <div style="display:flex;align-items:center;gap:6px;">
                    <span style="font-size:11px;">ü§ñ Claude:</span>
                    <input type="password" id="claudeKey" class="api-input" placeholder="sk-ant-... (per analisi AI)" style="width:180px;padding:5px 8px;font-size:11px;">
                    <button class="btn btn-small" style="background:#a855f7;color:white;padding:4px 8px;font-size:10px;" onclick="saveClaudeKey()">Salva</button>
                    <span id="claudeStatus" class="api-status off" style="font-size:10px;padding:2px 6px;">OFF</span>
                </div>
                <span style="font-size:10px;color:#666;">üí° Per Binance API ‚Üí <a href="Crypto_Fiscal_Manager_v1.html" style="color:#f3ba2f;">Fiscal Manager</a></span>
            </div>
        </div>
        
        <!-- Year Selection Section -->
        <div class="date-section">
            <div class="date-row">
                <span class="date-label">üìÖ Anno Fiscale:</span>
                <div class="year-buttons">
                    <button class="year-btn" onclick="selectYear(2021)">2021</button>
                    <button class="year-btn" onclick="selectYear(2022)">2022</button>
                    <button class="year-btn" onclick="selectYear(2023)">2023</button>
                    <button class="year-btn" onclick="selectYear(2024)">2024</button>
                    <button class="year-btn active" onclick="selectYear(2025)">2025</button>
                </div>
                <span class="rate-display" id="rateDisplay">EUR/USD: caricamento...</span>
                <button class="btn btn-small btn-warning" onclick="fetchEurUsdRate()">üîÑ Aggiorna Tasso</button>
            </div>
            
            <!-- Riepilogo Totale + Grafico -->
            <div style="display:flex;gap:20px;margin-top:15px;flex-wrap:wrap;align-items:stretch;">
                <!-- Grafico a Torta -->
                <div style="flex:0 0 180px;display:flex;align-items:center;justify-content:center;">
                    <canvas id="tokenPieChart" width="160" height="160"></canvas>
                </div>
                
                <!-- Stats Box -->
                <div style="flex:1;display:flex;gap:10px;flex-wrap:wrap;">
                    <div style="flex:1;min-width:100px;background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.1);border-radius:10px;padding:12px;text-align:center;">
                        <div style="font-size:10px;color:#888;text-transform:uppercase;">Wallet</div>
                        <div style="font-size:22px;font-weight:700;color:#fff;" id="totalWalletsTop">0</div>
                    </div>
                    <div style="flex:1;min-width:100px;background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.1);border-radius:10px;padding:12px;text-align:center;">
                        <div style="font-size:10px;color:#888;text-transform:uppercase;">Token</div>
                        <div style="font-size:22px;font-weight:700;color:#fff;" id="totalTokensTop">0</div>
                    </div>
                    <div style="flex:1;min-width:100px;background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.1);border-radius:10px;padding:12px;text-align:center;">
                        <div style="font-size:10px;color:#888;text-transform:uppercase;">Chain</div>
                        <div style="font-size:22px;font-weight:700;color:#fff;" id="totalChainsTop">0</div>
                    </div>
                    <div style="flex:1;min-width:130px;background:rgba(0,255,136,0.1);border:1px solid rgba(0,255,136,0.3);border-radius:10px;padding:12px;text-align:center;">
                        <div style="font-size:10px;color:#888;text-transform:uppercase;">Valore USD</div>
                        <div style="font-size:22px;font-weight:700;color:#00ff88;" id="totalValueTop">$0</div>
                    </div>
                    <div style="flex:1;min-width:130px;background:rgba(0,212,170,0.1);border:1px solid rgba(0,212,170,0.3);border-radius:10px;padding:12px;text-align:center;">
                        <div style="font-size:10px;color:#888;text-transform:uppercase;">Valore EUR</div>
                        <div style="font-size:22px;font-weight:700;color:#00d4aa;" id="totalValueEurTop">‚Ç¨0</div>
                    </div>
                </div>
            </div>
            
            <!-- Riepilogo Fiscale Compatto -->
            <div style="display:flex;gap:10px;margin-top:15px;flex-wrap:wrap;">
                <div style="flex:1;min-width:150px;background:rgba(0,255,136,0.1);border:1px solid rgba(0,255,136,0.3);border-radius:10px;padding:10px 12px;">
                    <div style="font-size:10px;color:#888;margin-bottom:2px;">üìã QUADRO RW</div>
                    <div style="font-size:18px;font-weight:700;color:#00ff88;" id="rwValueTop">‚Ç¨0</div>
                    <div style="font-size:9px;color:#666;">Valore al 31/12/<span id="rwYearTop">2025</span></div>
                </div>
                <div style="flex:1;min-width:150px;background:rgba(251,191,36,0.1);border:1px solid rgba(251,191,36,0.3);border-radius:10px;padding:10px 12px;">
                    <div style="font-size:10px;color:#888;margin-bottom:2px;">üí∏ IVAFE (0,2%)</div>
                    <div style="font-size:18px;font-weight:700;color:#fbbf24;" id="ivafeTop">‚Ç¨0</div>
                    <div style="font-size:9px;color:#666;">Codice F24: 4043</div>
                </div>
                <div style="flex:1;min-width:150px;background:rgba(139,92,246,0.1);border:1px solid rgba(139,92,246,0.3);border-radius:10px;padding:10px 12px;">
                    <div style="font-size:10px;color:#888;margin-bottom:2px;">üìà QUADRO RT</div>
                    <div style="font-size:18px;font-weight:700;color:#8b5cf6;">Serve storico</div>
                    <div style="font-size:9px;color:#666;">26% plusvalenze</div>
                </div>
            </div>
        </div>
        
        <!-- Staking Section -->
        <div class="staking-section">
            <div class="staking-header">
                <span>üîí Token in Staking</span>
                <button class="btn btn-small btn-info" onclick="toggleStakingSection()">Mostra/Nascondi</button>
            </div>
            <div id="stakingContent" class="staking-content hidden">
                <div class="staking-input-row">
                    <input type="text" id="stakingPlatform" class="staking-input" placeholder="Piattaforma (es. Binance, Nexo...)">
                    <input type="text" id="stakingToken" class="staking-input" placeholder="Token (es. ETH, BTC...)">
                    <input type="number" id="stakingAmount" class="staking-input" placeholder="Quantit√†" step="any">
                    <input type="number" id="stakingValueEur" class="staking-input" placeholder="Valore EUR (opzionale)" step="any">
                    <button class="btn btn-small btn-primary" onclick="addStakingToken()">+ Aggiungi</button>
                </div>
                <div id="stakingList" class="staking-list"></div>
                <div id="stakingTotal" class="staking-total"></div>
            </div>
        </div>
        
        <!-- NFT Section -->
        <div class="staking-section" style="border-color:rgba(139,92,246,0.3);background:rgba(139,92,246,0.05);">
            <div class="staking-header">
                <span>üñºÔ∏è NFT Collection <span id="nftCount" style="font-size:12px;color:#8b5cf6;margin-left:8px;">(0 NFT)</span></span>
                <div style="display:flex;gap:8px;">
                    <span id="nftTotalValue" style="font-size:14px;font-weight:600;color:#8b5cf6;">$0</span>
                    <button class="btn btn-small" style="background:#8b5cf6;color:#fff;" onclick="toggleNftSection()">Mostra/Nascondi</button>
                </div>
            </div>
            <div id="nftContent" class="staking-content hidden">
                <div id="nftGrid" style="display:grid;grid-template-columns:repeat(auto-fill,minmax(150px,1fr));gap:12px;margin-top:10px;"></div>
                <div id="nftEmpty" style="text-align:center;color:#666;padding:20px;font-size:13px;">
                    üñºÔ∏è Scansiona un wallet per vedere gli NFT
                </div>
            </div>
        </div>
        
        <!-- Backup Section -->
        <div class="backup-section">
            <div class="backup-title">üî• Sincronizzazione Firebase (Automatica)</div>
            <div class="backup-row">
                <span id="syncStatus" style="font-size:12px;color:#888;">‚è≥ Connessione...</span>
                <button class="btn btn-small btn-primary" onclick="forceSaveToFirebase()" style="margin-left:auto;">üíæ Salva Ora</button>
                <button class="btn btn-small btn-info" onclick="document.getElementById('importFile').click()">üìÇ Importa JSON</button>
                <input type="file" id="importFile" class="file-input-hidden" accept=".json" onchange="importJSON(event)">
            </div>
        </div>
        
        <!-- Wallet Input -->
        <div class="card">
            <h2 style="margin-bottom:15px;">üìç Aggiungi Wallet</h2>
            <div class="input-group">
                <input type="text" id="walletInput" class="input-wallet" placeholder="Indirizzo 0x... (EVM) o Solana">
                <input type="text" id="walletName" class="input-wallet" placeholder="Nome (es. Wallet Principale)" style="max-width:200px;">
                <button class="btn btn-primary" onclick="addWallet()">+ Aggiungi</button>
            </div>
            
            <div id="walletsPreview" class="hidden" style="margin-top:20px;">
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;">
                    <h3 style="font-size:14px;color:#888;">Wallet da scansionare:</h3>
                    <div style="display:flex;gap:10px;">
                        <button class="btn btn-small" style="background:linear-gradient(135deg,#00ff88,#00d4aa);color:#000;" onclick="scanAllWallets()">üîç Scansiona Tutti</button>
                        <button class="btn btn-small" style="background:rgba(255,71,87,0.2);color:#ff4757;" onclick="clearAllWallets()">üóëÔ∏è Cancella</button>
                    </div>
                </div>
                <div id="walletsPreviewList"></div>
            </div>
        </div>
        
        <!-- Loading -->
        <div id="loadingSection" class="card hidden">
            <div class="loading">
                <div class="loading-spinner"></div>
                <span id="loadingText">Caricamento prezzi real-time...</span>
            </div>
        </div>
        
        <!-- Results -->
        <div id="resultsSection" class="hidden">
            
            <!-- Filters -->
            <div class="filter-bar">
                <span class="filter-title">üõ°Ô∏è Filtri:</span>
                <label>
                    <input type="checkbox" id="filterScam" checked onchange="renderResults()">
                    Nascondi scam
                </label>
                <label>
                    <input type="checkbox" id="filterDust" onchange="renderResults()">
                    Nascondi &lt; $1
                </label>
                <label>
                    <input type="checkbox" id="filterHidden" checked onchange="renderResults()">
                    Nascondi manuali
                </label>
                <div style="margin-left:auto;font-size:11px;color:#888;">
                    <span id="filterStats">0 token nascosti</span>
                </div>
            </div>
            
            <!-- Action Buttons & Info -->
            <div class="card" style="padding:12px 15px;">
                <div style="display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:10px;">
                    <div style="display:flex;align-items:center;gap:15px;">
                        <span class="price-info" id="priceInfo" style="font-size:11px;">Prezzi: --</span>
                    </div>
                    <div style="display:flex;gap:8px;flex-wrap:wrap;">
                        <button class="btn btn-ai btn-small" onclick="analyzeWithAI()">ü§ñ Analisi AI</button>
                        <button class="btn btn-warning btn-small" onclick="exportCSV()">üì• CSV</button>
                        <button class="btn btn-info btn-small" onclick="exportCSVFiscale()">üìã CSV Fiscale</button>
                    </div>
                </div>
            </div>
            
            <!-- Wallets -->
            <div id="walletsContainer"></div>
            
            <!-- AI -->
            <div id="aiSection" class="ai-section hidden">
                <h3>ü§ñ Analisi AI</h3>
                <div id="aiResponse" class="ai-response"></div>
            </div>
        </div>
        
        <div class="footer">
            <p>Crypto Wallet Analyzer v8.0 - Storico Anni ‚Ä¢ Staking ‚Ä¢ Fiscalit√† Italiana</p>
        </div>
    </div>
    
    <script>
        let wallets = [];
        let prices = {};
        let hiddenTokens = JSON.parse(localStorage.getItem('hidden_tokens_v8') || '[]');
        let stakingTokens = JSON.parse(localStorage.getItem('staking_tokens_v8') || '[]');
        let EUR_USD = 0.92; // Default, will be updated
        let lastScanDate = null;
        let selectedYear = 2024;
        
        // Prezzi storici al 31/12 di ogni anno (BTC, ETH, etc.)
        const HISTORICAL_PRICES = {
            2021: {
                'BTC': 46306, 'ETH': 3682, 'BNB': 531, 'MATIC': 2.47, 'AVAX': 111,
                'SOL': 170, 'ADA': 1.35, 'DOT': 27.5, 'SHIB': 0.0000338, 'DOGE': 0.17,
                'BONK': 0, 'JUP': 0, 'WIF': 0, 'PYTH': 0, 'RAY': 5.8,
                'EUR_USD': 0.88
            },
            2022: {
                'BTC': 16547, 'ETH': 1196, 'BNB': 244, 'MATIC': 0.76, 'AVAX': 11.2,
                'SOL': 9.97, 'ADA': 0.25, 'DOT': 4.33, 'SHIB': 0.0000089, 'DOGE': 0.07,
                'BONK': 0.0000003, 'JUP': 0, 'WIF': 0, 'PYTH': 0, 'RAY': 0.17,
                'EUR_USD': 0.93
            },
            2023: {
                'BTC': 42265, 'ETH': 2282, 'BNB': 311, 'MATIC': 1.03, 'AVAX': 41.5,
                'SOL': 101, 'ADA': 0.59, 'DOT': 8.9, 'SHIB': 0.0000101, 'DOGE': 0.09,
                'BONK': 0.000015, 'JUP': 0.68, 'WIF': 0.25, 'PYTH': 0.42, 'RAY': 1.85,
                'EUR_USD': 0.91
            },
            2024: {
                'BTC': 93500, 'ETH': 3350, 'BNB': 702, 'MATIC': 0.46, 'AVAX': 40.2,
                'SOL': 189, 'ADA': 0.89, 'DOT': 7.2, 'SHIB': 0.0000218, 'DOGE': 0.32,
                'BONK': 0.000033, 'JUP': 0.92, 'WIF': 1.85, 'PYTH': 0.38, 'RAY': 5.2,
                'EUR_USD': 0.96
            }
            // 2025 usa prezzi live (non servono prezzi storici)
        };
        
        // Chain config
        const CHAINS = {
            'eth': { name: 'Ethereum', icon: 'üî∑', color: '#627eea' },
            'bsc': { name: 'BSC', icon: 'üü°', color: '#f3ba2f' },
            'polygon': { name: 'Polygon', icon: 'üü£', color: '#8247e5' },
            'arbitrum': { name: 'Arbitrum', icon: 'üîµ', color: '#28a0f0' },
            'optimism': { name: 'Optimism', icon: 'üî¥', color: '#ff0420' },
            'avalanche': { name: 'Avalanche', icon: 'üî∫', color: '#e84142' },
            'base': { name: 'Base', icon: 'üîµ', color: '#0052ff' },
            'pulse': { name: 'PulseChain', icon: 'üíú', color: '#9b59b6' },
            'solana': { name: 'Solana', icon: '‚òÄÔ∏è', color: '#14f195' }
        };
        
        // CoinGecko IDs
        const COINGECKO_IDS = {
            'ETH': 'ethereum', 'BNB': 'binancecoin', 'MATIC': 'matic-network',
            'AVAX': 'avalanche-2', 'FTM': 'fantom', 'SHIB': 'shiba-inu',
            'BONE': 'bone-shibaswap', 'USDT': 'tether', 'USDC': 'usd-coin',
            'DAI': 'dai', 'CAKE': 'pancakeswap-token', 'PLS': 'pulsechain',
            'PLSX': 'pulsex', 'HEX': 'hex', 'INC': 'incentive',
            'DOGE': 'dogecoin', 'PEPE': 'pepe', 'FLOKI': 'floki',
            'UNI': 'uniswap', 'AAVE': 'aave', 'LINK': 'chainlink',
            'ARB': 'arbitrum', 'OP': 'optimism', 'SOL': 'solana',
            'WBTC': 'wrapped-bitcoin', 'WETH': 'weth',
            'RAY': 'raydium', 'SRM': 'serum', 'ORCA': 'orca',
            'BONK': 'bonk', 'JTO': 'jito-governance-token', 'JUP': 'jupiter-exchange-solana',
            'PYTH': 'pyth-network', 'WIF': 'dogwifcoin', 'RENDER': 'render-token'
        };
        
        // Token logos
        const TOKEN_LOGOS = {
            'ETH': 'https://assets.coingecko.com/coins/images/279/small/ethereum.png',
            'BNB': 'https://assets.coingecko.com/coins/images/825/small/bnb-icon2_2x.png',
            'MATIC': 'https://assets.coingecko.com/coins/images/4713/small/matic-token-icon.png',
            'AVAX': 'https://assets.coingecko.com/coins/images/12559/small/Avalanche_Circle_RedWhite_Trans.png',
            'SHIB': 'https://assets.coingecko.com/coins/images/11939/small/shiba.png',
            'BONE': 'https://assets.coingecko.com/coins/images/16916/small/bone_icon.png',
            'USDT': 'https://assets.coingecko.com/coins/images/325/small/Tether.png',
            'USDC': 'https://assets.coingecko.com/coins/images/6319/small/usdc.png',
            'DAI': 'https://assets.coingecko.com/coins/images/9956/small/Badge_Dai.png',
            'CAKE': 'https://assets.coingecko.com/coins/images/12632/small/pancakeswap-cake-logo.png',
            'PLS': 'https://assets.coingecko.com/coins/images/25667/small/PLS_WLOGO.png',
            'PLSX': 'https://assets.coingecko.com/coins/images/29993/small/PLSX.png',
            'HEX': 'https://assets.coingecko.com/coins/images/10103/small/HEX-logo.png',
            'INC': 'https://assets.coingecko.com/coins/images/30298/small/INC.png',
            'DOGE': 'https://assets.coingecko.com/coins/images/5/small/dogecoin.png',
            'PEPE': 'https://assets.coingecko.com/coins/images/29850/small/pepe-token.jpeg',
            'FLOKI': 'https://assets.coingecko.com/coins/images/16746/small/PNG_image.png',
            'UNI': 'https://assets.coingecko.com/coins/images/12504/small/uniswap-logo.png',
            'AAVE': 'https://assets.coingecko.com/coins/images/12645/small/AAVE.png',
            'LINK': 'https://assets.coingecko.com/coins/images/877/small/chainlink-new-logo.png',
            'ARB': 'https://assets.coingecko.com/coins/images/16547/small/photo_2023-03-29_21.47.00.jpeg',
            'OP': 'https://assets.coingecko.com/coins/images/25244/small/Optimism.png',
            'LEASH': 'https://assets.coingecko.com/coins/images/15802/small/leash.png',
            'SOL': 'https://assets.coingecko.com/coins/images/4128/small/solana.png',
            'RAY': 'https://assets.coingecko.com/coins/images/13928/small/PSigc4ie_400x400.jpg',
            'BONK': 'https://assets.coingecko.com/coins/images/28600/small/bonk.jpg',
            'JUP': 'https://assets.coingecko.com/coins/images/34188/small/jup.png',
            'WIF': 'https://assets.coingecko.com/coins/images/33566/small/dogwifhat.jpg',
            'PYTH': 'https://assets.coingecko.com/coins/images/31924/small/pyth.png'
        };
        
        function getTokenLogo(symbol) {
            return TOKEN_LOGOS[symbol.toUpperCase()] || '';
        }
        
        // Scam patterns
        const SCAM_PATTERNS = [
            /airdrop/i, /claim/i, /\.com$/i, /\.io$/i, /\.org$/i, /\.net$/i,
            /reward/i, /bonus/i, /gift/i, /visit/i, /http/i, /www\./i,
            /free.*token/i, /token.*free/i
        ];
        
        // ==================== EUR/USD RATE ====================
        async function fetchEurUsdRate() {
            const rateDisplayEl = document.getElementById('rateDisplay');
            if (rateDisplayEl) rateDisplayEl.textContent = 'EUR/USD: caricamento...';
            
            try {
                // Try exchangerate-api (free, no key needed)
                const res = await fetch('https://api.exchangerate-api.com/v4/latest/USD');
                if (res.ok) {
                    const data = await res.json();
                    EUR_USD = data.rates.EUR;
                    localStorage.setItem('eur_usd_rate', EUR_USD);
                    localStorage.setItem('eur_usd_date', new Date().toISOString());
                    if (rateDisplayEl) rateDisplayEl.textContent = `EUR/USD: ${EUR_USD.toFixed(4)} (live)`;
                    return;
                }
            } catch (e) {
                console.error('Exchange rate error:', e);
            }
            
            // Fallback to cached or default
            const cached = localStorage.getItem('eur_usd_rate');
            if (cached) {
                EUR_USD = parseFloat(cached);
                if (rateDisplayEl) rateDisplayEl.textContent = `EUR/USD: ${EUR_USD.toFixed(4)} (cache)`;
            } else {
                if (rateDisplayEl) rateDisplayEl.textContent = `EUR/USD: ${EUR_USD.toFixed(4)} (default)`;
            }
        }
        
        // ==================== BACKUP/RESTORE ====================
        function exportJSON() {
            const data = {
                version: '8.0',
                lastUpdate: new Date().toISOString(),
                selectedYear: selectedYear,
                eurUsdRate: EUR_USD,
                wallets: wallets,
                hiddenTokens: hiddenTokens,
                stakingTokens: stakingTokens,
                lastScanDate: lastScanDate
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'wallet_data.json';
            link.click();
            
            // Update sync status
            const syncStatus = document.getElementById('syncStatus');
            syncStatus.innerHTML = 'üì• File scaricato! Caricalo su GitHub in /data/';
            syncStatus.style.color = '#fbbf24';
        }
        
        function importJSON(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    if (data.wallets) {
                        wallets = data.wallets;
                        saveWallets();
                    }
                    if (data.hiddenTokens) {
                        hiddenTokens = data.hiddenTokens;
                        localStorage.setItem('hidden_tokens_v8', JSON.stringify(hiddenTokens));
                    }
                    if (data.stakingTokens) {
                        stakingTokens = data.stakingTokens;
                        localStorage.setItem('staking_tokens_v8', JSON.stringify(stakingTokens));
                    }
                    if (data.selectedYear) {
                        selectYear(data.selectedYear);
                    }
                    if (data.eurUsdRate) {
                        EUR_USD = data.eurUsdRate;
                        document.getElementById('rateDisplay').textContent = `EUR/USD: ${EUR_USD.toFixed(4)} (importato)`;
                        // rateUsed removed = `@${EUR_USD.toFixed(4)}`;
                    }
                    if (data.lastScanDate) {
                        lastScanDate = data.lastScanDate;
                    }
                    
                    renderWalletsPreview();
                    renderStakingList();
                    
                    if (wallets.some(w => w.tokens && w.tokens.length > 0)) {
                        document.getElementById('resultsSection').classList.remove('hidden');
                        renderResults();
                    }
                    
                    const syncStatus = document.getElementById('syncStatus');
                    syncStatus.innerHTML = `‚úÖ Importati ${wallets.length} wallet!`;
                    syncStatus.style.color = '#00ff88';
                } catch (err) {
                    alert('‚ùå Errore nel file JSON: ' + err.message);
                }
            };
            reader.readAsText(file);
            event.target.value = ''; // Reset input
        }
        
        // ==================== API MANAGEMENT ====================
        function saveMoralisKey() {
            const key = document.getElementById('moralisKey').value.trim();
            if (key) {
                localStorage.setItem('moralis_key', key);
                document.getElementById('moralisKey').value = '';
                updateApiStatus();
            }
        }
        
        function clearMoralisKey() {
            localStorage.removeItem('moralis_key');
            updateApiStatus();
            alert('Moralis API rimossa!');
        }
        
        function saveClaudeKey() {
            const key = document.getElementById('claudeKey').value.trim();
            if (key.startsWith('sk-ant-')) {
                localStorage.setItem('claude_key', key);
                document.getElementById('claudeKey').value = '';
                updateApiStatus();
            }
        }
        
        function updateApiStatus() {
            const moralis = localStorage.getItem('moralis_key');
            const claude = localStorage.getItem('claude_key');
            
            document.getElementById('moralisStatus').className = moralis ? 'api-status on' : 'api-status off';
            document.getElementById('moralisStatus').textContent = moralis ? 'ON' : 'OFF';
            document.getElementById('claudeStatus').className = claude ? 'api-status on' : 'api-status off';
            document.getElementById('claudeStatus').textContent = claude ? 'ON' : 'OFF';
        }
        
        // ==================== WALLET MANAGEMENT ====================
        function addWallet() {
            const addressInput = document.getElementById('walletInput');
            const nameInput = document.getElementById('walletName');
            let address = addressInput.value.trim();
            const name = nameInput.value.trim() || `Wallet ${wallets.length + 1}`;
            
            // Validate address (EVM or Solana)
            const isEVM = address.startsWith('0x') && address.length === 42;
            const isSolana = isSolanaAddress(address);
            
            if (!isEVM && !isSolana) {
                alert('Indirizzo non valido. Usa 0x... per EVM o indirizzo Solana.');
                return;
            }
            
            // Lowercase only for EVM addresses
            if (isEVM) address = address.toLowerCase();
            
            if (wallets.find(w => w.address === address)) {
                alert('Wallet gi√† aggiunto');
                return;
            }
            
            wallets.push({ address, name, tokens: [], totalUSD: 0, type: isSolana ? 'solana' : 'evm' });
            addressInput.value = '';
            nameInput.value = '';
            saveWallets();
            renderWalletsPreview();
        }
        
        function removeWallet(address) {
            wallets = wallets.filter(w => w.address !== address);
            saveWallets();
            renderWalletsPreview();
            if (wallets.length === 0) {
                document.getElementById('resultsSection').classList.add('hidden');
            }
        }
        
        function updateWalletName(address, newName) {
            const wallet = wallets.find(w => w.address === address);
            if (wallet) {
                wallet.name = newName || 'Wallet';
                saveWallets();
            }
        }
        
        function clearAllWallets() {
            if (confirm('Cancellare tutti i wallet?')) {
                wallets = [];
                saveWallets();
                document.getElementById('resultsSection').classList.add('hidden');
                renderWalletsPreview();
            }
        }
        
        function saveWallets() {
            localStorage.setItem('crypto_wallets_v8', JSON.stringify(wallets));
            // Auto-save to Firebase
            saveToFirebase();
        }
        
        // ==================== FIREBASE SYNC ====================
        let saveTimeout = null;
        
        async function saveToFirebase() {
            // Debounce: aspetta 2 secondi prima di salvare
            if (saveTimeout) clearTimeout(saveTimeout);
            
            saveTimeout = setTimeout(async () => {
                try {
                    const syncStatus = document.getElementById('syncStatus');
                    syncStatus.innerHTML = '‚è≥ Salvataggio...';
                    syncStatus.style.color = '#fbbf24';
                    
                    await db.collection('users').doc('moreno').set({
                        wallets: wallets,
                        hiddenTokens: hiddenTokens,
                        stakingTokens: stakingTokens,
                        selectedYear: selectedYear,
                        eurUsdRate: EUR_USD,
                        lastScanDate: lastScanDate,
                        lastUpdate: new Date().toISOString()
                    });
                    
                    syncStatus.innerHTML = '‚úÖ Sincronizzato ' + new Date().toLocaleTimeString('it-IT');
                    syncStatus.style.color = '#00ff88';
                    console.log('‚úÖ Salvato su Firebase');
                } catch (e) {
                    console.error('Firebase save error:', e);
                    document.getElementById('syncStatus').innerHTML = '‚ùå Errore sync';
                    document.getElementById('syncStatus').style.color = '#ff4757';
                }
            }, 2000);
        }
        
        function forceSaveToFirebase() {
            if (saveTimeout) clearTimeout(saveTimeout);
            saveTimeout = null;
            
            const syncStatus = document.getElementById('syncStatus');
            syncStatus.innerHTML = '‚è≥ Salvataggio...';
            
            db.collection('users').doc('moreno').set({
                wallets: wallets,
                hiddenTokens: hiddenTokens,
                stakingTokens: stakingTokens,
                selectedYear: selectedYear,
                eurUsdRate: EUR_USD,
                lastScanDate: lastScanDate,
                lastUpdate: new Date().toISOString()
            }).then(() => {
                syncStatus.innerHTML = '‚úÖ Salvato! ' + new Date().toLocaleTimeString('it-IT');
                syncStatus.style.color = '#00ff88';
            }).catch(e => {
                syncStatus.innerHTML = '‚ùå Errore: ' + e.message;
                syncStatus.style.color = '#ff4757';
            });
        }
        
        async function loadFromFirebase() {
            const syncStatus = document.getElementById('syncStatus');
            
            try {
                syncStatus.innerHTML = '‚è≥ Caricamento da Firebase...';
                syncStatus.style.color = '#fbbf24';
                
                // Timeout di 5 secondi
                const timeoutPromise = new Promise((_, reject) => 
                    setTimeout(() => reject(new Error('Timeout')), 5000)
                );
                
                const docPromise = db.collection('users').doc('moreno').get();
                const doc = await Promise.race([docPromise, timeoutPromise]);
                
                if (doc.exists) {
                    const data = doc.data();
                    
                    if (data.wallets) wallets = data.wallets;
                    if (data.hiddenTokens) hiddenTokens = data.hiddenTokens;
                    if (data.stakingTokens) stakingTokens = data.stakingTokens;
                    if (data.selectedYear) selectedYear = data.selectedYear;
                    if (data.eurUsdRate) EUR_USD = data.eurUsdRate;
                    if (data.lastScanDate) lastScanDate = data.lastScanDate;
                    
                    // Salva anche in localStorage come backup
                    localStorage.setItem('crypto_wallets_v8', JSON.stringify(wallets));
                    localStorage.setItem('hidden_tokens_v8', JSON.stringify(hiddenTokens));
                    localStorage.setItem('staking_tokens_v8', JSON.stringify(stakingTokens));
                    
                    const lastUpdate = data.lastUpdate ? new Date(data.lastUpdate).toLocaleString('it-IT') : 'N/A';
                    syncStatus.innerHTML = 'üî• Firebase OK ‚Ä¢ ' + wallets.length + ' wallet ‚Ä¢ ' + lastUpdate;
                    syncStatus.style.color = '#00ff88';
                    
                    console.log('‚úÖ Caricato da Firebase:', wallets.length, 'wallet');
                    return true;
                } else {
                    syncStatus.innerHTML = 'üì≠ Nessun dato su Firebase';
                    syncStatus.style.color = '#888';
                    return false;
                }
            } catch (e) {
                console.error('Firebase load error:', e);
                syncStatus.innerHTML = '‚ö†Ô∏è Firebase non disponibile, uso dati locali';
                syncStatus.style.color = '#fbbf24';
                return false;
            }
        }
        
        async function loadWallets() {
            // Prima prova Firebase
            const firebaseLoaded = await loadFromFirebase();
            
            if (!firebaseLoaded) {
                // Fallback a localStorage
                let saved = localStorage.getItem('crypto_wallets_v8');
                if (!saved) {
                    saved = localStorage.getItem('crypto_wallets_v7') || localStorage.getItem('crypto_wallets_v6');
                }
                if (saved) {
                    wallets = JSON.parse(saved);
                    document.getElementById('syncStatus').innerHTML = 'üíæ Dati locali (' + wallets.length + ' wallet)';
                }
            }
        }
        
        function renderWalletsPreview() {
            if (wallets.length === 0) {
                document.getElementById('walletsPreview').classList.add('hidden');
                return;
            }
            
            document.getElementById('walletsPreview').classList.remove('hidden');
            document.getElementById('walletsPreviewList').innerHTML = wallets.map((w, idx) => `
                <div class="wallet-preview-item" id="wallet-item-${idx}">
                    <div style="display:flex;justify-content:space-between;align-items:center;width:100%;">
                        <div class="wallet-preview-left" style="cursor:pointer;" onclick="toggleWalletTokens(${idx})">
                            <div class="wallet-preview-icon">üíº</div>
                            <div>
                                <div class="wallet-preview-name">${w.name} ${w.tokens && w.tokens.length > 0 ? `<span style="font-size:10px;color:#888;">(${w.tokens.length} token)</span>` : ''}</div>
                                <div class="wallet-preview-address">${w.address.slice(0,10)}...${w.address.slice(-6)}</div>
                            </div>
                        </div>
                        <div style="display:flex;align-items:center;gap:8px;">
                            ${w.tokens && w.tokens.length > 0 
                                ? `<span style="color:#00ff88;font-weight:600;cursor:pointer;" onclick="toggleWalletTokens(${idx})">$${(w.totalUSD || 0).toLocaleString('en-US', {minimumFractionDigits:2})} ‚ñº</span>` 
                                : `<span class="wallet-preview-status" id="wallet-status-${idx}">‚è≥ Pronto</span>`}
                            <button class="btn btn-small" style="background:#00ff88;color:#000;padding:4px 10px;font-size:11px;" onclick="scanSingleWallet(${idx})" id="scan-btn-${idx}">üîç</button>
                            <button class="wallet-preview-remove" onclick="removeWallet('${w.address}')">‚úï</button>
                        </div>
                    </div>
                    <div id="wallet-tokens-${idx}" class="wallet-tokens-dropdown hidden" style="margin-top:10px;padding-top:10px;border-top:1px solid rgba(255,255,255,0.1);display:none;">
                        ${w.tokens && w.tokens.length > 0 ? w.tokens
                            .filter(t => (t.valueUSD || 0) >= 0.01 && !isHidden(t))
                            .sort((a, b) => (b.valueUSD || 0) - (a.valueUSD || 0))
                            .slice(0, 30)
                            .map(t => {
                                const chainUrl = t.chain === 'polygon' ? 'polygonscan.com' : t.chain === 'bsc' ? 'bscscan.com' : t.chain === 'eth' ? 'etherscan.io' : t.chain === 'arbitrum' ? 'arbiscan.io' : t.chain === 'base' ? 'basescan.org' : 'etherscan.io';
                                const verifiedBadge = t.verified ? '<span style="color:#00ff88;font-size:9px;">‚úì</span>' : '';
                                const priceStr = t.price ? '$' + t.price.toLocaleString('en-US', {minimumFractionDigits:2, maximumFractionDigits: t.price < 0.01 ? 8 : 2}) : '';
                                const contractShort = t.contractAddress && t.contractAddress !== 'native' ? t.contractAddress.slice(0,6) + '...' + t.contractAddress.slice(-4) : '';
                                const contractLink = t.contractAddress && t.contractAddress !== 'native' ? '<a href="https://' + chainUrl + '/token/' + t.contractAddress + '" target="_blank" style="color:#666;font-size:9px;text-decoration:none;" title="' + t.contractAddress + '">' + contractShort + ' ‚Üó</a>' : '';
                                return '<div style="display:flex;justify-content:space-between;align-items:center;padding:6px 0;border-bottom:1px solid rgba(255,255,255,0.05);">' +
                                    '<div style="display:flex;align-items:center;gap:6px;flex:1;flex-wrap:wrap;">' +
                                        '<button onclick="hideTokenFromPreview(\'' + t.symbol + '\', \'' + (t.contractAddress || '') + '\')" style="background:rgba(255,71,87,0.15);border:none;color:#ff4757;width:20px;height:20px;border-radius:4px;cursor:pointer;font-size:9px;flex-shrink:0;" title="Nascondi">‚úï</button>' +
                                        '<img src="' + (t.logo || getTokenLogo(t.symbol)) + '" style="width:24px;height:24px;border-radius:50%;flex-shrink:0;" onerror="this.style.display=\'none\'">' +
                                        '<span style="font-weight:600;font-size:12px;min-width:50px;">' + t.symbol + verifiedBadge + '</span>' +
                                        '<span style="color:#fbbf24;font-size:11px;min-width:65px;">' + priceStr + '</span>' +
                                        '<span style="font-size:10px;color:#888;">' + (t.chain || '').toUpperCase() + '</span>' +
                                        '<span style="font-size:10px;color:#666;">' + (t.balance?.toLocaleString('en-US', {maximumFractionDigits:4}) || 0) + '</span>' +
                                        contractLink +
                                    '</div>' +
                                    '<div style="color:#00ff88;font-weight:600;font-size:13px;text-align:right;min-width:90px;flex-shrink:0;">$' + (t.valueUSD || 0).toLocaleString('en-US', {minimumFractionDigits:2}) + '</div>' +
                                '</div>';
                            }).join('') : '<div style="color:#666;font-size:11px;">Nessun token</div>'}
                        ${w.tokens && w.tokens.filter(t => (t.valueUSD || 0) >= 0.01 && !isHidden(t)).length > 30 ? '<div style="color:#888;font-size:10px;text-align:center;margin-top:8px;">+ altri ' + (w.tokens.filter(t => (t.valueUSD || 0) >= 0.01 && !isHidden(t)).length - 30) + ' token...</div>' : ''}
                    </div>
                </div>
            `).join('');
        }
        
        function hideTokenFromPreview(symbol, contractAddress) {
            if (contractAddress && contractAddress !== 'native') {
                hiddenTokens.push(`contract:${contractAddress.toLowerCase()}`);
            } else {
                hiddenTokens.push(`symbol:${symbol.toUpperCase()}`);
            }
            localStorage.setItem('hidden_tokens_v8', JSON.stringify(hiddenTokens));
            saveToFirebase();
            renderWalletsPreview();
            updateDashboardTotals();
        }
        
        function toggleWalletTokens(idx) {
            const dropdown = document.getElementById(`wallet-tokens-${idx}`);
            if (dropdown) {
                const isHidden = dropdown.style.display === 'none';
                dropdown.style.display = isHidden ? 'block' : 'none';
            }
        }
        
        // Scansiona un singolo wallet
        async function scanSingleWallet(idx) {
            const wallet = wallets[idx];
            if (!wallet) return;
            
            const statusEl = document.getElementById(`wallet-status-${idx}`);
            const btnEl = document.getElementById(`scan-btn-${idx}`);
            
            if (statusEl) statusEl.innerHTML = '‚è≥ Scansione...';
            if (btnEl) {
                btnEl.disabled = true;
                btnEl.innerHTML = '‚è≥';
            }
            
            console.log(`üîç Scanning wallet: ${wallet.name} (${wallet.address})`);
            
            try {
                await fetchPrices();
                const moralisKey = localStorage.getItem('moralis_key');
                
                if (isSolanaAddress(wallet.address)) {
                    console.log('üîç Solana wallet detected');
                    
                    // Prova Moralis prima
                    if (moralisKey) {
                        wallet.tokens = await getMoralisSolanaBalances(wallet.address);
                    }
                    
                    // Fallback RPC
                    if (!wallet.tokens || wallet.tokens.length === 0) {
                        wallet.tokens = await getSolanaTokens(wallet.address);
                    }
                } else {
                    // EVM
                    wallet.tokens = await getMoralisBalances(wallet.address);
                }
                
                // Carica anche NFT
                if (moralisKey) {
                    if (statusEl) statusEl.innerHTML = '‚è≥ NFT...';
                    wallet.nfts = await getMoralisNFTs(wallet.address);
                    console.log(`üñºÔ∏è Found ${wallet.nfts?.length || 0} NFTs`);
                }
                
                wallet.totalUSD = wallet.tokens.reduce((s, t) => s + (t.valueUSD || 0), 0);
                
                console.log(`‚úÖ Found ${wallet.tokens.length} tokens, $${wallet.totalUSD.toFixed(2)}`);
                
                // Aggiorna UI
                renderWalletsPreview();
                
                // Mostra risultati se ci sono token
                if (wallets.some(w => w.tokens && w.tokens.length > 0)) {
                    document.getElementById('resultsSection').classList.remove('hidden');
                    renderResults();
                }
                
                // Aggiorna NFT
                updateAllNfts();
                renderNFTs();
                
                // Salva
                saveWallets();
                
            } catch (e) {
                console.error('Scan error:', e);
                if (statusEl) statusEl.innerHTML = '‚ùå Errore';
            }
            
            if (btnEl) {
                btnEl.disabled = false;
                btnEl.innerHTML = 'üîç';
            }
        }
        
        function updateAllNfts() {
            allNfts = [];
            wallets.forEach(w => {
                if (w.nfts && w.nfts.length > 0) {
                    allNfts.push(...w.nfts);
                }
            });
        }
        
        // ==================== PRICES ====================
        // Contract verificati da CoinGecko (aggiornati)
        const VERIFIED_CONTRACTS = {
            // Ethereum
            'eth': {
                '0x7fc66500c84a76ad7e9c93437bfc5ac33e2ddae9': { symbol: 'AAVE', coingecko: 'aave' },
                '0x1f9840a85d5af5bf1d1762f925bdaddc4201f984': { symbol: 'UNI', coingecko: 'uniswap' },
                '0x514910771af9ca656af840dff83e8264ecf986ca': { symbol: 'LINK', coingecko: 'chainlink' },
                '0x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce': { symbol: 'SHIB', coingecko: 'shiba-inu' },
                '0x9813037ee2218799597d83d4a5b6f3b6778218d9': { symbol: 'BONE', coingecko: 'bone-shibaswap' },
                '0x6b175474e89094c44da98b954eedeac495271d0f': { symbol: 'DAI', coingecko: 'dai' },
                '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48': { symbol: 'USDC', coingecko: 'usd-coin' },
                '0xdac17f958d2ee523a2206206994597c13d831ec7': { symbol: 'USDT', coingecko: 'tether' },
                '0x2260fac5e5542a773aa44fbcfedf7c193bc2c599': { symbol: 'WBTC', coingecko: 'wrapped-bitcoin' },
                '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2': { symbol: 'WETH', coingecko: 'weth' },
                '0x0d8775f648430679a709e98d2b0cb6250d2887ef': { symbol: 'BAT', coingecko: 'basic-attention-token' },
                '0x9f8f72aa9304c8b593d555f12ef6589cc3a579a2': { symbol: 'MKR', coingecko: 'maker' },
                '0xc00e94cb662c3520282e6f5717214004a7f26888': { symbol: 'COMP', coingecko: 'compound-governance-token' },
                '0x6982508145454ce325ddbe47a25d4ec3d2311933': { symbol: 'PEPE', coingecko: 'pepe' }
            },
            // Polygon
            'polygon': {
                '0xd6df932a45c0f255f85145f286ea0b292b21c90b': { symbol: 'AAVE', coingecko: 'aave' },
                '0xb33eaad8d922b1083446dc23f610c2567fb5180f': { symbol: 'UNI', coingecko: 'uniswap' },
                '0x53e0bca35ec356bd5dddfebbd1fc0fd03fabad39': { symbol: 'LINK', coingecko: 'chainlink' },
                '0x8f3cf7ad23cd3cadbd9735aff958023239c6a063': { symbol: 'DAI', coingecko: 'dai' },
                '0x2791bca1f2de4661ed88a30c99a7a9449aa84174': { symbol: 'USDC', coingecko: 'usd-coin' },
                '0xc2132d05d31c914a87c6611c10748aeb04b58e8f': { symbol: 'USDT', coingecko: 'tether' },
                '0x1bfd67037b42cf73acf2047067bd4f2c47d9bfd6': { symbol: 'WBTC', coingecko: 'wrapped-bitcoin' },
                '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619': { symbol: 'WETH', coingecko: 'weth' }
            },
            // BSC
            'bsc': {
                '0xfb6115445bff7b52feb98650c87f44907e58f802': { symbol: 'AAVE', coingecko: 'aave' },
                '0xbf5140a22578168fd562dccf235e5d43a02ce9b1': { symbol: 'UNI', coingecko: 'uniswap' },
                '0xf8a0bf9cf54bb92f17374d9e9a321e6a111a51bd': { symbol: 'LINK', coingecko: 'chainlink' },
                '0x1af3f329e8be154074d8769d1ffa4ee058b1dbc3': { symbol: 'DAI', coingecko: 'dai' },
                '0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d': { symbol: 'USDC', coingecko: 'usd-coin' },
                '0x55d398326f99059ff775485246999027b3197955': { symbol: 'USDT', coingecko: 'tether' },
                '0x0e09fabb73bd3ade0a17ecc321fd13a19e81ce82': { symbol: 'CAKE', coingecko: 'pancakeswap-token' }
            },
            // Arbitrum
            'arbitrum': {
                '0xfa7f8980b0f1e64a2062791cc3b0871572f1f7f0': { symbol: 'UNI', coingecko: 'uniswap' },
                '0xf97f4df75117a78c1a5a0dbb814af92458539fb4': { symbol: 'LINK', coingecko: 'chainlink' },
                '0xda10009cbd5d07dd0cecc66161fc93d7c9000da1': { symbol: 'DAI', coingecko: 'dai' },
                '0xff970a61a04b1ca14834a43f5de4533ebddb5cc8': { symbol: 'USDC', coingecko: 'usd-coin' },
                '0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9': { symbol: 'USDT', coingecko: 'tether' },
                '0x912ce59144191c1204e64559fe8253a0e49e6548': { symbol: 'ARB', coingecko: 'arbitrum' }
            }
        };
        
        // Verifica se un token √® verificato su CoinGecko
        function isVerifiedToken(chain, contractAddress) {
            if (!contractAddress || contractAddress === 'native') return true; // Native tokens sono OK
            const chainContracts = VERIFIED_CONTRACTS[chain];
            if (!chainContracts) return null; // Chain non mappata
            return chainContracts[contractAddress.toLowerCase()] || false;
        }
        
        async function fetchPrices() {
            const ids = Object.values(COINGECKO_IDS).join(',');
            try {
                const res = await fetch(`https://api.coingecko.com/api/v3/simple/price?ids=${ids}&vs_currencies=usd`);
                const data = await res.json();
                for (const [symbol, id] of Object.entries(COINGECKO_IDS)) {
                    if (data[id]) prices[symbol] = data[id].usd;
                }
                document.getElementById('priceInfo').textContent = `Prezzi aggiornati: ${new Date().toLocaleTimeString('it-IT')}`;
            } catch (e) {
                console.error('CoinGecko error:', e);
            }
        }
        
        // Fetch prezzo da CoinGecko per contract verificato
        async function fetchVerifiedPrice(chain, contractAddress) {
            const verified = isVerifiedToken(chain, contractAddress);
            if (!verified || !verified.coingecko) return null;
            
            try {
                const res = await fetch(`https://api.coingecko.com/api/v3/simple/price?ids=${verified.coingecko}&vs_currencies=usd`);
                const data = await res.json();
                return data[verified.coingecko]?.usd || null;
            } catch (e) {
                return null;
            }
        }
        
        // ==================== SCAM & HIDE ====================
        function isScam(token) {
            const name = (token.name || '').toLowerCase();
            const symbol = (token.symbol || '').toLowerCase();
            
            for (const pattern of SCAM_PATTERNS) {
                if (pattern.test(symbol) || pattern.test(name)) return true;
            }
            if (name.length > 40) return true;
            if (/[\/\\<>]/.test(name)) return true;
            
            return false;
        }
        
        function hideTokenKeepOpen(chain, address, symbol, name, walletIdx, chainIdx) {
            const contractId = `contract:${address.toLowerCase()}`;
            const symbolId = `symbol:${symbol.toUpperCase()}`;
            const nameId = `name:${name.toLowerCase()}`;
            
            if (!hiddenTokens.includes(contractId)) hiddenTokens.push(contractId);
            if (!hiddenTokens.includes(symbolId)) hiddenTokens.push(symbolId);
            if (name && !hiddenTokens.includes(nameId)) hiddenTokens.push(nameId);
            
            localStorage.setItem('hidden_tokens_v8', JSON.stringify(hiddenTokens));
            
            const tokenEl = document.getElementById(`token-${chain}-${address}`);
            if (tokenEl) {
                tokenEl.style.transition = 'opacity 0.3s, transform 0.3s';
                tokenEl.style.opacity = '0';
                tokenEl.style.transform = 'translateX(-20px)';
                setTimeout(() => {
                    tokenEl.remove();
                    updateDashboardTotals();
                }, 300);
            }
        }
        
        function updateDashboardTotals() {
            let totalUSD = 0;
            let totalTokens = 0;
            const allChains = new Set();
            const tokenValues = []; // Per il grafico
            
            wallets.forEach(wallet => {
                if (wallet.tokens) {
                    wallet.tokens.forEach(token => {
                        if (!isHidden(token)) {
                            totalUSD += token.valueUSD || 0;
                            totalTokens++;
                            allChains.add(token.chain);
                            
                            // Raccogli per grafico
                            if (token.valueUSD > 0) {
                                tokenValues.push({
                                    symbol: token.symbol,
                                    value: token.valueUSD,
                                    chain: token.chain
                                });
                            }
                        }
                    });
                }
            });
            
            // Aggiorna elementi esistenti
            const totalTokensEl = document.getElementById('totalTokens');
            const totalChainsEl = document.getElementById('totalChains');
            const totalValueEl = document.getElementById('totalValue');
            const totalValueEurEl = document.getElementById('totalValueEur');
            
            if (totalTokensEl) totalTokensEl.textContent = totalTokens;
            if (totalChainsEl) totalChainsEl.textContent = allChains.size;
            if (totalValueEl) totalValueEl.textContent = `$${totalUSD.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
            
            const eurValue = totalUSD * EUR_USD;
            const eurFormatted = `‚Ç¨${eurValue.toLocaleString('it-IT', { minimumFractionDigits: 2 })}`;
            const ivafeFormatted = `‚Ç¨${(eurValue * 0.002).toLocaleString('it-IT', { minimumFractionDigits: 2 })}`;
            
            if (totalValueEurEl) totalValueEurEl.textContent = eurFormatted;
            
            // Aggiorna totali in alto
            const totalWalletsTopEl = document.getElementById('totalWalletsTop');
            const totalTokensTopEl = document.getElementById('totalTokensTop');
            const totalChainsTopEl = document.getElementById('totalChainsTop');
            const totalValueTopEl = document.getElementById('totalValueTop');
            const totalValueEurTopEl = document.getElementById('totalValueEurTop');
            
            if (totalWalletsTopEl) totalWalletsTopEl.textContent = wallets.length;
            if (totalTokensTopEl) totalTokensTopEl.textContent = totalTokens;
            if (totalChainsTopEl) totalChainsTopEl.textContent = allChains.size;
            if (totalValueTopEl) totalValueTopEl.textContent = `$${totalUSD.toLocaleString('en-US', { minimumFractionDigits: 2 })}`;
            if (totalValueEurTopEl) totalValueEurTopEl.textContent = eurFormatted;
            
            // Aggiorna riepilogo fiscale in alto
            const rwTopEl = document.getElementById('rwValueTop');
            const ivafeTopEl = document.getElementById('ivafeTop');
            const rwYearTopEl = document.getElementById('rwYearTop');
            
            if (rwTopEl) rwTopEl.textContent = eurFormatted;
            if (ivafeTopEl) ivafeTopEl.textContent = ivafeFormatted;
            if (rwYearTopEl) rwYearTopEl.textContent = selectedYear;
            
            // Disegna grafico a torta
            drawPieChart(tokenValues, totalUSD);
        }
        
        function drawPieChart(tokenValues, totalUSD) {
            const canvas = document.getElementById('tokenPieChart');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(centerX, centerY) - 10;
            
            // Clear
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (tokenValues.length === 0 || totalUSD === 0) {
                // Cerchio vuoto
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                ctx.strokeStyle = 'rgba(255,255,255,0.1)';
                ctx.lineWidth = 20;
                ctx.stroke();
                
                ctx.fillStyle = '#666';
                ctx.font = '12px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('No data', centerX, centerY);
                return;
            }
            
            // Ordina per valore e prendi top 6
            const sorted = tokenValues.sort((a, b) => b.value - a.value);
            const top = sorted.slice(0, 6);
            const othersValue = sorted.slice(6).reduce((s, t) => s + t.value, 0);
            
            if (othersValue > 0) {
                top.push({ symbol: 'Altri', value: othersValue, chain: 'other' });
            }
            
            // Colori
            const colors = [
                '#00ff88', '#f3ba2f', '#8b5cf6', '#ff4757', 
                '#3498db', '#e91e63', '#00bcd4', '#ff9800'
            ];
            
            // Disegna fette
            let startAngle = -Math.PI / 2;
            
            top.forEach((token, i) => {
                const sliceAngle = (token.value / totalUSD) * 2 * Math.PI;
                const endAngle = startAngle + sliceAngle;
                
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.arc(centerX, centerY, radius, startAngle, endAngle);
                ctx.closePath();
                ctx.fillStyle = colors[i % colors.length];
                ctx.fill();
                
                // Bordo
                ctx.strokeStyle = '#0a0a0a';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                startAngle = endAngle;
            });
            
            // Buco centrale (donut)
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius * 0.55, 0, 2 * Math.PI);
            ctx.fillStyle = '#0a0a0a';
            ctx.fill();
            
            // Testo centrale
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(`$${(totalUSD/1000).toFixed(1)}k`, centerX, centerY - 6);
            ctx.font = '10px sans-serif';
            ctx.fillStyle = '#888';
            ctx.fillText('Total', centerX, centerY + 10);
        }
        
        function isHidden(token) {
            const contractId = `contract:${(token.contractAddress || '').toLowerCase()}`;
            const symbolId = `symbol:${(token.symbol || '').toUpperCase()}`;
            const nameId = `name:${(token.name || '').toLowerCase()}`;
            
            return hiddenTokens.includes(contractId) || 
                   hiddenTokens.includes(symbolId) || 
                   hiddenTokens.includes(nameId);
        }
        
        // ==================== MORALIS API ====================
        async function getMoralisBalances(address) {
            const moralisKey = localStorage.getItem('moralis_key');
            const tokens = [];
            
            if (!moralisKey) {
                console.log('No Moralis key, usando fallback');
                return await getFallbackBalances(address);
            }
            
            const chains = ['eth', 'bsc', 'polygon', 'arbitrum', 'base', 'optimism', 'avalanche'];
            
            for (const chain of chains) {
                try {
                    // Native balance
                    const nativeRes = await fetch(
                        `https://deep-index.moralis.io/api/v2.2/${address}/balance?chain=${chain}`,
                        { headers: { 'X-API-Key': moralisKey } }
                    );
                    
                    if (nativeRes.ok) {
                        const data = await nativeRes.json();
                        const balance = parseInt(data.balance) / 1e18;
                        if (balance > 0.0001) {
                            const symbol = chain === 'bsc' ? 'BNB' : chain === 'polygon' ? 'MATIC' : chain === 'avalanche' ? 'AVAX' : 'ETH';
                            tokens.push({
                                symbol, name: symbol, chain, balance,
                                price: prices[symbol] || 0,
                                valueUSD: balance * (prices[symbol] || 0),
                                logo: getTokenLogo(symbol), contractAddress: 'native'
                            });
                        }
                    }
                    
                    // ERC-20 tokens
                    const tokensRes = await fetch(
                        `https://deep-index.moralis.io/api/v2.2/${address}/erc20?chain=${chain}`,
                        { headers: { 'X-API-Key': moralisKey } }
                    );
                    
                    if (tokensRes.ok) {
                        const data = await tokensRes.json();
                        
                        for (const t of data) {
                            const balance = parseFloat(t.balance) / Math.pow(10, t.decimals || 18);
                            if (balance <= 0) continue;
                            
                            const symbol = (t.symbol || 'UNKNOWN').toUpperCase();
                            let price = prices[symbol] || 0;
                            
                            if (price === 0) {
                                try {
                                    const priceRes = await fetch(
                                        `https://deep-index.moralis.io/api/v2.2/erc20/${t.token_address}/price?chain=${chain}`,
                                        { headers: { 'X-API-Key': moralisKey } }
                                    );
                                    if (priceRes.ok) {
                                        const priceData = await priceRes.json();
                                        price = priceData.usdPrice || 0;
                                    }
                                } catch (e) {}
                            }
                            
                            const valueUSD = balance * price;
                            
                            // Verifica se il token √® nella lista CoinGecko verificata
                            const verified = isVerifiedToken(chain, t.token_address);
                            
                            // Se il simbolo √® di un token famoso ma il contract NON √® verificato, √® FAKE
                            const famousSymbols = ['AAVE', 'UNI', 'LINK', 'DAI', 'USDC', 'USDT', 'WBTC', 'WETH', 'CAKE', 'COMP', 'MKR', 'BAT', 'ARB'];
                            if (famousSymbols.includes(symbol) && verified === false) {
                                console.log(`üö´ FAKE ${symbol} filtered - contract not verified:`, t.token_address);
                                continue;
                            }
                            
                            // Token noti (nativi + verificati)
                            const isKnownToken = ['ETH','BNB','MATIC','AVAX','BTC','WBTC','WETH','USDT','USDC','DAI','CAKE','UNI','AAVE','LINK','SHIB','BONE','PLS','PLSX','HEX','SOL'].includes(symbol);
                            
                            // Filtra token sconosciuti con valore > $100k
                            if (!isKnownToken && !verified && valueUSD > 100000) {
                                console.log('üö´ Suspicious token filtered:', symbol, 'value:', valueUSD);
                                continue;
                            }
                            
                            // Filtra token con prezzo irrealistico (>$50k per token, esclusi BTC/ETH)
                            if (!isKnownToken && !verified && price > 50000) {
                                console.log('üö´ Unrealistic price filtered:', symbol, 'price:', price);
                                continue;
                            }
                            
                            // Se √® verificato, usa il prezzo CoinGecko (pi√π affidabile)
                            let finalPrice = price;
                            if (verified && verified.coingecko && prices[symbol]) {
                                finalPrice = prices[symbol];
                            }
                            
                            const finalValueUSD = balance * finalPrice;
                            
                            tokens.push({
                                symbol, name: t.name || symbol, chain, balance, 
                                price: finalPrice,
                                valueUSD: finalValueUSD,
                                logo: t.logo || t.thumbnail || getTokenLogo(symbol),
                                contractAddress: t.token_address,
                                verified: verified ? true : false
                            });
                        }
                    }
                    
                    await new Promise(r => setTimeout(r, 100));
                } catch (e) {
                    console.error(`${chain} error:`, e);
                }
            }
            
            // PulseChain (solo per EVM)
            if (address.startsWith('0x')) {
                const pulseTokens = await getPulseChainTokens(address);
                tokens.push(...pulseTokens);
            }
            
            return tokens;
        }
        
        // ==================== MORALIS SOLANA ====================
        async function getMoralisSolanaBalances(address) {
            const moralisKey = localStorage.getItem('moralis_key');
            const tokens = [];
            
            if (!moralisKey) {
                console.log('No Moralis key for Solana');
                return tokens;
            }
            
            console.log('üîç Moralis Solana scan:', address);
            
            try {
                // Get SOL balance
                const solRes = await fetch(
                    `https://solana-gateway.moralis.io/account/mainnet/${address}/balance`,
                    { headers: { 'X-API-Key': moralisKey } }
                );
                
                if (solRes.ok) {
                    const data = await solRes.json();
                    const balance = parseFloat(data.solana) || 0;
                    console.log('üí∞ Moralis SOL balance:', balance);
                    
                    if (balance > 0) {
                        tokens.push({
                            symbol: 'SOL',
                            name: 'Solana',
                            chain: 'solana',
                            balance,
                            price: prices['SOL'] || 0,
                            valueUSD: balance * (prices['SOL'] || 0),
                            logo: getTokenLogo('SOL'),
                            contractAddress: 'native'
                        });
                    }
                } else {
                    console.log('‚ùå Moralis SOL error:', solRes.status);
                }
                
                // Get SPL tokens
                const tokensRes = await fetch(
                    `https://solana-gateway.moralis.io/account/mainnet/${address}/tokens`,
                    { headers: { 'X-API-Key': moralisKey } }
                );
                
                if (tokensRes.ok) {
                    const data = await tokensRes.json();
                    console.log('üì¶ Moralis SPL tokens:', data.length || 0);
                    
                    for (const t of data) {
                        const balance = parseFloat(t.amount) || 0;
                        if (balance <= 0) continue;
                        
                        const symbol = (t.symbol || 'UNKNOWN').toUpperCase();
                        let price = prices[symbol] || 0;
                        
                        // Prova a ottenere il prezzo da Moralis
                        if (price === 0 && t.mint) {
                            try {
                                const priceRes = await fetch(
                                    `https://solana-gateway.moralis.io/token/mainnet/${t.mint}/price`,
                                    { headers: { 'X-API-Key': moralisKey } }
                                );
                                if (priceRes.ok) {
                                    const priceData = await priceRes.json();
                                    price = priceData.usdPrice || 0;
                                }
                            } catch (e) {}
                        }
                        
                        tokens.push({
                            symbol,
                            name: t.name || symbol,
                            chain: 'solana',
                            balance,
                            price,
                            valueUSD: balance * price,
                            logo: t.logo || getTokenLogo(symbol),
                            contractAddress: t.mint || 'unknown'
                        });
                        
                        console.log(`‚úÖ Found ${symbol}: ${balance} ($${(balance * price).toFixed(2)})`);
                    }
                } else {
                    console.log('‚ùå Moralis tokens error:', tokensRes.status);
                }
            } catch (e) {
                console.error('Moralis Solana error:', e);
            }
            
            return tokens;
        }
        
        async function getPulseChainTokens(address) {
            const tokens = [];
            
            try {
                const res = await fetch('https://rpc.pulsechain.com', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        jsonrpc: '2.0', method: 'eth_getBalance',
                        params: [address, 'latest'], id: 1
                    })
                });
                const data = await res.json();
                if (data.result) {
                    const balance = parseInt(data.result, 16) / 1e18;
                    if (balance > 0) {
                        const price = prices['PLS'] || 0;
                        tokens.push({
                            symbol: 'PLS', name: 'PulseChain', chain: 'pulse',
                            balance, price, valueUSD: balance * price,
                            logo: getTokenLogo('PLS'), contractAddress: 'native'
                        });
                    }
                }
                
                const pulseTokensList = [
                    { address: '0x95B303987A60C71504D99Aa1b13B4DA07b0790ab', symbol: 'PLSX', name: 'PulseX', decimals: 18 },
                    { address: '0x2b591e99afE9f32eAA6214f7B7629768c40Eeb39', symbol: 'HEX', name: 'HEX', decimals: 8 },
                    { address: '0x2fa878Ab3F87CC1C9737Fc071108F904c0B0C95d', symbol: 'INC', name: 'Incentive', decimals: 18 }
                ];
                
                const balanceOfData = '0x70a08231000000000000000000000000' + address.slice(2);
                
                for (const t of pulseTokensList) {
                    try {
                        const res = await fetch('https://rpc.pulsechain.com', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                jsonrpc: '2.0', method: 'eth_call',
                                params: [{ to: t.address, data: balanceOfData }, 'latest'], id: 1
                            })
                        });
                        const result = await res.json();
                        if (result.result && result.result !== '0x' && result.result !== '0x0') {
                            const balance = parseInt(result.result, 16) / Math.pow(10, t.decimals);
                            if (balance > 0) {
                                const price = prices[t.symbol] || 0;
                                tokens.push({
                                    symbol: t.symbol, name: t.name, chain: 'pulse',
                                    balance, price, valueUSD: balance * price,
                                    logo: getTokenLogo(t.symbol), contractAddress: t.address
                                });
                            }
                        }
                    } catch (e) {}
                }
            } catch (e) {
                console.error('PulseChain error:', e);
            }
            
            return tokens;
        }
        
        // ==================== SOLANA ====================
        const SOLANA_RPCS = [
            'https://rpc.ankr.com/solana',
            'https://solana-mainnet.g.alchemy.com/v2/demo',
            'https://api.mainnet-beta.solana.com',
            'https://solana.public-rpc.com'
        ];
        
        async function getSolanaTokens(address) {
            const tokens = [];
            
            // Check if it's a Solana address (base58, 32-44 chars, no 0x)
            if (address.startsWith('0x') || address.length < 32 || address.length > 44) {
                console.log('‚ùå Not a Solana address:', address);
                return tokens;
            }
            
            console.log('üîç Scanning Solana wallet:', address);
            
            let rpcWorked = false;
            
            for (const rpc of SOLANA_RPCS) {
                if (rpcWorked) break;
                
                try {
                    console.log('üåê Trying RPC:', rpc);
                    
                    // Get SOL balance with timeout
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 10000);
                    
                    const solRes = await fetch(rpc, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            jsonrpc: '2.0',
                            id: 1,
                            method: 'getBalance',
                            params: [address]
                        }),
                        signal: controller.signal
                    });
                    
                    clearTimeout(timeoutId);
                    
                    if (!solRes.ok) {
                        console.log('‚ùå RPC HTTP error:', rpc, solRes.status);
                        continue;
                    }
                    
                    const solData = await solRes.json();
                    console.log('üì¶ SOL response:', solData);
                    
                    if (solData.error) {
                        console.log('‚ùå RPC error:', solData.error);
                        continue;
                    }
                    
                    rpcWorked = true;
                    console.log('‚úÖ RPC working:', rpc);
                    
                    // SOL balance (anche se 0, teniamo traccia)
                    const solBalance = (solData.result?.value || 0) / 1e9;
                    console.log('üí∞ SOL balance:', solBalance);
                    
                    if (solBalance > 0) {
                        const price = prices['SOL'] || 0;
                        tokens.push({
                            symbol: 'SOL',
                            name: 'Solana',
                            chain: 'solana',
                            balance: solBalance,
                            price,
                            valueUSD: solBalance * price,
                            logo: getTokenLogo('SOL'),
                            contractAddress: 'native'
                        });
                        console.log('‚úÖ Added SOL:', solBalance);
                    }
                    
                    // Get SPL token accounts
                    console.log('üîç Fetching SPL tokens...');
                    const tokenRes = await fetch(rpc, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            jsonrpc: '2.0',
                            id: 1,
                            method: 'getTokenAccountsByOwner',
                            params: [
                                address,
                                { programId: 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' },
                                { encoding: 'jsonParsed' }
                            ]
                        })
                    });
                    
                    const tokenData = await tokenRes.json();
                    const tokenCount = tokenData.result?.value?.length || 0;
                    console.log('üì¶ SPL Token accounts found:', tokenCount);
                    
                    if (tokenData.result && tokenData.result.value) {
                        // Known Solana tokens mapping
                        const SOLANA_TOKENS = {
                            'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v': { symbol: 'USDC', name: 'USD Coin', decimals: 6 },
                            'Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB': { symbol: 'USDT', name: 'Tether', decimals: 6 },
                            '4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R': { symbol: 'RAY', name: 'Raydium', decimals: 6 },
                            'DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263': { symbol: 'BONK', name: 'Bonk', decimals: 5 },
                            'JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN': { symbol: 'JUP', name: 'Jupiter', decimals: 6 },
                            'EKpQGSJtjMFqKZ9KQanSqYXRcF8fBopzLHYxdM65zcjm': { symbol: 'WIF', name: 'dogwifhat', decimals: 6 },
                            'HZ1JovNiVvGrGNiiYvEozEVgZ58xaU3RKwX8eACQBCt3': { symbol: 'PYTH', name: 'Pyth Network', decimals: 6 },
                            'jtojtomepa8beP8AuQc6eXt5FriJwfFMwQx2v2f9mCL': { symbol: 'JTO', name: 'Jito', decimals: 9 },
                            'rndrizKT3MK1iimdxRdWabcF7Zg7AR5T4nud4EkHBof': { symbol: 'RENDER', name: 'Render', decimals: 8 },
                            'orcaEKTdK7LKz57vaAYr9QeNsVEPfiu6QeMU1kektZE': { symbol: 'ORCA', name: 'Orca', decimals: 6 }
                        };
                        
                        for (const account of tokenData.result.value) {
                            try {
                                const info = account.account.data.parsed.info;
                                const mint = info.mint;
                                const balance = parseFloat(info.tokenAmount.uiAmount) || 0;
                                
                                if (balance <= 0) continue;
                                
                                let tokenInfo = SOLANA_TOKENS[mint];
                                let symbol = tokenInfo?.symbol || 'SPL';
                                let name = tokenInfo?.name || mint.slice(0,8) + '...';
                                
                                // Try to get price
                                let price = prices[symbol] || 0;
                                
                                // Add all tokens with balance
                                tokens.push({
                                    symbol,
                                    name,
                                    chain: 'solana',
                                    balance,
                                    price,
                                    valueUSD: balance * price,
                                    logo: getTokenLogo(symbol),
                                    contractAddress: mint
                                });
                                console.log('‚úÖ Found SPL token:', symbol, balance);
                            } catch (e) {
                                console.error('SPL token parse error:', e);
                            }
                        }
                    }
                    
                } catch (e) {
                    console.error('Solana RPC error:', rpc, e);
                }
            }
            
            if (!rpcWorked) {
                console.error('‚ùå All Solana RPCs failed');
            }
            
            return tokens;
        }
        
        function isSolanaAddress(address) {
            // Solana addresses are base58 encoded, 32-44 characters, no 0x prefix
            if (address.startsWith('0x')) return false;
            if (address.length < 32 || address.length > 44) return false;
            // Check for valid base58 characters
            return /^[1-9A-HJ-NP-Za-km-z]+$/.test(address);
        }
        
        async function getFallbackBalances(address) {
            const tokens = [];
            const rpcs = {
                eth: 'https://eth.llamarpc.com',
                bsc: 'https://bsc-dataseed.binance.org',
                polygon: 'https://polygon-rpc.com',
                base: 'https://mainnet.base.org',
                pulse: 'https://rpc.pulsechain.com'
            };
            
            const nativeSymbols = {
                eth: 'ETH', bsc: 'BNB', polygon: 'MATIC', base: 'ETH', pulse: 'PLS'
            };
            
            for (const [chain, rpc] of Object.entries(rpcs)) {
                try {
                    const res = await fetch(rpc, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            jsonrpc: '2.0', method: 'eth_getBalance',
                            params: [address, 'latest'], id: 1
                        })
                    });
                    const data = await res.json();
                    if (data.result) {
                        const balance = parseInt(data.result, 16) / 1e18;
                        if (balance > 0.0001) {
                            const symbol = nativeSymbols[chain];
                            tokens.push({
                                symbol, name: CHAINS[chain]?.name || chain, chain, balance,
                                price: prices[symbol] || 0,
                                valueUSD: balance * (prices[symbol] || 0),
                                logo: getTokenLogo(symbol), contractAddress: 'native'
                            });
                        }
                    }
                } catch (e) {}
            }
            
            const pulseTokens = await getPulseChainTokens(address);
            tokens.push(...pulseTokens);
            
            return tokens;
        }
        
        // ==================== SCAN ====================
        async function scanAllWallets() {
            if (wallets.length === 0) {
                const input = document.getElementById('walletInput').value.trim().toLowerCase();
                if (input && input.startsWith('0x') && input.length === 42) {
                    wallets.push({
                        address: input,
                        name: document.getElementById('walletName').value.trim() || 'Wallet 1',
                        tokens: [], totalUSD: 0
                    });
                    document.getElementById('walletInput').value = '';
                    document.getElementById('walletName').value = '';
                    saveWallets();
                } else {
                    alert('Aggiungi almeno un wallet');
                    return;
                }
            }
            
            document.getElementById('loadingSection').classList.remove('hidden');
            document.getElementById('resultsSection').classList.add('hidden');
            document.getElementById('aiSection').classList.add('hidden');
            
            document.getElementById('loadingText').textContent = 'Caricamento tasso EUR/USD...';
            await fetchEurUsdRate();
            
            document.getElementById('loadingText').textContent = 'Caricamento prezzi...';
            await fetchPrices();
            
            const moralisKey = localStorage.getItem('moralis_key');
            
            for (let i = 0; i < wallets.length; i++) {
                const wallet = wallets[i];
                document.getElementById('loadingText').textContent = `Scansione ${i + 1}/${wallets.length}: ${wallet.name}...`;
                
                // Check if it's a Solana address
                if (isSolanaAddress(wallet.address)) {
                    document.getElementById('loadingText').textContent = `Scansione Solana ${i + 1}/${wallets.length}: ${wallet.name}...`;
                    
                    // Prova prima Moralis (pi√π affidabile)
                    if (moralisKey) {
                        console.log('üîç Using Moralis for Solana');
                        wallet.tokens = await getMoralisSolanaBalances(wallet.address);
                    }
                    
                    // Se Moralis non ha trovato nulla, prova RPC diretto
                    if (!wallet.tokens || wallet.tokens.length === 0) {
                        console.log('üîç Fallback to direct RPC for Solana');
                        wallet.tokens = await getSolanaTokens(wallet.address);
                    }
                } else {
                    // EVM chains (Ethereum, BSC, etc.)
                    wallet.tokens = await getMoralisBalances(wallet.address);
                }
                
                // Carica NFT
                if (moralisKey) {
                    document.getElementById('loadingText').textContent = `NFT ${i + 1}/${wallets.length}: ${wallet.name}...`;
                    wallet.nfts = await getMoralisNFTs(wallet.address);
                }
                
                wallet.totalUSD = wallet.tokens.reduce((s, t) => s + (t.valueUSD || 0), 0);
                
                await new Promise(r => setTimeout(r, 200));
            }
            
            lastScanDate = new Date().toISOString();
            saveWallets();
            
            // Aggiorna NFT
            updateAllNfts();
            renderNFTs();
            
            document.getElementById('loadingSection').classList.add('hidden');
            document.getElementById('resultsSection').classList.remove('hidden');
            
            updateFiscalDisplay();
            renderResults();
        }
        
        function updateFiscalDisplay() {
            const fiscalDate = document.getElementById('fiscalDate').value;
            const year = fiscalDate.split('-')[0];
            const dateFormatted = fiscalDate.split('-').reverse().join('/');
            
            document.getElementById('fiscalYear').textContent = `(Anno ${year})`;
            document.getElementById('rwDate').textContent = dateFormatted;
        }
        
        // ==================== RENDER ====================
        function renderResults() {
            const filterScam = document.getElementById('filterScam')?.checked ?? true;
            const filterDust = document.getElementById('filterDust')?.checked ?? true;
            const filterHiddenCheck = document.getElementById('filterHidden')?.checked ?? true;
            
            let totalUSD = 0;
            let totalTokens = 0;
            let hiddenCount = 0;
            const allChains = new Set();
            
            wallets.forEach(wallet => {
                wallet._filteredTokens = wallet.tokens.filter(token => {
                    const tokenIsScam = isScam(token);
                    const tokenIsHidden = isHidden(token);
                    const tokenIsDust = (token.valueUSD || 0) < 1;
                    
                    token._isScam = tokenIsScam;
                    token._isHidden = tokenIsHidden;
                    token._isDust = tokenIsDust;
                    
                    let show = true;
                    
                    if (filterScam && tokenIsScam) show = false;
                    if (show && filterDust && tokenIsDust) show = false;
                    if (show && filterHiddenCheck && tokenIsHidden) show = false;
                    
                    if (!show) hiddenCount++;
                    
                    if (show) {
                        totalUSD += token.valueUSD || 0;
                        totalTokens++;
                        allChains.add(token.chain);
                    }
                    
                    return show;
                });
                
                wallet._filteredUSD = wallet._filteredTokens.reduce((s, t) => s + (t.valueUSD || 0), 0);
            });
            
            // Summary - con controlli null
            const totalWalletsEl = document.getElementById('totalWallets');
            const totalTokensEl = document.getElementById('totalTokens');
            const totalChainsEl = document.getElementById('totalChains');
            const totalValueEl = document.getElementById('totalValue');
            const filterStatsEl = document.getElementById('filterStats');
            const totalValueEurEl = document.getElementById('totalValueEur');
            const rwValueEl = document.getElementById('rwValue');
            const ivafeEl = document.getElementById('ivafe');
            
            if (totalWalletsEl) totalWalletsEl.textContent = wallets.length;
            if (totalTokensEl) totalTokensEl.textContent = totalTokens;
            if (totalChainsEl) totalChainsEl.textContent = allChains.size;
            if (totalValueEl) totalValueEl.textContent = `$${totalUSD.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
            if (filterStatsEl) filterStatsEl.textContent = `${hiddenCount} nascosti`;
            
            // EUR values
            const eurValue = totalUSD * EUR_USD;
            if (totalValueEurEl) totalValueEurEl.textContent = `‚Ç¨${eurValue.toLocaleString('it-IT', { minimumFractionDigits: 2 })}`;
            if (rwValueEl) rwValueEl.textContent = `‚Ç¨${eurValue.toLocaleString('it-IT', { minimumFractionDigits: 2 })}`;
            if (ivafeEl) ivafeEl.textContent = `‚Ç¨${(eurValue * 0.002).toLocaleString('it-IT', { minimumFractionDigits: 2 })}`;
            
            // Wallets container
            const container = document.getElementById('walletsContainer');
            container.innerHTML = wallets.map((wallet, wIdx) => {
                const chainGroups = {};
                wallet._filteredTokens.forEach(token => {
                    if (!chainGroups[token.chain]) chainGroups[token.chain] = [];
                    chainGroups[token.chain].push(token);
                });
                
                const sortedChains = Object.entries(chainGroups)
                    .map(([chain, tokens]) => ({
                        chain,
                        tokens: tokens.sort((a, b) => (b.valueUSD || 0) - (a.valueUSD || 0)),
                        totalUSD: tokens.reduce((s, t) => s + (t.valueUSD || 0), 0)
                    }))
                    .sort((a, b) => b.totalUSD - a.totalUSD);
                
                return `
                    <div class="wallet-card">
                        <div class="wallet-header" onclick="toggleWallet(${wIdx})">
                            <div class="wallet-left">
                                <div class="wallet-icon">üíº</div>
                                <div>
                                    <input type="text" class="wallet-name" value="${wallet.name}"
                                        onclick="event.stopPropagation()"
                                        onchange="updateWalletName('${wallet.address}', this.value)">
                                    <div class="wallet-address">${wallet.address.slice(0, 8)}...${wallet.address.slice(-6)}</div>
                                </div>
                            </div>
                            <div class="wallet-right">
                                <div>
                                    <div class="wallet-value">$${wallet._filteredUSD.toLocaleString('en-US', { minimumFractionDigits: 2 })}</div>
                                    <div class="wallet-tokens">${wallet._filteredTokens.length} token ‚Ä¢ ${sortedChains.length} chain</div>
                                </div>
                                <div class="wallet-toggle" id="wallet-toggle-${wIdx}">‚ñº</div>
                            </div>
                        </div>
                        <div class="wallet-content" id="wallet-content-${wIdx}">
                            ${sortedChains.map((chainData, cIdx) => {
                                const chainInfo = CHAINS[chainData.chain] || { name: chainData.chain, icon: 'üîó' };
                                return `
                                    <div class="chain-section">
                                        <div class="chain-header" onclick="toggleChain(${wIdx}, ${cIdx})">
                                            <div class="chain-left">
                                                <div class="chain-icon">${chainInfo.icon}</div>
                                                <div class="chain-name">${chainInfo.name}</div>
                                                <div class="chain-count">(${chainData.tokens.length} token)</div>
                                            </div>
                                            <div style="display:flex;align-items:center;">
                                                <div class="chain-value">$${chainData.totalUSD.toLocaleString('en-US', { minimumFractionDigits: 2 })}</div>
                                                <div class="chain-toggle" id="chain-toggle-${wIdx}-${cIdx}">‚ñº</div>
                                            </div>
                                        </div>
                                        <div class="chain-content" id="chain-content-${wIdx}-${cIdx}">
                                            <div class="token-list">
                                                ${chainData.tokens.map(token => `
                                                    <div class="token-item ${token._isScam ? 'scam' : ''}" id="token-${token.chain}-${token.contractAddress}">
                                                        <div class="token-left">
                                                            <button class="hide-btn" onclick="event.stopPropagation(); hideTokenKeepOpen('${token.chain}', '${token.contractAddress}', '${token.symbol}', '${(token.name || '').replace(/'/g, "\\'")}', ${wIdx}, ${cIdx})" title="Elimina per sempre">üóëÔ∏è</button>
                                                            ${token.logo 
                                                                ? `<img src="${token.logo}" class="token-logo" onerror="this.style.display='none'">`
                                                                : `<div class="token-logo">${token.symbol.slice(0, 3)}</div>`}
                                                            <div>
                                                                <div class="token-symbol">
                                                                    ${token.symbol}
                                                                    ${token._isScam ? '<span class="token-badge scam">‚ö†Ô∏è SCAM</span>' : ''}
                                                                </div>
                                                                <div class="token-name">${token.name}</div>
                                                            </div>
                                                        </div>
                                                        <div style="display:flex;align-items:center;gap:15px;">
                                                            <div style="text-align:right;">
                                                                <div class="token-balance">${formatBalance(token.balance)}</div>
                                                                <div class="token-price">@$${(token.price || 0).toFixed(6)}</div>
                                                            </div>
                                                            <div class="token-value">$${(token.valueUSD || 0).toLocaleString('en-US', { minimumFractionDigits: 2 })}</div>
                                                        </div>
                                                    </div>
                                                `).join('')}
                                            </div>
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        function toggleWallet(idx) {
            const content = document.getElementById(`wallet-content-${idx}`);
            const toggle = document.getElementById(`wallet-toggle-${idx}`);
            content.classList.toggle('open');
            toggle.classList.toggle('open');
        }
        
        function toggleChain(wIdx, cIdx) {
            const content = document.getElementById(`chain-content-${wIdx}-${cIdx}`);
            const toggle = document.getElementById(`chain-toggle-${wIdx}-${cIdx}`);
            content.classList.toggle('open');
            toggle.classList.toggle('open');
        }
        
        function formatBalance(balance) {
            if (!balance) return '0';
            if (balance >= 1e12) return (balance / 1e12).toFixed(2) + 'T';
            if (balance >= 1e9) return (balance / 1e9).toFixed(2) + 'B';
            if (balance >= 1e6) return (balance / 1e6).toFixed(2) + 'M';
            if (balance >= 1e3) return (balance / 1e3).toFixed(2) + 'K';
            if (balance >= 1) return balance.toFixed(4);
            return balance.toFixed(8);
        }
        
        // ==================== EXPORT CSV ====================
        function exportCSV() {
            const fiscalDate = `${selectedYear}-12-31`;
            let csv = 'Wallet,Chain,Token,Name,Balance,Price USD,Value USD,Value EUR,Rate EUR/USD,Data\n';
            wallets.forEach(w => {
                (w._filteredTokens || w.tokens).forEach(t => {
                    const valueEur = (t.valueUSD || 0) * EUR_USD;
                    csv += `"${w.name}","${t.chain}","${t.symbol}","${t.name}",${t.balance},${t.price},${t.valueUSD},${valueEur.toFixed(2)},${EUR_USD},${fiscalDate}\n`;
                });
            });
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `crypto_${fiscalDate}.csv`;
            link.click();
        }
        
        function exportCSVFiscale() {
            const year = selectedYear;
            const fiscalDate = `31/12/${year}`;
            
            let totalUSD = 0;
            let totalEUR = 0;
            
            // Get staking value for this year
            const yearStaking = stakingTokens.filter(t => t.year === year);
            const stakingEUR = yearStaking.reduce((s, t) => s + (t.valueEur || 0), 0);
            
            let csv = `RIEPILOGO FISCALE CRYPTO - ANNO ${year}\n`;
            csv += `Data riferimento: ${fiscalDate}\n`;
            csv += `Tasso EUR/USD: ${EUR_USD.toFixed(4)}\n\n`;
            csv += 'Wallet,Indirizzo,Valore USD,Valore EUR\n';
            
            wallets.forEach(w => {
                const usd = w._filteredUSD || w.totalUSD;
                const eur = usd * EUR_USD;
                totalUSD += usd;
                totalEUR += eur;
                csv += `"${w.name}","${w.address}",${usd.toFixed(2)},${eur.toFixed(2)}\n`;
            });
            
            csv += `\nWALLET TOTALE,,${totalUSD.toFixed(2)},${totalEUR.toFixed(2)}\n`;
            
            // Add staking section
            if (yearStaking.length > 0) {
                csv += `\n--- STAKING ---\n`;
                csv += 'Piattaforma,Token,Quantit√†,Valore EUR\n';
                yearStaking.forEach(s => {
                    csv += `"${s.platform}","${s.token}",${s.amount},${s.valueEur.toFixed(2)}\n`;
                });
                csv += `STAKING TOTALE,,,${stakingEUR.toFixed(2)}\n`;
            }
            
            const grandTotalEUR = totalEUR + stakingEUR;
            csv += `\n--- TOTALE GENERALE ---\n`;
            csv += `QUADRO RW: ‚Ç¨${grandTotalEUR.toFixed(2)}\n`;
            csv += `IVAFE (0.2%): ‚Ç¨${(grandTotalEUR * 0.002).toFixed(2)}\n`;
            csv += `Codice F24: 4043\n`;
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `crypto_fiscale_${year}.csv`;
            link.click();
        }
        
        // ==================== AI ====================
        async function analyzeWithAI() {
            const apiKey = localStorage.getItem('claude_key');
            const aiSection = document.getElementById('aiSection');
            const aiResponse = document.getElementById('aiResponse');
            
            aiSection.classList.remove('hidden');
            aiResponse.innerHTML = '<div class="loading"><div class="loading-spinner"></div> Analisi AI...</div>';
            
            const totalUSD = wallets.reduce((s, w) => s + (w._filteredUSD || w.totalUSD), 0);
            const fiscalDate = `${selectedYear}-12-31`;
            
            const summary = {
                dataRiferimento: fiscalDate,
                tassoEurUsd: EUR_USD,
                wallets: wallets.map(w => ({
                    name: w.name,
                    totalUSD: w._filteredUSD || w.totalUSD,
                    tokens: (w._filteredTokens || w.tokens)
                        .sort((a, b) => b.valueUSD - a.valueUSD)
                        .slice(0, 5)
                        .map(t => ({ symbol: t.symbol, chain: t.chain, valueUSD: t.valueUSD }))
                })),
                totalUSD,
                totalEUR: totalUSD * EUR_USD,
                ivafe: totalUSD * EUR_USD * 0.002
            };
            
            if (apiKey) {
                try {
                    const res = await fetch('https://api.anthropic.com/v1/messages', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'x-api-key': apiKey,
                            'anthropic-version': '2023-06-01',
                            'anthropic-dangerous-direct-browser-access': 'true'
                        },
                        body: JSON.stringify({
                            model: 'claude-sonnet-4-20250514',
                            max_tokens: 2500,
                            messages: [{
                                role: 'user',
                                content: `Analizza portafoglio crypto per fiscalit√† italiana:\n\n${JSON.stringify(summary, null, 2)}\n\nFornisci:\n1. üìä RIEPILOGO\n2. üáÆüáπ FISCALE: RW, IVAFE, RT\n3. ‚ö†Ô∏è RISCHI\n4. ‚úÖ AZIONI\n\nItaliano, conciso.`
                            }]
                        })
                    });
                    const data = await res.json();
                    aiResponse.innerHTML = data.content[0].text;
                } catch (e) {
                    aiResponse.innerHTML = '‚ùå Errore: ' + e.message;
                }
            } else {
                const eurValue = totalUSD * EUR_USD;
                aiResponse.innerHTML = `üìä RIEPILOGO:
‚Ä¢ ${wallets.length} wallet analizzati
‚Ä¢ $${totalUSD.toFixed(2)} (~‚Ç¨${eurValue.toFixed(2)})
‚Ä¢ Tasso EUR/USD: ${EUR_USD.toFixed(4)}

üáÆüáπ FISCALE:
‚Ä¢ Quadro RW: ‚Ç¨${eurValue.toFixed(2)}
‚Ä¢ IVAFE (0,2%): ‚Ç¨${(eurValue * 0.002).toFixed(2)}
‚Ä¢ Codice F24: 4043

‚ö†Ô∏è Inserisci Claude API per analisi completa`;
            }
        }
        
        // ==================== YEAR SELECTION ====================
        function selectYear(year) {
            selectedYear = year;
            
            // Update button styles
            document.querySelectorAll('.year-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.textContent == year) btn.classList.add('active');
            });
            
            // Update EUR/USD rate for selected year
            if (HISTORICAL_PRICES[year]) {
                EUR_USD = HISTORICAL_PRICES[year].EUR_USD;
                document.getElementById('rateDisplay').textContent = `EUR/USD: ${EUR_USD.toFixed(4)} (31/12/${year})`;
            } else {
                // Per 2025 usa il tasso corrente
                document.getElementById('rateDisplay').textContent = `EUR/USD: ${EUR_USD.toFixed(4)} (live)`;
            }
            
            updateFiscalDisplay();
            
            // Recalculate values if we have data
            if (wallets.some(w => w.tokens && w.tokens.length > 0)) {
                recalculateWithHistoricalPrices();
            }
            
            // Aggiorna staking list
            renderStakingList();
        }
        
        function recalculateWithHistoricalPrices() {
            const hp = HISTORICAL_PRICES[selectedYear];
            const isCurrentYear = selectedYear === 2025;
            
            console.log('üìÖ Recalculating for year:', selectedYear, 'Historical prices:', hp ? 'YES' : 'NO (using live)');
            
            // Recalculate values using historical prices
            wallets.forEach(wallet => {
                if (wallet.tokens && wallet.tokens.length > 0) {
                    wallet.tokens.forEach(token => {
                        const symbol = (token.symbol || '').toUpperCase();
                        
                        if (isCurrentYear) {
                            // 2025 - usa prezzi live
                            token.historicalPrice = token.price;
                            token.historicalValueUSD = token.valueUSD;
                        } else if (hp && hp[symbol]) {
                            // Anno passato con prezzo storico
                            token.historicalPrice = hp[symbol];
                            token.historicalValueUSD = token.balance * hp[symbol];
                        } else {
                            // Nessun prezzo storico disponibile - usa prezzo corrente
                            token.historicalPrice = token.price;
                            token.historicalValueUSD = token.valueUSD;
                        }
                    });
                    
                    // Ricalcola totale wallet
                    wallet.historicalTotalUSD = wallet.tokens.reduce((s, t) => s + (t.historicalValueUSD || t.valueUSD || 0), 0);
                }
            });
            
            // Aggiorna UI
            updateDashboardTotalsHistorical();
            renderResults();
        }
        
        function updateDashboardTotalsHistorical() {
            let totalUSD = 0;
            let totalTokens = 0;
            const allChains = new Set();
            const tokenValues = [];
            
            wallets.forEach(wallet => {
                if (wallet.tokens && wallet.tokens.length > 0) {
                    wallet.tokens.forEach(token => {
                        if (!isHidden(token)) {
                            const value = token.historicalValueUSD !== undefined ? token.historicalValueUSD : (token.valueUSD || 0);
                            totalUSD += value;
                            totalTokens++;
                            if (token.chain) allChains.add(token.chain);
                            
                            if (value > 0) {
                                tokenValues.push({
                                    symbol: token.symbol,
                                    value: value,
                                    chain: token.chain
                                });
                            }
                        }
                    });
                }
            });
            
            console.log('üìä Dashboard update:', { wallets: wallets.length, totalTokens, totalUSD, chains: allChains.size });
            
            // Aggiorna totali in alto
            const totalWalletsTopEl = document.getElementById('totalWalletsTop');
            const totalTokensTopEl = document.getElementById('totalTokensTop');
            const totalChainsTopEl = document.getElementById('totalChainsTop');
            const totalValueTopEl = document.getElementById('totalValueTop');
            const totalValueEurTopEl = document.getElementById('totalValueEurTop');
            
            if (totalWalletsTopEl) totalWalletsTopEl.textContent = wallets.length;
            if (totalTokensTopEl) totalTokensTopEl.textContent = totalTokens;
            if (totalChainsTopEl) totalChainsTopEl.textContent = allChains.size;
            if (totalValueTopEl) totalValueTopEl.textContent = `$${totalUSD.toLocaleString('en-US', { minimumFractionDigits: 2 })}`;
            
            const eurValue = totalUSD * EUR_USD;
            const eurFormatted = `‚Ç¨${eurValue.toLocaleString('it-IT', { minimumFractionDigits: 2 })}`;
            const ivafeFormatted = `‚Ç¨${(eurValue * 0.002).toLocaleString('it-IT', { minimumFractionDigits: 2 })}`;
            
            if (totalValueEurTopEl) totalValueEurTopEl.textContent = eurFormatted;
            
            // Aggiorna riepilogo fiscale
            const rwTopEl = document.getElementById('rwValueTop');
            const ivafeTopEl = document.getElementById('ivafeTop');
            
            if (rwTopEl) rwTopEl.textContent = eurFormatted;
            if (ivafeTopEl) ivafeTopEl.textContent = ivafeFormatted;
            
            // Aggiorna grafico
            drawPieChart(tokenValues, totalUSD);
        }
        
        function updateFiscalDisplay() {
            // Aggiorna anno in alto
            const rwYearTopEl = document.getElementById('rwYearTop');
            if (rwYearTopEl) rwYearTopEl.textContent = selectedYear;
        }
        
        // ==================== STAKING ====================
        function toggleStakingSection() {
            document.getElementById('stakingContent').classList.toggle('hidden');
        }
        
        function addStakingToken() {
            const platform = document.getElementById('stakingPlatform').value.trim();
            const token = document.getElementById('stakingToken').value.trim().toUpperCase();
            const amount = parseFloat(document.getElementById('stakingAmount').value) || 0;
            const valueEur = parseFloat(document.getElementById('stakingValueEur').value) || 0;
            
            if (!platform || !token || amount <= 0) {
                alert('Compila piattaforma, token e quantit√†');
                return;
            }
            
            stakingTokens.push({
                id: Date.now(),
                platform,
                token,
                amount,
                valueEur,
                year: selectedYear
            });
            
            saveStakingTokens();
            renderStakingList();
            
            // Clear inputs
            document.getElementById('stakingPlatform').value = '';
            document.getElementById('stakingToken').value = '';
            document.getElementById('stakingAmount').value = '';
            document.getElementById('stakingValueEur').value = '';
        }
        
        function removeStakingToken(id) {
            stakingTokens = stakingTokens.filter(t => t.id !== id);
            saveStakingTokens();
            renderStakingList();
        }
        
        function saveStakingTokens() {
            localStorage.setItem('staking_tokens_v8', JSON.stringify(stakingTokens));
            saveToFirebase();
        }
        
        function renderStakingList() {
            const list = document.getElementById('stakingList');
            const total = document.getElementById('stakingTotal');
            
            // Filter by selected year
            const yearTokens = stakingTokens.filter(t => t.year === selectedYear);
            
            if (yearTokens.length === 0) {
                list.innerHTML = '<div style="color:#666;font-size:12px;text-align:center;padding:20px;">Nessun token in staking per il ' + selectedYear + '</div>';
                total.innerHTML = '';
                return;
            }
            
            list.innerHTML = yearTokens.map(t => `
                <div class="staking-item">
                    <div class="staking-item-left">
                        <div>
                            <div class="staking-item-platform">${t.platform}</div>
                            <div class="staking-item-token">${t.token}</div>
                        </div>
                    </div>
                    <div class="staking-item-amount">${t.amount.toLocaleString('it-IT', {maximumFractionDigits: 8})}</div>
                    <div class="staking-item-value">${t.valueEur > 0 ? '‚Ç¨' + t.valueEur.toLocaleString('it-IT', {minimumFractionDigits: 2}) : '-'}</div>
                    <button class="staking-item-remove" onclick="removeStakingToken(${t.id})">‚úï</button>
                </div>
            `).join('');
            
            const totalValue = yearTokens.reduce((s, t) => s + (t.valueEur || 0), 0);
            total.innerHTML = `
                <span>üîí Totale Staking ${selectedYear}</span>
                <span style="color:#00ff88;">‚Ç¨${totalValue.toLocaleString('it-IT', {minimumFractionDigits: 2})}</span>
            `;
            
            // Update fiscal summary to include staking
            updateFiscalWithStaking(totalValue);
        }
        
        function updateFiscalWithStaking(stakingValue) {
            // This will be called to add staking value to RW
            const rwTopEl = document.getElementById('rwValueTop');
            if (!rwTopEl) return;
            
            const currentRW = rwTopEl.textContent;
            const walletValue = parseFloat(currentRW.replace('‚Ç¨', '').replace('.', '').replace(',', '.')) || 0;
        }
        
        // ==================== NFT ====================
        let allNfts = [];
        
        function toggleNftSection() {
            document.getElementById('nftContent').classList.toggle('hidden');
        }
        
        async function getMoralisNFTs(address) {
            const moralisKey = localStorage.getItem('moralis_key');
            const nfts = [];
            
            if (!moralisKey) return nfts;
            
            console.log('üñºÔ∏è Fetching NFTs for:', address);
            
            // Determina se √® Solana o EVM
            if (isSolanaAddress(address)) {
                // Solana NFTs
                try {
                    const res = await fetch(
                        `https://solana-gateway.moralis.io/account/mainnet/${address}/nft`,
                        { headers: { 'X-API-Key': moralisKey } }
                    );
                    
                    if (res.ok) {
                        const data = await res.json();
                        console.log('üì¶ Solana NFTs:', data.length || 0);
                        
                        for (const nft of (data || [])) {
                            const nftName = nft.name || 'Unknown NFT';
                            const nftSymbol = nft.symbol || 'Unknown';
                            
                            // Filtro scam Solana
                            if (isNftScam(nftName, nftSymbol)) {
                                console.log('üö´ Scam NFT filtered:', nftName);
                                continue;
                            }
                            
                            nfts.push({
                                name: nftName,
                                collection: nftSymbol,
                                image: nft.metadata?.image || '',
                                chain: 'solana',
                                mint: nft.mint,
                                floorPrice: 0
                            });
                        }
                    }
                } catch (e) {
                    console.error('Solana NFT error:', e);
                }
            } else {
                // EVM NFTs (Ethereum, Polygon, etc.)
                const chains = ['eth', 'polygon', 'bsc', 'arbitrum', 'base'];
                
                for (const chain of chains) {
                    try {
                        const res = await fetch(
                            `https://deep-index.moralis.io/api/v2.2/${address}/nft?chain=${chain}&format=decimal`,
                            { headers: { 'X-API-Key': moralisKey } }
                        );
                        
                        if (res.ok) {
                            const data = await res.json();
                            
                            for (const nft of (data.result || [])) {
                                let metadata = {};
                                try {
                                    metadata = nft.metadata ? JSON.parse(nft.metadata) : {};
                                } catch (e) {}
                                
                                const nftName = metadata.name || nft.name || `#${nft.token_id}`;
                                const collectionName = nft.name || 'Unknown';
                                
                                // Filtro scam NFT
                                if (isNftScam(nftName, collectionName)) {
                                    console.log('üö´ Scam NFT filtered:', nftName, '- chain:', chain);
                                    continue;
                                }
                                
                                nfts.push({
                                    name: nftName,
                                    collection: collectionName,
                                    image: metadata.image || '',
                                    chain: chain,
                                    contractAddress: nft.token_address,
                                    tokenId: nft.token_id,
                                    floorPrice: nft.floor_price || 0
                                });
                            }
                        }
                        
                        await new Promise(r => setTimeout(r, 100));
                    } catch (e) {
                        console.error(`${chain} NFT error:`, e);
                    }
                }
            }
            
            console.log('‚úÖ Total NFTs found (after filter):', nfts.length);
            return nfts;
        }
        
        // Filtro anti-scam per NFT
        function isNftScam(name, collection) {
            const text = (name + ' ' + collection).toLowerCase();
            
            // Pattern scam comuni
            const SCAM_PATTERNS = [
                /airdrop/i,
                /claim/i,
                /free.*mint/i,
                /voucher/i,
                /\.com/i,
                /\.io/i,
                /\.xyz/i,
                /\.net/i,
                /\.org/i,
                /reward/i,
                /bonus/i,
                /winner/i,
                /congratulation/i,
                /visit/i,
                /http/i,
                /www\./i,
                /\.eth/i,
                /opensea/i,
                /rarible/i,
                /uniswap/i,
                /sushiswap/i,
                /pancake/i,
                /1inch/i,
                /blur\.io/i,
                /looksrare/i,
                /x2y2/i,
                /foundation/i,
                /metamask/i,
                /wallet.*connect/i,
                /\$\d+/i,  // Contiene $ seguito da numeri
                /usdt|usdc|busd/i,
                /limited.*offer/i,
                /act.*now/i,
                /urgent/i,
                /verify/i,
                /update.*required/i
            ];
            
            for (const pattern of SCAM_PATTERNS) {
                if (pattern.test(text)) return true;
            }
            
            // Nome troppo lungo (spesso spam)
            if (name.length > 50) return true;
            
            // Contiene caratteri sospetti
            if (/[<>{}\\\/]/.test(name)) return true;
            
            return false;
        }
        
        function renderNFTs() {
            const grid = document.getElementById('nftGrid');
            const empty = document.getElementById('nftEmpty');
            const countEl = document.getElementById('nftCount');
            const totalEl = document.getElementById('nftTotalValue');
            
            if (allNfts.length === 0) {
                grid.innerHTML = '';
                empty.style.display = 'block';
                countEl.textContent = '(0 NFT)';
                totalEl.textContent = '$0';
                return;
            }
            
            empty.style.display = 'none';
            countEl.textContent = `(${allNfts.length} NFT)`;
            
            // Calcola valore totale (se disponibile floor price)
            const totalValue = allNfts.reduce((s, n) => s + (n.floorPrice || 0), 0);
            totalEl.textContent = totalValue > 0 ? `$${totalValue.toFixed(2)}` : 'N/A';
            
            grid.innerHTML = allNfts.slice(0, 50).map(nft => {
                // Converti IPFS URL
                let imageUrl = nft.image || '';
                if (imageUrl.startsWith('ipfs://')) {
                    imageUrl = imageUrl.replace('ipfs://', 'https://ipfs.io/ipfs/');
                }
                
                return `
                    <div style="background:rgba(139,92,246,0.1);border:1px solid rgba(139,92,246,0.2);border-radius:10px;overflow:hidden;">
                        <div style="width:100%;aspect-ratio:1;background:#1a1a2e;display:flex;align-items:center;justify-content:center;overflow:hidden;">
                            ${imageUrl 
                                ? `<img src="${imageUrl}" style="width:100%;height:100%;object-fit:cover;" onerror="this.style.display='none';this.parentElement.innerHTML='üñºÔ∏è';">` 
                                : 'üñºÔ∏è'}
                        </div>
                        <div style="padding:8px;">
                            <div style="font-size:11px;font-weight:600;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${nft.name}</div>
                            <div style="font-size:10px;color:#888;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${nft.collection}</div>
                            <div style="font-size:9px;color:#8b5cf6;margin-top:4px;">${nft.chain.toUpperCase()}</div>
                        </div>
                    </div>
                `;
            }).join('');
            
            if (allNfts.length > 50) {
                grid.innerHTML += `<div style="display:flex;align-items:center;justify-content:center;color:#888;font-size:12px;">+ ${allNfts.length - 50} altri NFT</div>`;
            }
        }
        
        // ==================== INIT ====================
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('üöÄ Avvio inizializzazione...');
            
            try {
                updateApiStatus();
                console.log('‚úÖ API status updated');
            } catch(e) {
                console.error('‚ùå updateApiStatus error:', e);
            }
            
            try {
                await loadWallets();
                console.log('‚úÖ Wallets loaded:', wallets.length);
            } catch(e) {
                console.error('‚ùå loadWallets error:', e);
                // Prova localStorage come fallback
                const saved = localStorage.getItem('crypto_wallets_v8');
                if (saved) wallets = JSON.parse(saved);
            }
            
            try {
                renderWalletsPreview();
                console.log('‚úÖ Wallets preview rendered');
            } catch(e) {
                console.error('‚ùå renderWalletsPreview error:', e);
            }
            
            try {
                fetchEurUsdRate();
            } catch(e) {
                console.error('‚ùå fetchEurUsdRate error:', e);
            }
            
            try {
                selectYear(2025);
            } catch(e) {
                console.error('‚ùå selectYear error:', e);
            }
            
            try {
                renderStakingList();
            } catch(e) {
                console.error('‚ùå renderStakingList error:', e);
            }
            
            try {
                // Carica NFT dai wallet salvati
                updateAllNfts();
                renderNFTs();
            } catch(e) {
                console.error('‚ùå NFT render error:', e);
            }
            
            try {
                // Aggiorna totali in alto
                updateDashboardTotals();
                console.log('‚úÖ Dashboard totals updated');
            } catch(e) {
                console.error('‚ùå updateDashboardTotals error:', e);
            }
            
            // Se ci sono wallet con token, mostra i risultati
            const hasScannedTokens = wallets.some(w => w.tokens && w.tokens.length > 0);
            if (hasScannedTokens) {
                document.getElementById('resultsSection').classList.remove('hidden');
                try {
                    renderResults();
                } catch(e) {
                    console.error('‚ùå renderResults error:', e);
                }
            }
            
            console.log('üöÄ App inizializzata:', wallets.length, 'wallet caricati');
        });
        
        document.getElementById('walletInput')?.addEventListener('keypress', e => {
            if (e.key === 'Enter') addWallet();
        });
    </script>
</body>
</html>
