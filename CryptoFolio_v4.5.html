<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CryptoFolio v4.5 - Multi-Exchange</title>
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <script>
        const firebaseConfig = {
            apiKey: "AIzaSyDAmtceQc0m-KQC7xGmu0IH1cR4tnI8oCQ",
            authDomain: "moreno-crypto-tools.firebaseapp.com",
            projectId: "moreno-crypto-tools",
            storageBucket: "moreno-crypto-tools.firebasestorage.app",
            messagingSenderId: "875997322481",
            appId: "1:875997322481:web:1a012bec2aff2cb5205d50"
        };
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();
    </script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --bg-primary: #0f0f1a;
            --bg-secondary: #1a1a2e;
            --bg-card: #16213e;
            --text-primary: #ffffff;
            --text-secondary: #a0a0a0;
            --accent: #6c5ce7;
            --accent-light: #a29bfe;
            --green: #00cec9;
            --red: #ff6b6b;
            --border: #2d2d44;
        }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: var(--bg-primary); color: var(--text-primary); min-height: 100vh; }
        .app-container { display: flex; min-height: 100vh; }
        .sidebar { width: 240px; background: var(--bg-secondary); padding: 20px; display: flex; flex-direction: column; border-right: 1px solid var(--border); }
        .logo { display: flex; align-items: center; gap: 12px; margin-bottom: 40px; }
        .logo-icon { width: 40px; height: 40px; background: linear-gradient(135deg, var(--accent), var(--accent-light)); border-radius: 10px; display: flex; align-items: center; justify-content: center; font-size: 20px; }
        .logo-text { font-size: 20px; font-weight: 700; }
        .nav-section { margin-bottom: 30px; }
        .nav-label { font-size: 11px; color: var(--text-secondary); margin-bottom: 12px; text-transform: uppercase; letter-spacing: 1px; }
        .nav-item { display: flex; align-items: center; gap: 12px; padding: 12px 16px; border-radius: 8px; cursor: pointer; transition: all 0.2s; margin-bottom: 4px; }
        .nav-item:hover { background: var(--bg-card); }
        .nav-item.active { background: var(--accent); }
        .nav-item .icon { font-size: 18px; }
        .nav-item .badge { margin-left: auto; background: var(--accent); padding: 2px 8px; border-radius: 10px; font-size: 11px; }
        .nav-item.active .badge { background: rgba(255,255,255,0.2); }
        .sidebar-footer { margin-top: auto; padding-top: 20px; border-top: 1px solid var(--border); }
        .version { font-size: 12px; color: var(--text-secondary); }
        .main-content { flex: 1; padding: 30px; overflow-y: auto; }
        .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 30px; }
        .header h1 { font-size: 28px; font-weight: 600; }
        .header-actions { display: flex; gap: 12px; align-items: center; }
        .btn { padding: 10px 20px; border-radius: 8px; border: none; cursor: pointer; font-size: 14px; font-weight: 500; transition: all 0.2s; }
        .btn-primary { background: var(--accent); color: white; }
        .btn-primary:hover { background: var(--accent-light); }
        .btn-secondary { background: var(--bg-card); color: var(--text-primary); border: 1px solid var(--border); }
        .stats-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px; margin-bottom: 30px; }
        .stat-card { background: var(--bg-card); padding: 24px; border-radius: 16px; border: 1px solid var(--border); }
        .stat-label { font-size: 13px; color: var(--text-secondary); margin-bottom: 8px; }
        .stat-value { font-size: 28px; font-weight: 700; color: var(--green); }
        .stat-change { font-size: 13px; margin-top: 4px; }
        .content-grid { display: grid; grid-template-columns: 2fr 1fr; gap: 20px; }
        .card { background: var(--bg-card); border-radius: 16px; padding: 24px; border: 1px solid var(--border); }
        .card-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
        .card-title { font-size: 18px; font-weight: 600; }
        .holdings-table { width: 100%; border-collapse: collapse; }
        .holdings-table th { text-align: left; padding: 12px 8px; color: var(--text-secondary); font-size: 12px; text-transform: uppercase; border-bottom: 1px solid var(--border); }
        .holdings-table td { padding: 16px 8px; border-bottom: 1px solid var(--border); }
        .holdings-table tr:hover { background: rgba(255,255,255,0.02); }
        .token-cell { display: flex; align-items: center; gap: 12px; }
        .token-icon { width: 36px; height: 36px; border-radius: 50%; background: var(--bg-secondary); display: flex; align-items: center; justify-content: center; font-weight: 600; font-size: 12px; overflow: hidden; }
        .token-icon img { width: 100%; height: 100%; object-fit: cover; }
        .token-info .symbol { font-weight: 600; }
        .token-info .name { font-size: 12px; color: var(--text-secondary); }
        .text-right { text-align: right; }
        .text-mono { font-family: 'SF Mono', Monaco, monospace; }
        .text-secondary { color: var(--text-secondary); }
        .wallet-input-section { background: var(--bg-card); padding: 20px; border-radius: 16px; margin-bottom: 20px; border: 1px solid var(--border); }
        .input-row { display: flex; gap: 16px; margin-bottom: 16px; }
        .input-group { flex: 1; }
        .input-group label { display: block; font-size: 12px; color: var(--text-secondary); margin-bottom: 8px; }
        .input-group input { width: 100%; padding: 12px; background: var(--bg-primary); border: 1px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 14px; }
        .input-group input:focus { outline: none; border-color: var(--accent); }
        .chain-selector { display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 16px; }
        .chain-btn { padding: 8px 14px; border-radius: 8px; border: 1px solid var(--border); background: var(--bg-primary); color: var(--text-secondary); cursor: pointer; font-size: 13px; transition: all 0.2s; display: flex; align-items: center; gap: 6px; }
        .chain-btn:hover { border-color: var(--accent); }
        .chain-btn.active { background: var(--accent); color: white; border-color: var(--accent); }
        .chain-dot { width: 8px; height: 8px; border-radius: 50%; }
        .status-log { background: var(--bg-primary); border-radius: 8px; padding: 12px; max-height: 150px; overflow-y: auto; font-family: 'SF Mono', Monaco, monospace; font-size: 12px; }
        .log-line { padding: 4px 0; }
        .log-line.success { color: var(--green); }
        .log-line.error { color: var(--red); }
        .log-line.info { color: var(--text-secondary); }
        .empty-state { text-align: center; padding: 40px; color: var(--text-secondary); }
        .empty-state .icon { font-size: 48px; margin-bottom: 16px; }
        .verify-link { display: inline-flex; align-items: center; gap: 6px; color: var(--accent-light); font-size: 13px; text-decoration: none; }
        .chain-badge { display: inline-block; font-size: 9px; padding: 2px 6px; border-radius: 4px; margin-left: 6px; font-weight: 600; text-transform: uppercase; }
        .blacklist-item { display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg-primary); border-radius: 8px; margin-bottom: 8px; }
        .btn-restore { background: var(--green); color: white; border: none; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 12px; }
        .hide-btn { background: transparent; border: none; color: var(--text-secondary); cursor: pointer; font-size: 10px; padding: 2px 6px; border-radius: 4px; margin-right: 8px; opacity: 0.5; }
        .hide-btn:hover { background: var(--red); color: white; opacity: 1; }
        .api-status { padding: 6px 12px; border-radius: 6px; font-size: 11px; font-weight: 600; }
        .api-status[id$="Status"] { background: var(--red); color: white; }
        .api-on { background: var(--green) !important; color: #000 !important; }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="sidebar">
            <div class="logo"><div class="logo-icon">üìä</div><span class="logo-text">CryptoFolio</span></div>
            <div class="nav-section">
                <div class="nav-label">Menu</div>
                <div class="nav-item active" onclick="showView('dashboard')"><span class="icon">üìà</span><span>Dashboard</span></div>
                <div class="nav-item" onclick="showView('wallets')"><span class="icon">üëõ</span><span>Wallets</span><span class="badge" id="walletCount">0</span></div>
                <div class="nav-item" onclick="showView('exchanges')"><span class="icon">üè¶</span><span>Exchanges</span><span class="badge" id="exchangeCount">0</span></div>
                <div class="nav-item" onclick="showView('tax')"><span class="icon">üìã</span><span>Tax Report</span></div>
                <div class="nav-item" onclick="showView('api')"><span class="icon">üîå</span><span>API Connect</span><span class="badge" id="apiCount">0</span></div>
            </div>
            <div class="nav-section">
                <div class="nav-label">Settings</div>
                <div class="nav-item" onclick="toggleBlacklist()"><span class="icon">üö´</span><span>Token Nascosti</span><span class="badge" id="blacklistCount">0</span></div>
                <div class="nav-item" onclick="forceSyncFirebase()"><span class="icon">‚òÅÔ∏è</span><span>Force Sync</span></div>
                <div class="nav-item" onclick="clearWalletResults()"><span class="icon">üóëÔ∏è</span><span>Reset Scan</span></div>
            </div>
            <div class="sidebar-footer">
                <div style="display:flex;align-items:center;gap:8px;margin-bottom:8px;">
                    <span class="sync-dot" id="syncDot" style="width:8px;height:8px;border-radius:50%;background:var(--green);"></span>
                    <span id="syncStatus" style="font-size:11px;color:var(--text-secondary);">Connesso</span>
                </div>
                <div class="version">v4.5 - Multi-Exchange</div>
            </div>
        </div>
        
        <!-- DASHBOARD -->
        <div class="main-content" id="dashboardView">
            <div class="header"><h1>Dashboard</h1><div class="header-actions"><span id="lastUpdate" style="font-size:13px;color:var(--text-secondary);"></span><button class="btn btn-secondary" onclick="scanAllWallets()" style="margin-right:8px;">üìä Scan All</button><button class="btn btn-primary" onclick="scanWallet()">üîç Scan</button></div></div>
            
            <div class="wallet-input-section">
                <div class="input-row">
                    <div class="input-group" style="flex:2;">
                        <label>Wallet</label>
                        <div style="display:flex;gap:8px;">
                            <select id="walletSelect" onchange="onWalletSelect()" style="flex:1;padding:12px;background:var(--bg-primary);border:1px solid var(--border);border-radius:8px;color:var(--text-primary);font-size:14px;">
                                <option value="">-- Seleziona o inserisci --</option>
                            </select>
                            <input type="text" id="walletAddress" placeholder="0x... o seleziona sopra" autocomplete="off" style="flex:2;">
                        </div>
                    </div>
                    <div class="input-group"><label>API Key <a href="#" onclick="showView('api');return false;" style="color:var(--accent-light);font-size:11px;margin-left:8px;">‚Üí Configura in API Connect</a></label><input type="text" id="apiKey" placeholder="Configura in API Connect..." autocomplete="off" readonly onclick="showView('api')" style="cursor:pointer;"></div>
                </div>
                <label style="display:block;font-size:12px;color:var(--text-secondary);margin-bottom:8px;">Chains</label>
                <div class="chain-selector" id="chainSelector"></div>
                <div class="status-log" id="statusLog"><div class="log-line info">üëã Configura le API in <strong>API Connect</strong>, seleziona un wallet e clicca "Scan"</div></div>
            </div>
            
            <div class="stats-grid">
                <div class="stat-card"><div class="stat-label">üí∞ Portfolio Value</div><div class="stat-value" id="totalEUR">‚Ç¨0,00</div><div class="stat-change text-secondary" id="totalUSD">$0,00 USD</div></div>
                <div class="stat-card"><div class="stat-label">ü™ô Assets</div><div class="stat-value" id="tokenCount">0</div><div class="stat-change text-secondary">tokens</div></div>
                <div class="stat-card"><div class="stat-label">üëõ Wallets</div><div class="stat-value" id="scannedWallets">0</div><div class="stat-change text-secondary" id="chainNames">-</div></div>
                <div class="stat-card" style="cursor:pointer;" onclick="showView('exchanges')"><div class="stat-label">üè¶ Exchanges</div><div class="stat-value" id="exchangeTotalEUR" style="color:#f3ba2f;">‚Ç¨0,00</div><div class="stat-change text-secondary" id="exchangeNames">Binance</div></div>
                <div class="stat-card"><div class="stat-label">üí± EUR/USD</div><div class="stat-value" id="eurUsdRate">0.849</div><div class="stat-change text-secondary">rate</div></div>
            </div>
            
            <div class="content-grid">
                <div class="card"><div class="card-header"><div class="card-title">Holdings</div></div><div id="holdingsContent"><div class="empty-state"><div class="icon">üëõ</div><h3>Nessun dato</h3></div></div></div>
                <div class="card"><div class="card-header"><div class="card-title">Allocation</div></div><canvas id="allocationChart"></canvas></div>
            </div>
            
            <div class="card" id="blacklistPanel" style="display:none;margin-top:20px;"><div class="card-header"><div class="card-title">üö´ Token Nascosti</div><button class="btn btn-secondary" onclick="clearBlacklist()" style="font-size:12px;padding:6px 12px;">üóëÔ∏è Svuota</button></div><div id="blacklistContent"></div></div>
        </div>
        
        <!-- WALLETS -->
        <div class="main-content" id="walletsView" style="display:none;">
            <div class="header"><h1>üëõ Gestione Wallets</h1></div>
            
            <div class="card" style="margin-bottom:20px;">
                <div class="card-header"><div class="card-title">‚ûï Aggiungi Wallet</div></div>
                <div class="input-row">
                    <div class="input-group"><label>Nome (es. "Main", "Trading", "Cold")</label><input type="text" id="newWalletName" placeholder="Nome wallet..." autocomplete="off"></div>
                    <div class="input-group" style="flex:2;"><label>Indirizzo (EVM o Solana)</label><input type="text" id="newWalletAddress" placeholder="0x... o indirizzo Solana" autocomplete="off"></div>
                </div>
                <button class="btn btn-primary" onclick="addWallet()" style="margin-top:12px;">üíæ Salva Wallet</button>
            </div>
            
            <div class="card">
                <div class="card-header"><div class="card-title">üìã Wallets Salvati</div></div>
                <div id="walletsList"></div>
            </div>
        </div>
        
        <!-- WALLET DETAIL -->
        <div class="main-content" id="walletDetailView" style="display:none;">
            <div class="header">
                <div style="display:flex;align-items:center;gap:16px;">
                    <button class="btn btn-secondary" onclick="showView('wallets')" style="padding:8px 12px;">‚Üê Indietro</button>
                    <h1 id="detailWalletName">Wallet</h1>
                </div>
                <div class="header-actions">
                    <button class="btn btn-primary" onclick="scanDetailWallet()">üîç Scan</button>
                </div>
            </div>
            
            <div class="card" style="margin-bottom:20px;">
                <div style="display:flex;align-items:center;gap:16px;">
                    <div style="width:64px;height:64px;border-radius:16px;background:linear-gradient(135deg,var(--accent),var(--accent-light));display:flex;align-items:center;justify-content:center;font-size:28px;">üëõ</div>
                    <div>
                        <div style="font-size:13px;color:var(--text-secondary);">Indirizzo</div>
                        <div id="detailWalletAddress" style="font-family:monospace;font-size:14px;word-break:break-all;"></div>
                    </div>
                    <button class="btn btn-secondary" onclick="copyDetailAddress()" style="margin-left:auto;padding:8px 12px;">üìã Copia</button>
                </div>
            </div>
            
            <div class="stats-grid" style="grid-template-columns:repeat(3,1fr);">
                <div class="stat-card"><div class="stat-label">üí∞ Totale</div><div class="stat-value" id="detailTotal">‚Ç¨0,00</div></div>
                <div class="stat-card"><div class="stat-label">‚õìÔ∏è Chains</div><div class="stat-value" id="detailChainCount">0</div></div>
                <div class="stat-card"><div class="stat-label">ü™ô Token</div><div class="stat-value" id="detailTokenCount">0</div></div>
            </div>
            
            <div id="detailChainsContent"></div>
        </div>
        
        <!-- TAX REPORT -->
        <div class="main-content" id="taxView" style="display:none;">
            <div class="header"><h1>üìã Tax Report - Quadro RW</h1><div class="header-actions"><button class="btn" onclick="clearTaxReport()" style="margin-right:8px;background:var(--bg-secondary);">üóëÔ∏è Reset</button><button class="btn btn-secondary" onclick="printTaxReport()" style="margin-right:8px;">üñ®Ô∏è Stampa PDF</button><button class="btn btn-primary" onclick="calculateTaxReportAll()">üßÆ Calcola Tutti</button></div></div>
            
            <div class="card" style="margin-bottom:20px;">
                <p style="color:var(--text-secondary);font-size:14px;line-height:1.6;">
                    Il <strong>Quadro RW</strong> richiede il valore al <strong>31 dicembre</strong> di ogni anno fiscale. Soglia: <strong>‚Ç¨15.000</strong>.<br>
                    Calcola il valore aggregato di <strong>wallet + exchange</strong>.
                </p>
                <div id="taxWalletsList" style="margin-top:12px;"></div>
            </div>
            
            <!-- EXCHANGE VALUES -->
            <div class="card" style="margin-bottom:20px;">
                <div class="card-header">
                    <div class="card-title">üè¶ Valori Exchange (31/12)</div>
                    <button class="btn btn-primary" onclick="saveExchangeValues()" style="padding:8px 16px;">üíæ Salva</button>
                </div>
                <p style="color:var(--text-secondary);font-size:13px;margin-bottom:16px;">Inserisci il valore totale degli exchange al 31 dicembre di ogni anno (in EUR). Questi valori verranno sommati ai wallet.</p>
                <div style="display:grid;grid-template-columns:repeat(5,1fr);gap:12px;">
                    <div class="input-group">
                        <label>2021</label>
                        <input type="number" id="exchange2021" placeholder="‚Ç¨" step="0.01" style="text-align:right;">
                    </div>
                    <div class="input-group">
                        <label>2022</label>
                        <input type="number" id="exchange2022" placeholder="‚Ç¨" step="0.01" style="text-align:right;">
                    </div>
                    <div class="input-group">
                        <label>2023</label>
                        <input type="number" id="exchange2023" placeholder="‚Ç¨" step="0.01" style="text-align:right;">
                    </div>
                    <div class="input-group">
                        <label>2024</label>
                        <input type="number" id="exchange2024" placeholder="‚Ç¨" step="0.01" style="text-align:right;">
                    </div>
                    <div class="input-group">
                        <label>2025</label>
                        <input type="number" id="exchange2025" placeholder="‚Ç¨" step="0.01" style="text-align:right;">
                    </div>
                </div>
                <div style="margin-top:12px;font-size:12px;color:var(--text-secondary);">
                    üí° Puoi recuperare questi valori da OKIPO, Binance Tax Report, o i tuoi record personali.
                </div>
            </div>
            
            <div class="card"><div class="card-header"><div class="card-title">üìä Totale Portfolio per Anno (31/12)</div></div><div id="taxReportContent"><div class="empty-state"><div class="icon">üëÜ</div><h3>Clicca "Calcola Tutti" per iniziare</h3></div></div></div>
            <div class="card" id="taxDetailCard" style="display:none;margin-top:20px;"><div class="card-header"><div class="card-title">üìù Dettaglio Token per Wallet</div></div><div id="taxDetailContent"></div></div>
        </div>
        
        <!-- API CONNECT -->
        <div class="main-content" id="apiView" style="display:none;">
            <div class="header"><h1>üîå API Connect</h1></div>
            
            <div class="card" style="margin-bottom:20px;">
                <p style="color:var(--text-secondary);font-size:14px;line-height:1.6;">
                    Configura le API per accedere ai dati blockchain. <strong>Moralis</strong> √® consigliato per scan veloci, <strong>Etherscan</strong> per il Tax Report storico.
                </p>
            </div>
            
            <!-- MORALIS -->
            <div class="card" style="margin-bottom:20px;">
                <div class="card-header">
                    <div class="card-title" style="display:flex;align-items:center;gap:12px;">
                        <span style="width:40px;height:40px;background:#21BF96;border-radius:10px;display:flex;align-items:center;justify-content:center;font-size:20px;">üü¢</span>
                        <div>
                            <div>Moralis</div>
                            <div style="font-size:12px;color:var(--text-secondary);font-weight:normal;">Scan veloce ‚Ä¢ Balance diretti ‚Ä¢ Multi-chain</div>
                        </div>
                    </div>
                    <span class="api-status" id="moralisStatus">OFF</span>
                </div>
                <div class="input-row" style="margin-top:16px;">
                    <div class="input-group" style="flex:3;">
                        <label>API Key <a href="https://admin.moralis.io/api-keys" target="_blank" style="color:var(--accent);font-size:11px;margin-left:8px;">‚Üí Ottieni gratis</a></label>
                        <input type="password" id="moralisKey" placeholder="eyJhbGci..." autocomplete="off">
                    </div>
                    <div class="input-group" style="flex:0;align-self:flex-end;">
                        <button class="btn btn-primary" onclick="saveMoralisKey()">üíæ Salva</button>
                    </div>
                </div>
                <div style="margin-top:12px;padding:12px;background:var(--bg-primary);border-radius:8px;font-size:12px;">
                    <strong>Chains supportate:</strong> Ethereum, BSC, Polygon, Arbitrum, Optimism, Base<br>
                    <strong>Limite free:</strong> 25 req/sec, 10.000/giorno
                </div>
            </div>
            
            <!-- ETHERSCAN -->
            <div class="card" style="margin-bottom:20px;">
                <div class="card-header">
                    <div class="card-title" style="display:flex;align-items:center;gap:12px;">
                        <span style="width:40px;height:40px;background:#21325B;border-radius:10px;display:flex;align-items:center;justify-content:center;font-size:20px;">üîµ</span>
                        <div>
                            <div>Etherscan</div>
                            <div style="font-size:12px;color:var(--text-secondary);font-weight:normal;">Tax Report ‚Ä¢ Storico transazioni ‚Ä¢ Multi-chain V2</div>
                        </div>
                    </div>
                    <span class="api-status" id="etherscanStatus">OFF</span>
                </div>
                <div class="input-row" style="margin-top:16px;">
                    <div class="input-group" style="flex:3;">
                        <label>API Key <a href="https://etherscan.io/myapikey" target="_blank" style="color:var(--accent);font-size:11px;margin-left:8px;">‚Üí Ottieni gratis</a></label>
                        <input type="password" id="etherscanKey" placeholder="ABCDEF..." autocomplete="off">
                    </div>
                    <div class="input-group" style="flex:0;align-self:flex-end;">
                        <button class="btn btn-primary" onclick="saveEtherscanKey()">üíæ Salva</button>
                    </div>
                </div>
                <div style="margin-top:12px;padding:12px;background:var(--bg-primary);border-radius:8px;font-size:12px;">
                    <strong>Chains supportate:</strong> Ethereum, BSC, Polygon, Arbitrum, Optimism, Base (API V2)<br>
                    <strong>Limite free:</strong> 5 req/sec, 100.000/giorno
                </div>
            </div>
            
            <!-- PULSESCAN -->
            <div class="card" style="margin-bottom:20px;">
                <div class="card-header">
                    <div class="card-title" style="display:flex;align-items:center;gap:12px;">
                        <span style="width:40px;height:40px;background:#00ff00;border-radius:10px;display:flex;align-items:center;justify-content:center;font-size:20px;">üíö</span>
                        <div>
                            <div>PulseChain</div>
                            <div style="font-size:12px;color:var(--text-secondary);font-weight:normal;">PulseScan API ‚Ä¢ Gratuito ‚Ä¢ No API key richiesta</div>
                        </div>
                    </div>
                    <span class="api-status" style="background:var(--green);color:#000;">AUTO</span>
                </div>
                <div style="margin-top:12px;padding:12px;background:var(--bg-primary);border-radius:8px;font-size:12px;">
                    <strong>Endpoint:</strong> api.scan.pulsechain.com<br>
                    <strong>Note:</strong> Nessuna configurazione necessaria, funziona automaticamente
                </div>
            </div>
            
            <!-- SOLANA / HELIUS -->
            <div class="card" style="margin-bottom:20px;">
                <div class="card-header">
                    <div class="card-title" style="display:flex;align-items:center;gap:12px;">
                        <span style="width:40px;height:40px;background:#9945ff;border-radius:10px;display:flex;align-items:center;justify-content:center;font-size:20px;">üü£</span>
                        <div>
                            <div>Solana (Helius)</div>
                            <div style="font-size:12px;color:var(--text-secondary);font-weight:normal;">API Veloce ‚Ä¢ Token SPL ‚Ä¢ NFT</div>
                        </div>
                    </div>
                    <span class="api-status" id="heliusStatus">OFF</span>
                </div>
                <div class="input-row" style="margin-top:16px;">
                    <div class="input-group" style="flex:3;">
                        <label>API Key <a href="https://www.helius.dev/" target="_blank" style="color:var(--accent);font-size:11px;margin-left:8px;">‚Üí Ottieni gratis</a></label>
                        <input type="password" id="heliusKey" placeholder="xxx-xxx-xxx..." autocomplete="off">
                    </div>
                    <div class="input-group" style="flex:0;align-self:flex-end;">
                        <button class="btn btn-primary" onclick="saveHeliusKey()">üíæ Salva</button>
                    </div>
                </div>
                <div style="margin-top:12px;padding:12px;background:var(--bg-primary);border-radius:8px;font-size:12px;">
                    <strong>Endpoint:</strong> api.helius.xyz<br>
                    <strong>Limite free:</strong> 30 req/sec, 500.000/mese
                </div>
            </div>
            
            <!-- API STATUS SUMMARY -->
            <div class="card">
                <div class="card-header"><div class="card-title">üìä Riepilogo API</div></div>
                <div id="apiSummary" style="display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:12px;"></div>
            </div>
        </div>
        
        <!-- EXCHANGES -->
        <div class="main-content" id="exchangesView" style="display:none;">
            <div class="header"><h1>üè¶ Exchanges - Import CSV</h1><div class="header-actions"><button class="btn btn-secondary" onclick="clearAllExchangeData()" style="margin-right:8px;">üóëÔ∏è Reset All</button><button class="btn btn-primary" onclick="recalculateAllExchanges()">üßÆ Ricalcola</button></div></div>
            
            <div class="card" style="margin-bottom:20px;">
                <p style="color:var(--text-secondary);font-size:14px;line-height:1.6;">
                    Importa i <strong>CSV delle transazioni</strong> per calcolare i saldi al 31/12 di ogni anno (per il Tax Report).<br>
                    Trascina un <strong>file ZIP</strong> (con cartelle per anno) o <strong>singoli CSV</strong>.
                </p>
            </div>
            
            <!-- TOTALE EXCHANGES -->
            <div class="card" style="margin-bottom:20px;background:linear-gradient(135deg,rgba(243,186,47,0.1),rgba(0,230,118,0.1));">
                <div class="card-header"><div class="card-title">üìä Totale Exchange per Anno (31/12)</div></div>
                <div id="exchangeTotalsGrid" style="display:grid;grid-template-columns:repeat(5,1fr);gap:12px;margin-top:12px;">
                    <div style="background:var(--bg-primary);border-radius:8px;padding:16px;text-align:center;">
                        <div style="font-size:12px;color:var(--text-secondary);">2021</div>
                        <div id="exchTotal2021" style="font-size:18px;font-weight:700;color:var(--green);">‚Ç¨0</div>
                    </div>
                    <div style="background:var(--bg-primary);border-radius:8px;padding:16px;text-align:center;">
                        <div style="font-size:12px;color:var(--text-secondary);">2022</div>
                        <div id="exchTotal2022" style="font-size:18px;font-weight:700;color:var(--green);">‚Ç¨0</div>
                    </div>
                    <div style="background:var(--bg-primary);border-radius:8px;padding:16px;text-align:center;">
                        <div style="font-size:12px;color:var(--text-secondary);">2023</div>
                        <div id="exchTotal2023" style="font-size:18px;font-weight:700;color:var(--green);">‚Ç¨0</div>
                    </div>
                    <div style="background:var(--bg-primary);border-radius:8px;padding:16px;text-align:center;">
                        <div style="font-size:12px;color:var(--text-secondary);">2024</div>
                        <div id="exchTotal2024" style="font-size:18px;font-weight:700;color:var(--green);">‚Ç¨0</div>
                    </div>
                    <div style="background:var(--bg-primary);border-radius:8px;padding:16px;text-align:center;">
                        <div style="font-size:12px;color:var(--text-secondary);">2025</div>
                        <div id="exchTotal2025" style="font-size:18px;font-weight:700;color:var(--green);">‚Ç¨0</div>
                    </div>
                </div>
            </div>
            
            <!-- EXCHANGE GRID -->
            <div id="exchangeGrid" style="display:grid;grid-template-columns:repeat(auto-fill,minmax(280px,1fr));gap:16px;"></div>
        </div>
    </div>
    
    <!-- Hidden elements per evitare errori JS -->
    <div style="display:none;">
        <input id="binanceApiKey"><input id="binanceSecretKey">
        <span id="binanceServerStatus"></span><span id="binanceSyncStatus"></span>
        <span id="binanceSpotTotal"></span><span id="binanceEarnTotal"></span>
        <span id="binanceStakingTotal"></span><span id="binanceTotalValue"></span>
        <span id="binanceLastUpdate"></span><div id="binanceBalances"></div>
        <div id="binanceTokensList"></div>
    </div>

    <script>
        // ==================== CONFIG ====================
        let EUR_USD = 0.849;
        let allocationChart = null;
        let lastScanResults = [];
        let walletResults = {}; // { walletAddress: { name: 'Main', results: [...], scannedAt: timestamp } }
        
        const CHAINS = {
            eth: { id: 1, name: 'Ethereum', symbol: 'ETH', explorer: 'etherscan.io', color: '#627eea', dex: 'ethereum', api: 'etherscan' },
            bsc: { id: 56, name: 'BSC', symbol: 'BNB', explorer: 'bscscan.com', color: '#f3ba2f', dex: 'bsc', api: 'etherscan' },
            polygon: { id: 137, name: 'Polygon', symbol: 'MATIC', explorer: 'polygonscan.com', color: '#8247e5', dex: 'polygon', api: 'etherscan' },
            arbitrum: { id: 42161, name: 'Arbitrum', symbol: 'ETH', explorer: 'arbiscan.io', color: '#28a0f0', dex: 'arbitrum', api: 'etherscan' },
            optimism: { id: 10, name: 'Optimism', symbol: 'ETH', explorer: 'optimistic.etherscan.io', color: '#ff0420', dex: 'optimism', api: 'etherscan' },
            base: { id: 8453, name: 'Base', symbol: 'ETH', explorer: 'basescan.org', color: '#0052ff', dex: 'base', api: 'etherscan' },
            pulse: { id: 369, name: 'PulseChain', symbol: 'PLS', explorer: 'scan.pulsechain.com', color: '#00ff00', dex: 'pulsechain', api: 'pulsescan' },
            solana: { id: 0, name: 'Solana', symbol: 'SOL', explorer: 'solscan.io', color: '#9945ff', dex: 'solana', api: 'solana' },
        };
        
        const NATIVE_PRICES = { ETH: 0, BNB: 0, MATIC: 0, PLS: 0, SOL: 0 };
        
        const TOKEN_ICONS = {
            'ETH': 'https://assets.coingecko.com/coins/images/279/small/ethereum.png',
            'BNB': 'https://assets.coingecko.com/coins/images/825/small/bnb-icon2_2x.png',
            'MATIC': 'https://assets.coingecko.com/coins/images/4713/small/matic-token-icon.png',
            'SHIB': 'https://assets.coingecko.com/coins/images/11939/small/shiba.png',
            'BONE': 'https://assets.coingecko.com/coins/images/16916/small/bone_icon.png',
            'USDT': 'https://assets.coingecko.com/coins/images/325/small/tether.png',
            'USDC': 'https://assets.coingecko.com/coins/images/6319/small/usdc.png',
            'PLS': 'https://tokens.app.pulsex.com/images/tokens/0xA1077a294dDE1B09bB078844df40758a5D0f9a27.png',
            'SOL': 'https://assets.coingecko.com/coins/images/4128/small/solana.png',
            'HEX': 'https://tokens.app.pulsex.com/images/tokens/0x2b591e99afE9f32eAA6214f7B7629768c40Eeb39.png',
            'PLSX': 'https://tokens.app.pulsex.com/images/tokens/0x95B303987A60C71504D99Aa1b13B4DA07b0790ab.png',
            'INC': 'https://tokens.app.pulsex.com/images/tokens/0x2fa878Ab3F87CC1C9737Fc071108F904c0B0C95d.png',
            'DAI': 'https://assets.coingecko.com/coins/images/9956/small/dai-multi-collateral-mcd.png',
            'WETH': 'https://assets.coingecko.com/coins/images/2518/small/weth.png',
        };
        
        const HISTORICAL_PRICES = {
            'ethereum': { 2020: 737, 2021: 3769, 2022: 1196, 2023: 2282, 2024: 3337, 2025: 2950 },
            'shiba-inu': { 2020: 0, 2021: 0.0000338, 2022: 0.0000081, 2023: 0.0000091, 2024: 0.0000218, 2025: 0.000008 },
            'bone-shibaswap': { 2020: 0, 2021: 1.71, 2022: 0.93, 2023: 0.47, 2024: 0.42, 2025: 0.08 },
            'binancecoin': { 2020: 37, 2021: 526, 2022: 244, 2023: 311, 2024: 707, 2025: 680 },
            'matic-network': { 2020: 0.02, 2021: 2.47, 2022: 0.75, 2023: 0.99, 2024: 0.46, 2025: 0.35 },
            'pulsechain': { 2020: 0, 2021: 0, 2022: 0, 2023: 0.00005, 2024: 0.00003, 2025: 0.000014 },
            'hex': { 2020: 0.001, 2021: 0.15, 2022: 0.04, 2023: 0.006, 2024: 0.004, 2025: 0.003 },
            'pulsex': { 2020: 0, 2021: 0, 2022: 0, 2023: 0.0001, 2024: 0.00005, 2025: 0.00001 },
            'tether': { 2020: 1, 2021: 1, 2022: 1, 2023: 1, 2024: 1, 2025: 1 },
            'usd-coin': { 2020: 1, 2021: 1, 2022: 1, 2023: 1, 2024: 1, 2025: 1 },
            'solana': { 2020: 1.5, 2021: 170, 2022: 9.5, 2023: 100, 2024: 190, 2025: 150 },
            'bitcoin': { 2020: 29000, 2021: 47700, 2022: 16500, 2023: 42300, 2024: 93400, 2025: 100000 },
            'ripple': { 2020: 0.22, 2021: 0.83, 2022: 0.35, 2023: 0.62, 2024: 2.08, 2025: 2.30 },
            'cardano': { 2020: 0.18, 2021: 1.35, 2022: 0.25, 2023: 0.59, 2024: 0.88, 2025: 0.90 },
            'dogecoin': { 2020: 0.005, 2021: 0.17, 2022: 0.07, 2023: 0.09, 2024: 0.32, 2025: 0.35 },
            'polkadot': { 2020: 9.5, 2021: 27.8, 2022: 4.3, 2023: 7.9, 2024: 6.9, 2025: 7.0 },
            'chainlink': { 2020: 11.5, 2021: 19.3, 2022: 5.7, 2023: 15.1, 2024: 14.8, 2025: 15.0 },
            'avalanche-2': { 2020: 3.5, 2021: 109, 2022: 11.3, 2023: 40.5, 2024: 38.6, 2025: 40.0 },
            // Aggiunti per Crypto.com e Cosmos
            'cosmos': { 2020: 5.0, 2021: 44, 2022: 9.3, 2023: 10.5, 2024: 6.7, 2025: 7.0 },
            'crypto-com-chain': { 2020: 0.06, 2021: 0.60, 2022: 0.057, 2023: 0.073, 2024: 0.12, 2025: 0.10 },
            'terra-luna': { 2020: 0.64, 2021: 93, 2022: 0.00017, 2023: 0.00015, 2024: 0.00010, 2025: 0.00008 },
            'osmosis': { 2020: 0, 2021: 10.5, 2022: 0.8, 2023: 0.5, 2024: 0.4, 2025: 0.35 },
            'litecoin': { 2020: 125, 2021: 148, 2022: 70, 2023: 73, 2024: 103, 2025: 100 },
            'uniswap': { 2020: 3.5, 2021: 17.5, 2022: 5.2, 2023: 6.3, 2024: 13.5, 2025: 14.0 },
            'aave': { 2020: 89, 2021: 264, 2022: 51, 2023: 99, 2024: 330, 2025: 350 },
        };
        const YEAR_END_PRICES = HISTORICAL_PRICES; // Alias
        
        const SYMBOL_TO_CG = { 
            'ETH': 'ethereum', 'BNB': 'binancecoin', 'MATIC': 'matic-network', 
            'SHIB': 'shiba-inu', 'BONE': 'bone-shibaswap', 
            'USDT': 'tether', 'USDC': 'usd-coin',
            'PLS': 'pulsechain', 'HEX': 'hex', 'PLSX': 'pulsex',
            'SOL': 'solana', 'BTC': 'bitcoin', 'XRP': 'ripple',
            'ADA': 'cardano', 'DOGE': 'dogecoin', 'DOT': 'polkadot',
            'LINK': 'chainlink', 'AVAX': 'avalanche-2',
            'BUSD': 'tether', 'FDUSD': 'tether', 'DAI': 'tether',
            // Aggiunti
            'ATOM': 'cosmos', 'CRO': 'crypto-com-chain', 'LUNC': 'terra-luna', 'LUNA': 'terra-luna',
            'OSMO': 'osmosis', 'LTC': 'litecoin', 'UNI': 'uniswap', 'AAVE': 'aave',
            'EUR': 'eur', 'USD': 'usd',
        };
        
        let tokenBlacklist = JSON.parse(localStorage.getItem('cryptofolio_blacklist') || '[]');
        let blacklistNames = JSON.parse(localStorage.getItem('cryptofolio_blacklist_names') || '{}');
        let selectedChains = JSON.parse(localStorage.getItem('cryptofolio_chains') || '["eth","bsc"]');
        let savedWallets = JSON.parse(localStorage.getItem('cryptofolio_wallets') || '[]');
        let apiKeys = JSON.parse(localStorage.getItem('cryptofolio_apikeys') || '{}');
        let taxReportData = null; // Cached tax report results
        let saveTimeout = null;
        
        // Binance
        const BINANCE_SERVER_URL = 'http://localhost:3456';
        let binanceData = { balances: { spot: [], earn: [], staking: [] }, totals: { spot: 0, earn: 0, staking: 0 }, lastUpdate: null };
        
        // Exchange values per Tax Report (31/12 di ogni anno)
        let exchangeValues = { 2021: 0, 2022: 0, 2023: 0, 2024: 0, 2025: 0 };
        
        // Exchange data from CSV imports
        let exchangeData = {}; // { binance: { transactions: [], balances: {2021: {BTC: 0.5, ...}}, totals: {2021: 1234, ...} }, ... }
        
        // Lista exchange supportati
        const EXCHANGE_LIST = [
            { id: 'binance', name: 'Binance', color: '#f3ba2f', icon: 'B' },
            { id: 'bitget', name: 'Bitget', color: '#00f0ff', icon: 'Bg' },
            { id: 'bitpanda', name: 'Bitpanda', color: '#08b289', icon: 'Bp' },
            { id: 'bybit', name: 'Bybit', color: '#f7a600', icon: 'By' },
            { id: 'bybit_eu', name: 'Bybit EU', color: '#f7a600', icon: 'BE' },
            { id: 'cake', name: 'Cake DeFi', color: '#00d395', icon: 'üç∞' },
            { id: 'coinbase', name: 'Coinbase', color: '#0052ff', icon: 'Cb' },
            { id: 'cosmos', name: 'Cosmos', color: '#2e3148', icon: '‚öõÔ∏è' },
            { id: 'cryptocom_app', name: 'Crypto.com App', color: '#002d74', icon: 'Ca' },
            { id: 'cryptocom_exchange', name: 'Crypto.com Exchange', color: '#002d74', icon: 'Ce' },
            { id: 'gateio', name: 'Gate.io', color: '#17e6a1', icon: 'G' },
            { id: 'kraken', name: 'Kraken', color: '#5741d9', icon: 'Kr' },
            { id: 'kucoin', name: 'KuCoin', color: '#23af91', icon: 'Ku' },
            { id: 'manta', name: 'Manta Pacific', color: '#1fc7d4', icon: 'üêô' },
            { id: 'mexc', name: 'MEXC', color: '#00b897', icon: 'Mx' },
            { id: 'nexo', name: 'Nexo', color: '#1a4bff', icon: 'Nx' },
            { id: 'okx', name: 'OKX', color: '#000000', icon: 'OK' },
            { id: 'osmo', name: 'Osmosis', color: '#5e12a0', icon: 'üß™' },
            { id: 'pionex', name: 'Pionex', color: '#c8a02c', icon: 'Px' },
            { id: 'pulsechain', name: 'PulseChain', color: '#00ff00', icon: 'üíö' },
            { id: 'revolut', name: 'Revolut', color: '#0666eb', icon: 'Rv' },
            { id: 'terra', name: 'Terra-LUNC', color: '#5493f7', icon: 'üåô' },
            { id: 'whitebit', name: 'WhiteBit', color: '#02c3bd', icon: 'Wb' },
            { id: 'youholders', name: 'YouHodler', color: '#6c5ce7', icon: 'Yh' },
            { id: 'youngplatform', name: 'Young Platform', color: '#ff6b35', icon: 'Yp' },
        ];
        
        // Moralis chain mapping
        const MORALIS_CHAINS = {
            eth: '0x1',
            bsc: '0x38',
            polygon: '0x89',
            arbitrum: '0xa4b1',
            optimism: '0xa',
            base: '0x2105'
        };
        
        // ==================== FIREBASE ====================
        function updateSyncStatus(status, color) {
            document.getElementById('syncStatus').textContent = status;
            document.getElementById('syncDot').style.background = color || 'var(--green)';
        }
        
        function saveToFirebase() {
            if (saveTimeout) clearTimeout(saveTimeout);
            saveTimeout = setTimeout(async () => {
                try {
                    updateSyncStatus('Salvataggio...', 'var(--accent)');
                    await db.collection('cryptofolio').doc('settings').set({
                        wallets: savedWallets,
                        blacklist: tokenBlacklist,
                        blacklistNames: blacklistNames,
                        selectedChains: selectedChains,
                        apiKeys: apiKeys,
                        walletResults: walletResults,
                        taxReportData: taxReportData,
                        exchangeValues: exchangeValues,
                        lastUpdate: new Date().toISOString()
                    });
                    updateSyncStatus('Salvato ‚úì', 'var(--green)');
                    console.log('‚úÖ Firebase saved');
                } catch (e) {
                    updateSyncStatus('Errore sync', 'var(--red)');
                    console.error('Firebase save error:', e);
                }
            }, 1500);
        }
        
        async function loadFromFirebase() {
            try {
                updateSyncStatus('Caricamento...', 'var(--accent)');
                const doc = await db.collection('cryptofolio').doc('settings').get();
                
                if (doc.exists) {
                    const data = doc.data();
                    savedWallets = data.wallets || [];
                    tokenBlacklist = data.blacklist || [];
                    blacklistNames = data.blacklistNames || {};
                    selectedChains = data.selectedChains || ['eth', 'bsc'];
                    apiKeys = data.apiKeys || {};
                    walletResults = data.walletResults || {};
                    taxReportData = data.taxReportData || null;
                    exchangeValues = data.exchangeValues || { 2021: 0, 2022: 0, 2023: 0, 2024: 0, 2025: 0 };
                    
                    // Sync to localStorage
                    localStorage.setItem('cryptofolio_wallets', JSON.stringify(savedWallets));
                    localStorage.setItem('cryptofolio_blacklist', JSON.stringify(tokenBlacklist));
                    localStorage.setItem('cryptofolio_blacklist_names', JSON.stringify(blacklistNames));
                    localStorage.setItem('cryptofolio_chains', JSON.stringify(selectedChains));
                    localStorage.setItem('cryptofolio_apikeys', JSON.stringify(apiKeys));
                    
                    // Backward compatibility: load old apiKey into new structure
                    if (data.apiKey && !apiKeys.etherscan) {
                        apiKeys.etherscan = data.apiKey;
                        localStorage.setItem('cryptofolio_apikeys', JSON.stringify(apiKeys));
                    }
                    
                    // Update UI fields
                    if (apiKeys.etherscan) {
                        document.getElementById('apiKey').value = apiKeys.etherscan;
                    }
                    
                    console.log('‚úÖ Firebase loaded:', savedWallets.length, 'wallets,', Object.keys(walletResults).length, 'scan results', taxReportData ? ', tax report cached' : '');
                }
                
                updateSyncStatus('Connesso ‚úì', 'var(--green)');
            } catch (e) {
                updateSyncStatus('Offline', 'var(--red)');
                console.error('Firebase load error:', e);
            }
        }
        
        async function forceSyncFirebase() {
            if (saveTimeout) clearTimeout(saveTimeout);
            try {
                updateSyncStatus('Sync...', 'var(--accent)');
                await db.collection('cryptofolio').doc('settings').set({
                    wallets: savedWallets,
                    blacklist: tokenBlacklist,
                    blacklistNames: blacklistNames,
                    selectedChains: selectedChains,
                    apiKeys: apiKeys,
                    walletResults: walletResults,
                    taxReportData: taxReportData,
                    lastUpdate: new Date().toISOString()
                });
                updateSyncStatus('Salvato ‚úì', 'var(--green)');
                alert('‚úÖ Dati sincronizzati con Firebase!');
            } catch (e) {
                updateSyncStatus('Errore', 'var(--red)');
                alert('‚ùå Errore sync: ' + e.message);
            }
        }
        
        // ==================== UTILS ====================
        function log(msg, type = '') { 
            const el = document.getElementById('statusLog'); 
            el.innerHTML += `<div class="log-line ${type}">[${new Date().toLocaleTimeString('it-IT')}] ${msg}</div>`; 
            el.scrollTop = el.scrollHeight; 
        }
        function formatNum(n, d = 2) { 
            if (n >= 1e9) return (n/1e9).toFixed(2)+'B'; 
            if (n >= 1e6) return (n/1e6).toFixed(2)+'M'; 
            if (n < 0.0001 && n > 0) return n.toExponential(2); 
            return n.toLocaleString('en-US', {minimumFractionDigits: d, maximumFractionDigits: d}); 
        }
        function formatEUR(n) { return n.toLocaleString('it-IT', {minimumFractionDigits: 2, maximumFractionDigits: 2}); }
        function isSpam(name, sym) { 
            const n = (name||'').toLowerCase(), s = (sym||'').toLowerCase(); 
            const spam = ['visit', 'claim', 'reward', '.com', '.org', '.io', '.xyz', 'airdrop', 'bonus', 'free', 'gift', 'http', '$', '#']; 
            for (const p of spam) if (n.includes(p) || s.includes(p)) return true; 
            return (name||'').length > 40; 
        }
        function isBlacklisted(c) { return tokenBlacklist.includes(c.toLowerCase()); }
        function hideToken(c, s) { 
            const lc = c.toLowerCase(); 
            if (!tokenBlacklist.includes(lc)) { 
                tokenBlacklist.push(lc); 
                blacklistNames[lc] = s; 
                localStorage.setItem('cryptofolio_blacklist', JSON.stringify(tokenBlacklist)); 
                localStorage.setItem('cryptofolio_blacklist_names', JSON.stringify(blacklistNames)); 
            }
            updateBlacklist(); 
            displayResults(lastScanResults);
            saveToFirebase();
        }
        function restoreToken(c) { 
            tokenBlacklist = tokenBlacklist.filter(x => x !== c.toLowerCase()); 
            delete blacklistNames[c.toLowerCase()]; 
            localStorage.setItem('cryptofolio_blacklist', JSON.stringify(tokenBlacklist)); 
            localStorage.setItem('cryptofolio_blacklist_names', JSON.stringify(blacklistNames)); 
            updateBlacklist(); 
            displayResults(lastScanResults);
            saveToFirebase();
        }
        function clearBlacklist() { 
            tokenBlacklist = []; blacklistNames = {}; 
            localStorage.removeItem('cryptofolio_blacklist'); 
            localStorage.removeItem('cryptofolio_blacklist_names'); 
            updateBlacklist(); 
            displayResults(lastScanResults);
            saveToFirebase();
        }
        function toggleBlacklist() { 
            const p = document.getElementById('blacklistPanel'); 
            p.style.display = p.style.display === 'none' ? 'block' : 'none'; 
        }
        function updateBlacklist() { 
            document.getElementById('blacklistCount').textContent = tokenBlacklist.length; 
            const c = document.getElementById('blacklistContent'); 
            if (tokenBlacklist.length === 0) { c.innerHTML = '<p style="color:var(--text-secondary);">Nessun token nascosto</p>'; return; } 
            let h = ''; 
            for (const x of tokenBlacklist) { 
                h += `<div class="blacklist-item"><span>${blacklistNames[x]||x.slice(0,10)}</span><button class="btn-restore" onclick="restoreToken('${x}')">‚Ü©Ô∏è</button></div>`; 
            } 
            c.innerHTML = h; 
        }
        
        // ==================== UI ====================
        let currentDetailWallet = null;
        
        function showView(view) {
            document.getElementById('dashboardView').style.display = view === 'dashboard' ? 'block' : 'none';
            document.getElementById('walletsView').style.display = view === 'wallets' ? 'block' : 'none';
            document.getElementById('walletDetailView').style.display = view === 'walletDetail' ? 'block' : 'none';
            document.getElementById('exchangesView').style.display = view === 'exchanges' ? 'block' : 'none';
            document.getElementById('taxView').style.display = view === 'tax' ? 'block' : 'none';
            document.getElementById('apiView').style.display = view === 'api' ? 'block' : 'none';
            document.querySelectorAll('.nav-item').forEach((e, i) => {
                e.classList.toggle('active', 
                    (view === 'dashboard' && i === 0) || 
                    (view === 'wallets' && i === 1) || 
                    (view === 'walletDetail' && i === 1) || 
                    (view === 'exchanges' && i === 2) ||
                    (view === 'tax' && i === 3) ||
                    (view === 'api' && i === 4)
                );
            });
            
            // Aggiorna dropdown tax e mostra dati salvati
            if (view === 'tax') {
                updateTaxWalletsList();
                loadExchangeValuesUI();
                if (taxReportData) {
                    renderTaxReport(taxReportData);
                }
            }
            
            // Aggiorna status API quando si apre
            if (view === 'api') {
                updateApiStatus();
            }
            
            // Inizializza griglia exchange quando si apre
            if (view === 'exchanges') {
                initExchangeGrid();
                updateExchangeTotals();
            }
        }
        
        function renderTaxReport(data) {
            if (!data || !data.grandTotals || !data.walletDetails) {
                console.error('Invalid tax report data');
                return;
            }
            
            const container = document.getElementById('taxReportContent');
            const detailCard = document.getElementById('taxDetailCard');
            const detailContent = document.getElementById('taxDetailContent');
            const years = [2021, 2022, 2023, 2024, 2025];
            
            // Calcola totali includendo exchange
            const combinedTotals = {};
            let hasExchange = false;
            for (const y of years) {
                const walletEur = data.grandTotals[y]?.eur || 0;
                const walletUsd = data.grandTotals[y]?.usd || 0;
                const exchEur = exchangeValues[y] || 0;
                const exchUsd = exchEur / EUR_USD;
                if (exchEur > 0) hasExchange = true;
                combinedTotals[y] = {
                    eur: walletEur + exchEur,
                    usd: walletUsd + exchUsd,
                    walletEur: walletEur,
                    exchangeEur: exchEur
                };
            }
            
            // Render summary cards
            let html = '<div style="display:grid;gap:12px;">';
            
            for (const y of years) {
                const t = combinedTotals[y];
                const above = (t.eur || 0) >= 15000;
                const bgColor = above ? 'rgba(255,82,82,0.1)' : 'var(--bg-primary)';
                const borderColor = above ? 'var(--red)' : 'var(--border)';
                
                html += '<div style="background:' + bgColor + ';border:1px solid ' + borderColor + ';border-radius:12px;padding:16px;display:grid;grid-template-columns:80px 1fr 1fr 1fr 120px;align-items:center;gap:16px;">';
                html += '<div style="text-align:center;"><div style="font-size:28px;font-weight:700;color:var(--text-primary);">' + y + '</div></div>';
                html += '<div style="text-align:center;"><div style="font-size:11px;color:var(--text-secondary);margin-bottom:4px;">üëõ WALLET</div>';
                html += '<div style="font-size:16px;font-weight:600;color:var(--green);">‚Ç¨' + formatEUR(t.walletEur || 0) + '</div></div>';
                html += '<div style="text-align:center;"><div style="font-size:11px;color:var(--text-secondary);margin-bottom:4px;">üè¶ EXCHANGE</div>';
                html += '<div style="font-size:16px;font-weight:600;color:#f3ba2f;">‚Ç¨' + formatEUR(t.exchangeEur || 0) + '</div></div>';
                html += '<div style="text-align:center;"><div style="font-size:11px;color:var(--text-secondary);margin-bottom:4px;">üí∞ TOTALE</div>';
                html += '<div style="font-size:22px;font-weight:700;color:var(--green);">‚Ç¨' + formatEUR(t.eur || 0) + '</div></div>';
                html += '<div style="text-align:center;"><div style="font-size:11px;color:var(--text-secondary);margin-bottom:4px;">QUADRO RW</div>';
                if (above) {
                    html += '<div style="font-size:14px;font-weight:700;color:var(--red);background:rgba(255,82,82,0.2);padding:6px 12px;border-radius:8px;">‚ö†Ô∏è OBBLIGO</div>';
                } else {
                    html += '<div style="font-size:14px;font-weight:600;color:var(--green);background:rgba(0,230,118,0.1);padding:6px 12px;border-radius:8px;">‚úì NO</div>';
                }
                html += '</div></div>';
            }
            html += '</div>';
            
            // Footer info
            html += '<div style="margin-top:20px;padding:16px;background:var(--bg-primary);border-radius:12px;">';
            html += '<div style="display:flex;flex-wrap:wrap;gap:16px;justify-content:center;align-items:center;font-size:13px;">';
            html += '<span>üìä <strong>' + (data.walletCount || 0) + '</strong> wallet</span>';
            if (hasExchange) html += '<span style="color:var(--border);">|</span><span>üè¶ <strong>Exchange inclusi</strong></span>';
            html += '<span style="color:var(--border);">|</span>';
            html += '<span>‚õìÔ∏è ' + (data.chainNames || 'N/A') + '</span>';
            html += '<span style="color:var(--border);">|</span>';
            html += '<span>‚ö†Ô∏è Soglia RW: <strong>‚Ç¨15.000</strong></span>';
            html += '<span style="color:var(--border);">|</span>';
            html += '<span style="color:var(--text-secondary);">üìÖ ' + new Date(data.calculatedAt || Date.now()).toLocaleString('it-IT') + '</span>';
            html += '</div></div>';
            
            container.innerHTML = html;
            
            // Render detail per wallet
            let dh = '';
            for (const wd of (data.walletDetails || [])) {
                if (!wd) continue;
                dh += '<div style="margin-bottom:24px;padding:20px;background:var(--bg-primary);border-radius:12px;">';
                dh += '<h3 style="margin-bottom:16px;display:flex;align-items:center;gap:10px;font-size:16px;">üëõ ' + (wd.walletName || 'Wallet') + ' <span style="font-size:12px;color:var(--text-secondary);font-weight:normal;">' + (wd.walletAddress || '') + '</span></h3>';
                dh += '<table style="width:100%;border-collapse:collapse;font-size:13px;"><thead><tr style="border-bottom:2px solid var(--border);"><th style="text-align:left;padding:12px 8px;color:var(--text-secondary);font-weight:500;">TOKEN</th>';
                for (const y of years) dh += '<th style="text-align:center;padding:12px 8px;color:var(--text-secondary);font-weight:500;">' + y + '</th>';
                dh += '</tr></thead><tbody>';
                
                // Token rows
                for (const row of (wd.rows || [])) {
                    if (!row) continue;
                    dh += '<tr style="border-bottom:1px solid var(--border);"><td style="padding:12px 8px;"><strong>' + (row.tokenKey || '?') + '</strong></td>';
                    for (const y of years) {
                        const cell = row.cells ? row.cells[y] : null;
                        if (cell && cell.hasValue) {
                            dh += '<td style="text-align:center;padding:12px 8px;"><span style="color:var(--green);font-weight:600;">‚Ç¨' + formatEUR(cell.eur || 0) + '</span><br><span style="font-size:10px;color:var(--text-secondary);">' + formatNum(cell.balance || 0, 2) + '</span></td>';
                        } else if (cell && cell.balance > 0) {
                            dh += '<td style="text-align:center;padding:12px 8px;"><span style="color:var(--text-secondary);">' + formatNum(cell.balance || 0, 2) + '</span><br><span style="font-size:10px;color:var(--red);">no price</span></td>';
                        } else {
                            dh += '<td style="text-align:center;padding:12px 8px;color:var(--text-secondary);">-</td>';
                        }
                    }
                    dh += '</tr>';
                }
                
                // Wallet total row
                dh += '<tr style="background:var(--bg-secondary);border-radius:8px;"><td style="padding:14px 8px;font-weight:700;">TOTALE</td>';
                for (const y of years) {
                    const tot = wd.totals ? wd.totals[y] : null;
                    dh += '<td style="text-align:center;padding:14px 8px;font-weight:700;font-size:15px;color:var(--green);">‚Ç¨' + formatEUR(tot ? (tot.eur || 0) : 0) + '</td>';
                }
                dh += '</tr>';
                
                dh += '</tbody></table></div>';
            }
            
            detailContent.innerHTML = dh;
            detailCard.style.display = 'block';
        }
        
        function printTaxReport() {
            if (!taxReportData || !taxReportData.grandTotals || !taxReportData.walletDetails) {
                alert('Nessun report da stampare. Calcola prima il Tax Report.');
                return;
            }
            
            const years = [2021, 2022, 2023, 2024];
            const data = taxReportData;
            const dateStr = new Date().toLocaleString('it-IT');
            
            // Calcola totali combinati
            const combinedTotals = {};
            let hasExchange = false;
            for (const y of years) {
                const walletEur = data.grandTotals[y]?.eur || 0;
                const walletUsd = data.grandTotals[y]?.usd || 0;
                const exchEur = exchangeValues[y] || 0;
                const exchUsd = exchEur / EUR_USD;
                if (exchEur > 0) hasExchange = true;
                combinedTotals[y] = { eur: walletEur + exchEur, usd: walletUsd + exchUsd, walletEur, exchangeEur: exchEur };
            }
            
            // Build HTML string safely
            let html = '<!DOCTYPE html><html><head><meta charset="UTF-8"><title>Tax Report - Quadro RW</title>';
            html += '<style>';
            html += '* { margin: 0; padding: 0; box-sizing: border-box; }';
            html += 'body { font-family: Arial, sans-serif; padding: 40px; color: #1a1a2e; background: #fff; }';
            html += '.header { text-align: center; margin-bottom: 30px; border-bottom: 2px solid #1a1a2e; padding-bottom: 20px; }';
            html += '.header h1 { font-size: 24px; margin-bottom: 8px; }';
            html += '.header p { color: #666; font-size: 12px; }';
            html += '.summary h2 { font-size: 16px; margin-bottom: 15px; background: #f5f5f5; padding: 10px; }';
            html += 'table { width: 100%; border-collapse: collapse; margin-bottom: 20px; font-size: 12px; }';
            html += 'th { background: #1a1a2e; color: white; padding: 12px 8px; text-align: center; }';
            html += 'td { padding: 10px 8px; border-bottom: 1px solid #ddd; text-align: center; }';
            html += '.value-eur { font-weight: 700; color: #00c853; font-size: 14px; }';
            html += '.value-exchange { font-weight: 600; color: #f3ba2f; }';
            html += '.obbligo { background: #ffebee; }';
            html += '.obbligo-badge { background: #f44336; color: white; padding: 4px 8px; border-radius: 4px; font-size: 10px; }';
            html += '.no-badge { background: #e8f5e9; color: #2e7d32; padding: 4px 8px; border-radius: 4px; font-size: 10px; }';
            html += '.wallet-section { margin-bottom: 25px; page-break-inside: avoid; }';
            html += '.wallet-header { background: #f5f5f5; padding: 10px; margin-bottom: 10px; }';
            html += '.total-row { background: #e3f2fd; font-weight: 700; }';
            html += '.footer { margin-top: 30px; padding-top: 20px; border-top: 1px solid #ddd; font-size: 10px; color: #666; text-align: center; }';
            html += '.info-box { background: #fff3e0; border: 1px solid #ff9800; padding: 12px; margin-bottom: 20px; font-size: 11px; }';
            html += '</style></head><body>';
            
            // Header
            html += '<div class="header">';
            html += '<h1>TAX REPORT - QUADRO RW</h1>';
            html += '<p>Generato il ' + dateStr + ' | CryptoFolio</p>';
            html += '</div>';
            
            // Info box
            html += '<div class="info-box">';
            html += '<strong>NOTA:</strong> Valore criptovalute al 31/12. Soglia Quadro RW: 15.000 EUR. Consultare commercialista.';
            html += '</div>';
            
            // Summary table con colonne separate
            html += '<div class="summary"><h2>RIEPILOGO ANNUALE</h2>';
            html += '<table><thead><tr><th>ANNO</th><th>WALLET</th><th>EXCHANGE</th><th>TOTALE EUR</th><th>QUADRO RW</th></tr></thead><tbody>';
            
            for (const y of years) {
                const t = combinedTotals[y];
                const above = (t.eur || 0) >= 15000;
                html += '<tr class="' + (above ? 'obbligo' : '') + '">';
                html += '<td><strong>' + y + '</strong></td>';
                html += '<td class="value-eur">EUR ' + formatEUR(t.walletEur || 0) + '</td>';
                html += '<td class="value-exchange">EUR ' + formatEUR(t.exchangeEur || 0) + '</td>';
                html += '<td class="value-eur" style="font-size:16px;">EUR ' + formatEUR(t.eur || 0) + '</td>';
                html += '<td>' + (above ? '<span class="obbligo-badge">SI - OBBLIGO</span>' : '<span class="no-badge">NO</span>') + '</td>';
                html += '</tr>';
            }
            
            html += '</tbody></table>';
            html += '<p style="font-size:11px;color:#666;">Aggregato da ' + (data.walletCount || 0) + ' wallet' + (hasExchange ? ' + Exchange' : '') + ' | Chain: ' + (data.chainNames || 'N/A') + '</p>';
            html += '</div>';
            
            // Wallet details
            html += '<h2 style="font-size:16px;margin:20px 0 15px;background:#f5f5f5;padding:10px;">DETTAGLIO PER WALLET</h2>';
            
            for (const wd of (data.walletDetails || [])) {
                if (!wd) continue;
                html += '<div class="wallet-section">';
                html += '<div class="wallet-header"><strong>' + (wd.walletName || 'Wallet') + '</strong> - ' + (wd.walletAddress || '') + '</div>';
                html += '<table><thead><tr><th style="text-align:left;">TOKEN</th>';
                for (const y of years) {
                    html += '<th>' + y + '</th>';
                }
                html += '</tr></thead><tbody>';
                
                for (const row of (wd.rows || [])) {
                    if (!row) continue;
                    html += '<tr><td style="text-align:left;"><strong>' + (row.tokenKey || '?') + '</strong></td>';
                    for (const y of years) {
                        const cell = row.cells ? row.cells[y] : null;
                        if (cell && cell.hasValue) {
                            html += '<td class="value-eur">EUR ' + formatEUR(cell.eur || 0) + '<br><small style="color:#666;">' + formatNum(cell.balance || 0, 2) + '</small></td>';
                        } else if (cell && cell.balance > 0) {
                            html += '<td><small>' + formatNum(cell.balance || 0, 2) + '</small></td>';
                        } else {
                            html += '<td>-</td>';
                        }
                    }
                    html += '</tr>';
                }
                
                html += '<tr class="total-row"><td style="text-align:left;"><strong>TOTALE</strong></td>';
                for (const y of years) {
                    const tot = wd.totals ? wd.totals[y] : null;
                    html += '<td class="value-eur">EUR ' + formatEUR(tot ? (tot.eur || 0) : 0) + '</td>';
                }
                html += '</tr></tbody></table></div>';
            }
            
            // Footer
            html += '<div class="footer">';
            html += '<p>Documento generato da CryptoFolio | Solo uso informativo</p>';
            html += '</div>';
            
            html += '</body></html>';
            
            // Open print window
            const printWindow = window.open('', '_blank');
            if (printWindow) {
                printWindow.document.write(html);
                printWindow.document.close();
                printWindow.onload = function() { printWindow.print(); };
            } else {
                alert('Popup bloccato! Abilita i popup per stampare.');
            }
        }
        
        function clearTaxReport() {
            if (!confirm('Vuoi cancellare il Tax Report salvato?')) return;
            taxReportData = null;
            document.getElementById('taxReportContent').innerHTML = '<div class="empty-state"><div class="icon">üëÜ</div><h3>Clicca "Calcola Tutti" per iniziare</h3></div>';
            document.getElementById('taxDetailCard').style.display = 'none';
            saveToFirebase();
            alert('Tax Report resettato!');
        }
        
        function saveExchangeValues() {
            const years = [2021, 2022, 2023, 2024, 2025];
            for (const y of years) {
                const val = parseFloat(document.getElementById('exchange' + y).value) || 0;
                exchangeValues[y] = val;
            }
            saveToFirebase();
            alert('‚úÖ Valori Exchange salvati!');
            
            // Ricalcola se c'√® gi√† un report
            if (taxReportData) {
                renderTaxReport(taxReportData);
            }
        }
        
        function loadExchangeValuesUI() {
            const years = [2021, 2022, 2023, 2024, 2025];
            for (const y of years) {
                const input = document.getElementById('exchange' + y);
                if (input && exchangeValues[y]) {
                    // Formatta con max 2 decimali
                    input.value = parseFloat(exchangeValues[y]).toFixed(2);
                }
            }
        }
        
        function updateTaxWalletsList() {
            const container = document.getElementById('taxWalletsList');
            if (!container) return;
            
            if (savedWallets.length === 0) {
                container.innerHTML = '<p style="color:var(--red);">‚ö†Ô∏è Nessun wallet salvato. Vai su <strong>Wallets</strong> per aggiungerne.</p>';
                document.getElementById('taxReportContent').innerHTML = '<div class="empty-state"><div class="icon">üëõ</div><h3>Aggiungi wallet prima</h3></div>';
                return;
            }
            
            let html = '<div style="display:flex;flex-wrap:wrap;gap:8px;">';
            savedWallets.forEach(w => {
                const shortAddr = w.address.slice(0, 6) + '...' + w.address.slice(-4);
                html += `<span style="background:var(--bg-primary);padding:6px 12px;border-radius:8px;font-size:13px;">üëõ ${w.name} <span style="color:var(--text-secondary);">(${shortAddr})</span></span>`;
            });
            html += '</div>';
            container.innerHTML = html;
        }
        
        // ==================== API MANAGEMENT ====================
        function saveMoralisKey() {
            const key = document.getElementById('moralisKey').value.trim();
            if (!key) {
                alert('Inserisci una API key valida');
                return;
            }
            apiKeys.moralis = key;
            localStorage.setItem('cryptofolio_apikeys', JSON.stringify(apiKeys));
            saveToFirebase();
            updateApiStatus();
            alert('‚úÖ Moralis API key salvata!');
        }
        
        function saveEtherscanKey() {
            const key = document.getElementById('etherscanKey').value.trim();
            if (!key) {
                alert('Inserisci una API key valida');
                return;
            }
            apiKeys.etherscan = key;
            // Also update the old apiKey field for backward compatibility
            document.getElementById('apiKey').value = key;
            localStorage.setItem('cryptofolio_apikeys', JSON.stringify(apiKeys));
            saveToFirebase();
            updateApiStatus();
            alert('‚úÖ Etherscan API key salvata!');
        }
        
        function saveHeliusKey() {
            const key = document.getElementById('heliusKey').value.trim();
            if (!key) {
                alert('Inserisci una API key valida');
                return;
            }
            apiKeys.helius = key;
            localStorage.setItem('cryptofolio_apikeys', JSON.stringify(apiKeys));
            saveToFirebase();
            updateApiStatus();
            alert('‚úÖ Helius API key salvata! Solana scan migliorato.');
        }
        
        function updateApiStatus() {
            // Update status badges
            const moralisStatus = document.getElementById('moralisStatus');
            const etherscanStatus = document.getElementById('etherscanStatus');
            
            if (moralisStatus) {
                if (apiKeys.moralis) {
                    moralisStatus.textContent = 'ON';
                    moralisStatus.classList.add('api-on');
                } else {
                    moralisStatus.textContent = 'OFF';
                    moralisStatus.classList.remove('api-on');
                }
            }
            
            if (etherscanStatus) {
                if (apiKeys.etherscan) {
                    etherscanStatus.textContent = 'ON';
                    etherscanStatus.classList.add('api-on');
                } else {
                    etherscanStatus.textContent = 'OFF';
                    etherscanStatus.classList.remove('api-on');
                }
            }
            
            const heliusStatus = document.getElementById('heliusStatus');
            if (heliusStatus) {
                if (apiKeys.helius) {
                    heliusStatus.textContent = 'ON';
                    heliusStatus.classList.add('api-on');
                } else {
                    heliusStatus.textContent = 'OFF';
                    heliusStatus.classList.remove('api-on');
                }
            }
            
            // Fill input fields
            if (document.getElementById('moralisKey') && apiKeys.moralis) {
                document.getElementById('moralisKey').value = apiKeys.moralis;
            }
            if (document.getElementById('etherscanKey') && apiKeys.etherscan) {
                document.getElementById('etherscanKey').value = apiKeys.etherscan;
            }
            if (document.getElementById('heliusKey') && apiKeys.helius) {
                document.getElementById('heliusKey').value = apiKeys.helius;
            }
            
            // Update API count badge
            updateApiCount();
            
            // Update summary
            const summary = document.getElementById('apiSummary');
            if (summary) {
                let html = '';
                
                // Moralis
                html += `<div style="padding:16px;background:var(--bg-primary);border-radius:10px;text-align:center;">
                    <div style="font-size:24px;margin-bottom:8px;">üü¢</div>
                    <div style="font-weight:600;">Moralis</div>
                    <div style="font-size:12px;color:${apiKeys.moralis ? 'var(--green)' : 'var(--red)'};">${apiKeys.moralis ? '‚úì Configurato' : '‚úó Non configurato'}</div>
                </div>`;
                
                // Etherscan
                html += `<div style="padding:16px;background:var(--bg-primary);border-radius:10px;text-align:center;">
                    <div style="font-size:24px;margin-bottom:8px;">üîµ</div>
                    <div style="font-weight:600;">Etherscan</div>
                    <div style="font-size:12px;color:${apiKeys.etherscan ? 'var(--green)' : 'var(--red)'};">${apiKeys.etherscan ? '‚úì Configurato' : '‚úó Non configurato'}</div>
                </div>`;
                
                // PulseChain
                html += `<div style="padding:16px;background:var(--bg-primary);border-radius:10px;text-align:center;">
                    <div style="font-size:24px;margin-bottom:8px;">üíö</div>
                    <div style="font-weight:600;">PulseChain</div>
                    <div style="font-size:12px;color:var(--green);">‚úì Auto</div>
                </div>`;
                
                // Solana / Helius
                html += `<div style="padding:16px;background:var(--bg-primary);border-radius:10px;text-align:center;">
                    <div style="font-size:24px;margin-bottom:8px;">üü£</div>
                    <div style="font-weight:600;">Solana</div>
                    <div style="font-size:12px;color:${apiKeys.helius ? 'var(--green)' : 'var(--red)'};">${apiKeys.helius ? '‚úì Helius' : '‚úó Configura Helius'}</div>
                </div>`;
                
                summary.innerHTML = html;
            }
        }
        
        function updateApiCount() {
            let count = 1; // PulseChain sempre attiva
            if (apiKeys.moralis) count++;
            if (apiKeys.etherscan) count++;
            if (apiKeys.helius) count++;
            document.getElementById('apiCount').textContent = count;
        }
        
        // ==================== HELIUS API (SOLANA) ====================
        async function fetchWithHelius(addr) {
            if (!apiKeys.helius) return null;
            
            try {
                console.log('Fetching Solana data with Helius for', addr);
                
                // Helius balances endpoint - restituisce SOL + tutti i token SPL
                const url = `https://api.helius.xyz/v0/addresses/${addr}/balances?api-key=${apiKeys.helius}`;
                const response = await fetch(url);
                
                if (!response.ok) {
                    console.error('Helius API error:', response.status);
                    return null;
                }
                
                const data = await response.json();
                console.log('Helius response:', data);
                
                const results = [];
                
                // Native SOL balance
                if (data.nativeBalance) {
                    const solBalance = data.nativeBalance / 1e9; // lamports to SOL
                    const solPrice = NATIVE_PRICES.SOL || 150;
                    
                    if (solBalance > 0.0001) {
                        results.push({
                            symbol: 'SOL',
                            name: 'Solana',
                            balance: solBalance,
                            price: solPrice,
                            valueUSD: solBalance * solPrice,
                            contract: 'native-solana',
                            logo: TOKEN_ICONS['SOL'],
                            chain: 'solana'
                        });
                        console.log('SOL balance:', solBalance, 'USD:', solBalance * solPrice);
                    }
                }
                
                // Token balances
                if (data.tokens && data.tokens.length > 0) {
                    for (const token of data.tokens) {
                        if (!token.amount || token.amount <= 0) continue;
                        
                        const decimals = token.decimals || 0;
                        const balance = token.amount / Math.pow(10, decimals);
                        
                        if (balance <= 0) continue;
                        
                        // Try to get price from DexScreener
                        let price = 0;
                        let logo = null;
                        let symbol = token.symbol || 'SPL';
                        let name = token.name || 'Solana Token';
                        
                        const pd = await fetchTokenPrice(token.mint, 'solana');
                        if (pd) {
                            price = pd.price;
                            if (pd.logo) logo = pd.logo;
                            if (pd.symbol) symbol = pd.symbol;
                            if (pd.name) name = pd.name;
                        }
                        
                        // Skip dust (< $0.01)
                        const valueUSD = balance * price;
                        if (valueUSD < 0.01 && price > 0) continue;
                        
                        results.push({
                            symbol: symbol,
                            name: name,
                            balance: balance,
                            price: price,
                            valueUSD: valueUSD,
                            contract: token.mint,
                            logo: logo,
                            chain: 'solana'
                        });
                    }
                }
                
                console.log('Helius found', results.length, 'assets');
                return results;
                
            } catch (e) {
                console.error('Helius fetch error:', e);
                return null;
            }
        }
        
        // ==================== MORALIS API ====================
        async function fetchWithMoralis(addr, chainKey) {
            if (!apiKeys.moralis || !MORALIS_CHAINS[chainKey]) return null;
            
            try {
                const chain = MORALIS_CHAINS[chainKey];
                
                // Get native balance
                const nativeRes = await fetch(`https://deep-index.moralis.io/api/v2.2/${addr}/balance?chain=${chain}`, {
                    headers: { 'X-API-Key': apiKeys.moralis }
                });
                const nativeData = await nativeRes.json();
                
                // Get token balances
                const tokenRes = await fetch(`https://deep-index.moralis.io/api/v2.2/${addr}/erc20?chain=${chain}`, {
                    headers: { 'X-API-Key': apiKeys.moralis }
                });
                const tokenData = await tokenRes.json();
                
                return {
                    nativeBalance: nativeData.balance || '0',
                    tokens: tokenData || []
                };
            } catch (e) {
                console.error('Moralis error:', e);
                return null;
            }
        }
        
        async function scanWithMoralis(addr, chainKey) {
            const chainInfo = CHAINS[chainKey];
            const moralisData = await fetchWithMoralis(addr, chainKey);
            
            if (!moralisData) return [];
            
            const results = [];
            
            // Native balance
            const nativeBal = moralisData.nativeBalance ? Number(BigInt(moralisData.nativeBalance)) / 1e18 : 0;
            const nativePrice = NATIVE_PRICES[chainInfo.symbol] || NATIVE_PRICES.ETH;
            
            if (nativeBal > 0.0001) {
                results.push({
                    symbol: chainInfo.symbol,
                    name: `${chainInfo.symbol} (${chainInfo.name})`,
                    balance: nativeBal,
                    price: nativePrice,
                    valueUSD: nativeBal * nativePrice,
                    contract: `native-${chainKey}`,
                    logo: TOKEN_ICONS[chainInfo.symbol],
                    chain: chainKey
                });
            }
            
            // Token balances - check if tokens exists and is array
            if (moralisData.tokens && Array.isArray(moralisData.tokens)) {
                for (const token of moralisData.tokens) {
                    if (isBlacklisted(token.token_address) || isSpam(token.name, token.symbol)) continue;
                    
                    const bal = Number(BigInt(token.balance)) / Math.pow(10, token.decimals || 18);
                    if (bal <= 0) continue;
                    
                    let price = 0, logo = TOKEN_ICONS[token.symbol?.toUpperCase()] || token.logo || null;
                    
                    // Get price from DexScreener
                    const pd = await fetchTokenPrice(token.token_address, chainInfo.dex);
                    if (pd) { price = pd.price; if (pd.logo) logo = pd.logo; }
                    
                    results.push({
                        symbol: token.symbol,
                        name: token.name,
                        balance: bal,
                        price,
                        valueUSD: bal * price,
                        contract: token.token_address.toLowerCase(),
                        logo,
                        chain: chainKey
                    });
                }
            }
            
            return results;
        }
        
        // ==================== WALLET MANAGEMENT ====================
        function addWallet() {
            const name = document.getElementById('newWalletName').value.trim();
            const address = document.getElementById('newWalletAddress').value.trim();
            
            if (!name) { alert('Inserisci un nome per il wallet'); return; }
            
            // Validazione: EVM (0x + 40 hex) o Solana (32-44 chars base58)
            const isEVM = address.startsWith('0x') && address.length === 42 && /^0x[a-fA-F0-9]{40}$/.test(address);
            const isSolana = /^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(address);
            
            if (!isEVM && !isSolana) { 
                alert('Indirizzo wallet non valido.\n\nFormati supportati:\n‚Ä¢ EVM: 0x... (42 caratteri)\n‚Ä¢ Solana: base58 (32-44 caratteri)'); 
                return; 
            }
            
            // Check duplicate
            if (savedWallets.some(w => w.address.toLowerCase() === address.toLowerCase())) {
                alert('Questo wallet √® gi√† salvato');
                return;
            }
            
            // Detect wallet type
            const walletType = isSolana ? 'solana' : 'evm';
            
            savedWallets.push({ name, address, type: walletType, addedAt: Date.now() });
            localStorage.setItem('cryptofolio_wallets', JSON.stringify(savedWallets));
            
            document.getElementById('newWalletName').value = '';
            document.getElementById('newWalletAddress').value = '';
            
            updateWalletsList();
            updateWalletSelect();
            saveToFirebase();
            log(`‚úÖ Wallet "${name}" (${walletType.toUpperCase()}) aggiunto`, 'success');
        }
        
        function removeWallet(index) {
            if (confirm(`Rimuovere wallet "${savedWallets[index].name}"?`)) {
                savedWallets.splice(index, 1);
                localStorage.setItem('cryptofolio_wallets', JSON.stringify(savedWallets));
                updateWalletsList();
                updateWalletSelect();
                saveToFirebase();
            }
        }
        
        function selectWallet(index) {
            const wallet = savedWallets[index];
            document.getElementById('walletAddress').value = wallet.address;
            document.getElementById('walletSelect').value = index;
            showView('dashboard');
            log(`üëõ Wallet "${wallet.name}" selezionato`, 'info');
        }
        
        function onWalletSelect() {
            const select = document.getElementById('walletSelect');
            const idx = select.value;
            if (idx !== '' && savedWallets[idx]) {
                document.getElementById('walletAddress').value = savedWallets[idx].address;
            }
        }
        
        function updateWalletsList() {
            const container = document.getElementById('walletsList');
            document.getElementById('walletCount').textContent = savedWallets.length;
            
            if (savedWallets.length === 0) {
                container.innerHTML = '<p style="color:var(--text-secondary);padding:20px;text-align:center;">Nessun wallet salvato.<br>Aggiungi il tuo primo wallet sopra!</p>';
                return;
            }
            
            let html = '';
            savedWallets.forEach((w, i) => {
                const shortAddr = w.address.slice(0, 8) + '...' + w.address.slice(-6);
                // Calcola totale se scannerizzato
                const walletData = walletResults[w.address.toLowerCase()];
                const total = walletData ? walletData.results.reduce((s, t) => s + t.valueUSD, 0) * EUR_USD : 0;
                const totalStr = walletData ? `‚Ç¨${formatEUR(total)}` : '<span style="color:var(--text-secondary);">Non scansionato</span>';
                
                // Detect wallet type
                const isSolana = w.type === 'solana' || (!w.address.startsWith('0x') && /^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(w.address));
                const typeBadge = isSolana 
                    ? '<span style="background:#9945ff;color:#fff;padding:2px 6px;border-radius:4px;font-size:10px;margin-left:8px;">SOL</span>'
                    : '<span style="background:#627eea;color:#fff;padding:2px 6px;border-radius:4px;font-size:10px;margin-left:8px;">EVM</span>';
                
                html += `
                    <div style="display:flex;align-items:center;justify-content:space-between;padding:16px;background:var(--bg-primary);border-radius:12px;margin-bottom:12px;">
                        <div style="display:flex;align-items:center;gap:16px;cursor:pointer;flex:1;" onclick="openWalletDetail(${i})">
                            <div style="width:48px;height:48px;border-radius:12px;background:linear-gradient(135deg,${isSolana ? '#9945ff,#14f195' : 'var(--accent),var(--accent-light)'});display:flex;align-items:center;justify-content:center;font-size:20px;">üëõ</div>
                            <div>
                                <div style="font-weight:600;font-size:16px;">${w.name}${typeBadge}</div>
                                <div style="font-size:13px;color:var(--text-secondary);font-family:monospace;">${shortAddr}</div>
                            </div>
                            <div style="margin-left:auto;text-align:right;">
                                <div style="font-weight:600;color:var(--green);">${totalStr}</div>
                            </div>
                        </div>
                        <div style="display:flex;gap:8px;margin-left:16px;">
                            <button class="btn btn-primary" onclick="selectWallet(${i})" style="padding:8px 16px;">üìä Scan</button>
                            <button class="btn btn-secondary" onclick="navigator.clipboard.writeText('${w.address}')" style="padding:8px 12px;">üìã</button>
                            <button class="btn btn-secondary" onclick="removeWallet(${i})" style="padding:8px 12px;color:var(--red);">üóëÔ∏è</button>
                        </div>
                    </div>
                `;
            });
            container.innerHTML = html;
        }
        
        function updateWalletSelect() {
            const select = document.getElementById('walletSelect');
            let html = '<option value="">-- Seleziona wallet salvato --</option>';
            savedWallets.forEach((w, i) => {
                const shortAddr = w.address.slice(0, 6) + '...' + w.address.slice(-4);
                html += `<option value="${i}">${w.name} (${shortAddr})</option>`;
            });
            select.innerHTML = html;
        }
        
        // ==================== WALLET DETAIL ====================
        function openWalletDetail(index) {
            const wallet = savedWallets[index];
            if (!wallet) return;
            
            currentDetailWallet = wallet;
            document.getElementById('detailWalletName').textContent = wallet.name;
            document.getElementById('detailWalletAddress').textContent = wallet.address;
            
            displayWalletDetail();
            showView('walletDetail');
        }
        
        function copyDetailAddress() {
            if (currentDetailWallet) {
                navigator.clipboard.writeText(currentDetailWallet.address);
                alert('Indirizzo copiato!');
            }
        }
        
        function displayWalletDetail() {
            if (!currentDetailWallet) return;
            
            const walletData = walletResults[currentDetailWallet.address.toLowerCase()];
            const container = document.getElementById('detailChainsContent');
            
            if (!walletData || walletData.results.length === 0) {
                document.getElementById('detailTotal').textContent = '‚Ç¨0,00';
                document.getElementById('detailChainCount').textContent = '0';
                document.getElementById('detailTokenCount').textContent = '0';
                container.innerHTML = '<div class="card"><div class="empty-state"><div class="icon">üì≠</div><h3>Nessun dato</h3><p style="color:var(--text-secondary);">Clicca "Scan" per scansionare questo wallet</p></div></div>';
                return;
            }
            
            // Raggruppa token per chain
            const byChain = {};
            for (const token of walletData.results) {
                if (!byChain[token.chain]) byChain[token.chain] = [];
                byChain[token.chain].push(token);
            }
            
            // Calcola totali
            const totalUSD = walletData.results.reduce((s, t) => s + t.valueUSD, 0);
            const totalEUR = totalUSD * EUR_USD;
            const chainCount = Object.keys(byChain).length;
            const tokenCount = walletData.results.length;
            
            document.getElementById('detailTotal').textContent = '‚Ç¨' + formatEUR(totalEUR);
            document.getElementById('detailChainCount').textContent = chainCount;
            document.getElementById('detailTokenCount').textContent = tokenCount;
            
            // Genera HTML per ogni chain
            let html = '';
            for (const [chainKey, tokens] of Object.entries(byChain)) {
                const chain = CHAINS[chainKey];
                const chainTotal = tokens.reduce((s, t) => s + t.valueUSD, 0) * EUR_USD;
                
                html += `
                    <div class="card" style="margin-bottom:16px;">
                        <div class="card-header">
                            <div class="card-title" style="display:flex;align-items:center;gap:10px;">
                                <span style="width:12px;height:12px;border-radius:50%;background:${chain?.color || '#666'};"></span>
                                ${chain?.name || chainKey}
                            </div>
                            <div style="font-weight:600;color:var(--green);">‚Ç¨${formatEUR(chainTotal)}</div>
                        </div>
                        <table class="holdings-table">
                            <thead><tr><th>Token</th><th class="text-right">Balance</th><th class="text-right">Prezzo</th><th class="text-right">Valore</th></tr></thead>
                            <tbody>
                `;
                
                // Ordina token per valore
                tokens.sort((a, b) => b.valueUSD - a.valueUSD);
                
                for (const t of tokens) {
                    if (t.valueUSD < 0.01) continue;
                    const vEUR = t.valueUSD * EUR_USD;
                    html += `
                        <tr>
                            <td><div class="token-cell">
                                <div class="token-icon">${t.logo ? `<img src="${t.logo}" onerror="this.parentElement.textContent='${t.symbol?.slice(0,2) || '??'}'">` : (t.symbol?.slice(0,2) || '??')}</div>
                                <div class="token-info">
                                    <div class="symbol">${t.symbol || '???'}</div>
                                    <div class="name">${t.name || ''}</div>
                                </div>
                            </div></td>
                            <td class="text-right text-mono">${formatNum(t.balance, 4)}</td>
                            <td class="text-right text-mono text-secondary">$${t.price > 0 ? formatNum(t.price, 6) : '-'}</td>
                            <td class="text-right text-mono" style="color:var(--green);">‚Ç¨${formatEUR(vEUR)}</td>
                        </tr>
                    `;
                }
                
                html += '</tbody></table></div>';
            }
            
            container.innerHTML = html;
        }
        
        async function scanDetailWallet() {
            if (!currentDetailWallet) return;
            
            const etherscanKey = apiKeys.etherscan;
            if (!etherscanKey && !apiKeys.moralis) { 
                alert('Configura almeno una API in API Connect'); 
                return; 
            }
            if (selectedChains.length === 0) { alert('Seleziona almeno una chain nella Dashboard'); return; }
            
            // Scan del wallet
            const addr = currentDetailWallet.address;
            const results = [];
            
            await fetchEurUsd();
            await fetchNativePrices();
            
            for (const chainKey of selectedChains) {
                const chain = CHAINS[chainKey];
                
                // Try Moralis first for supported chains
                if (apiKeys.moralis && MORALIS_CHAINS[chainKey]) {
                    const moralisResults = await scanWithMoralis(addr, chainKey);
                    if (moralisResults && moralisResults.length > 0) {
                        results.push(...moralisResults);
                        await new Promise(r => setTimeout(r, 100));
                        continue;
                    }
                }
                
                // Fallback to Etherscan/PulseScan/Solana RPC
                if (!etherscanKey && chainKey !== 'pulse' && chainKey !== 'solana') {
                    continue;
                }
                
                // Native balance
                const nativeWei = await fetchNativeBalance(addr, etherscanKey, chain.id, chainKey);
                const nativeDecimals = chainKey === 'solana' ? 9 : 18;
                const nativeBal = Number(nativeWei) / Math.pow(10, nativeDecimals);
                const nativePrice = NATIVE_PRICES[chain.symbol] || NATIVE_PRICES.ETH;
                
                if (nativeBal > 0.0001) {
                    results.push({
                        symbol: chain.symbol,
                        name: `${chain.symbol} (${chain.name})`,
                        balance: nativeBal,
                        price: nativePrice,
                        valueUSD: nativeBal * nativePrice,
                        contract: `native-${chainKey}`,
                        logo: TOKEN_ICONS[chain.symbol],
                        chain: chainKey
                    });
                }
                
                // Token balances
                const tokens = await fetchTokenTransfers(addr, etherscanKey, chain.id, chainKey);
                
                for (const [c, t] of Object.entries(tokens)) {
                    if (isBlacklisted(c) || isSpam(t.name, t.symbol) || t.balance <= 0n) continue;
                    
                    const bal = Number(t.balance) / Math.pow(10, t.decimals);
                    let price = 0, logo = TOKEN_ICONS[t.symbol?.toUpperCase()] || null;
                    
                    const pd = await fetchTokenPrice(c, chain.dex);
                    if (pd) { price = pd.price; if (pd.logo) logo = pd.logo; }
                    
                    results.push({
                        symbol: t.symbol,
                        name: t.name,
                        balance: bal,
                        price,
                        valueUSD: bal * price,
                        contract: c,
                        logo,
                        chain: chainKey
                    });
                    
                    await new Promise(r => setTimeout(r, 150));
                }
                
                await new Promise(r => setTimeout(r, 200));
            }
            
            // Salva risultati
            walletResults[addr.toLowerCase()] = {
                name: currentDetailWallet.name,
                results: results,
                scannedAt: Date.now()
            };
            
            // Aggiorna display
            displayWalletDetail();
            updateWalletsList();
            aggregateAndDisplay();
            saveToFirebase();
        }
        
        function initChainSelector() {
            const container = document.getElementById('chainSelector');
            let html = '';
            for (const [key, chain] of Object.entries(CHAINS)) {
                const active = selectedChains.includes(key) ? 'active' : '';
                html += `<button class="chain-btn ${active}" data-chain="${key}" onclick="toggleChain('${key}')">
                    <span class="chain-dot" style="background:${chain.color}"></span>${chain.name}
                </button>`;
            }
            container.innerHTML = html;
        }
        
        function toggleChain(key) {
            const idx = selectedChains.indexOf(key);
            if (idx >= 0) selectedChains.splice(idx, 1);
            else selectedChains.push(key);
            localStorage.setItem('cryptofolio_chains', JSON.stringify(selectedChains));
            initChainSelector();
            saveToFirebase();
        }
        
        function loadSettings() {
            const w = localStorage.getItem('cryptofolio_wallet');
            const oldKey = localStorage.getItem('etherscan_api_key');
            
            if (w) document.getElementById('walletAddress').value = w;
            
            // Backward compatibility: migra vecchia API key a nuovo sistema
            if (oldKey && !apiKeys.etherscan) {
                apiKeys.etherscan = oldKey;
                localStorage.setItem('cryptofolio_apikeys', JSON.stringify(apiKeys));
                localStorage.removeItem('etherscan_api_key'); // Rimuovi vecchia chiave
            }
        }
        
        function saveSettings() {
            const w = document.getElementById('walletAddress').value.trim();
            if (w) localStorage.setItem('cryptofolio_wallet', w);
            saveToFirebase();
        }
        
        // ==================== API ====================
        async function fetchEurUsd() { 
            try { 
                const r = await fetch('https://api.exchangerate-api.com/v4/latest/USD'); 
                const d = await r.json(); 
                EUR_USD = d.rates.EUR; 
                document.getElementById('eurUsdRate').textContent = EUR_USD.toFixed(4); 
            } catch(e) { EUR_USD = 0.849; } 
        }
        
        async function fetchNativePrices() {
            try {
                const r = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=ethereum,binancecoin,matic-network,pulsechain,solana&vs_currencies=usd');
                const d = await r.json();
                NATIVE_PRICES.ETH = d.ethereum?.usd || 3000;
                NATIVE_PRICES.BNB = d.binancecoin?.usd || 600;
                NATIVE_PRICES.MATIC = d['matic-network']?.usd || 0.4;
                NATIVE_PRICES.PLS = d.pulsechain?.usd || 0.00003;
                NATIVE_PRICES.SOL = d.solana?.usd || 150;
            } catch(e) {
                NATIVE_PRICES.ETH = 3000; NATIVE_PRICES.BNB = 600; NATIVE_PRICES.MATIC = 0.4;
                NATIVE_PRICES.PLS = 0.00003; NATIVE_PRICES.SOL = 150;
            }
        }
        
        async function fetchNativeBalance(addr, apiKey, chainId, chainKey) {
            try {
                // Solana - usa RPC
                if (chainKey === 'solana') {
                    const r = await fetch('https://api.mainnet-beta.solana.com', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            jsonrpc: '2.0', id: 1, method: 'getBalance', params: [addr]
                        })
                    });
                    const d = await r.json();
                    if (d.result?.value) return BigInt(d.result.value);
                    return 0n;
                }
                
                // PulseChain - usa PulseScan API
                if (chainKey === 'pulse') {
                    const r = await fetch(`https://api.scan.pulsechain.com/api?module=account&action=balance&address=${addr}`);
                    const d = await r.json();
                    if (d.status === '1') return BigInt(d.result);
                    return 0n;
                }
                
                // EVM chains - usa Etherscan V2
                const r = await fetch(`https://api.etherscan.io/v2/api?chainid=${chainId}&module=account&action=balance&address=${addr}&tag=latest&apikey=${apiKey}`);
                const d = await r.json();
                if (d.status === '1') return BigInt(d.result);
            } catch(e) { console.error(`Balance error ${chainKey}:`, e); }
            return 0n;
        }
        
        async function fetchTokenTransfers(addr, apiKey, chainId, chainKey) {
            try {
                // Solana - usa RPC per token SPL
                if (chainKey === 'solana') {
                    const r = await fetch('https://api.mainnet-beta.solana.com', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            jsonrpc: '2.0', id: 1, 
                            method: 'getTokenAccountsByOwner',
                            params: [addr, { programId: 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' }, { encoding: 'jsonParsed' }]
                        })
                    });
                    const d = await r.json();
                    const bal = {};
                    if (d.result?.value) {
                        for (const acc of d.result.value) {
                            const info = acc.account?.data?.parsed?.info;
                            if (info && info.tokenAmount?.uiAmount > 0) {
                                const mint = info.mint;
                                bal[mint] = {
                                    symbol: 'SPL', // Will try to get from DexScreener
                                    name: 'Solana Token',
                                    decimals: info.tokenAmount.decimals,
                                    balance: BigInt(info.tokenAmount.amount)
                                };
                            }
                        }
                    }
                    return bal;
                }
                
                // PulseChain - usa PulseScan API
                if (chainKey === 'pulse') {
                    const r = await fetch(`https://api.scan.pulsechain.com/api?module=account&action=tokentx&address=${addr}&startblock=0&endblock=99999999&sort=asc`);
                    const d = await r.json();
                    if (d.status === '1' && d.result) {
                        const bal = {}, w = addr.toLowerCase();
                        for (const tx of d.result) {
                            const c = tx.contractAddress.toLowerCase();
                            if (!bal[c]) bal[c] = { symbol: tx.tokenSymbol, name: tx.tokenName, decimals: parseInt(tx.tokenDecimal||'18'), balance: 0n };
                            const v = BigInt(tx.value||'0');
                            if (tx.to.toLowerCase() === w) bal[c].balance += v;
                            if (tx.from.toLowerCase() === w) bal[c].balance -= v;
                        }
                        return bal;
                    }
                    return {};
                }
                
                // EVM chains - usa Etherscan V2
                const r = await fetch(`https://api.etherscan.io/v2/api?chainid=${chainId}&module=account&action=tokentx&address=${addr}&startblock=0&endblock=99999999&sort=asc&apikey=${apiKey}`);
                const d = await r.json();
                if (d.status === '1' && d.result) {
                    const bal = {}, w = addr.toLowerCase();
                    for (const tx of d.result) {
                        const c = tx.contractAddress.toLowerCase();
                        if (!bal[c]) bal[c] = { symbol: tx.tokenSymbol, name: tx.tokenName, decimals: parseInt(tx.tokenDecimal||'18'), balance: 0n };
                        const v = BigInt(tx.value||'0');
                        if (tx.to.toLowerCase() === w) bal[c].balance += v;
                        if (tx.from.toLowerCase() === w) bal[c].balance -= v;
                    }
                    return bal;
                }
            } catch(e) { console.error(`Token error ${chainKey}:`, e); }
            return {};
        }
        
        async function fetchTokenPrice(contract, dexChain) {
            try {
                const r = await fetch(`https://api.dexscreener.com/latest/dex/tokens/${contract}`);
                const d = await r.json();
                if (d.pairs?.length) {
                    const p = d.pairs.filter(x => x.chainId === dexChain).sort((a,b) => (b.liquidity?.usd||0) - (a.liquidity?.usd||0))[0];
                    if (p) return { price: parseFloat(p.priceUsd), logo: p.info?.imageUrl };
                }
            } catch(e) {}
            return null;
        }
        
        // ==================== SCAN ====================
        async function scanWallet() {
            const addr = document.getElementById('walletAddress').value.trim();
            const etherscanKey = apiKeys.etherscan || document.getElementById('apiKey').value.trim();
            
            if (!addr) { log('‚ùå Inserisci wallet address', 'error'); return; }
            if (!etherscanKey && !apiKeys.moralis) { 
                log('‚ùå Configura almeno una API (Moralis o Etherscan) in API Connect', 'error'); 
                return; 
            }
            if (selectedChains.length === 0) { log('‚ùå Seleziona almeno una chain', 'error'); return; }
            
            // Detect wallet type
            const isSolanaWallet = !addr.startsWith('0x') && /^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(addr);
            
            document.getElementById('statusLog').innerHTML = '';
            log(`üöÄ Scan Multi-Chain...`);
            log(`üìç ${addr.slice(0,8)}...${addr.slice(-6)} ${isSolanaWallet ? '(Solana)' : '(EVM)'}`);
            log(`‚õìÔ∏è ${selectedChains.map(c => CHAINS[c].name).join(', ')}`);
            
            // Mostra quale API sar√† usata
            if (isSolanaWallet) {
                log(`üü£ Usando Solana RPC`, 'info');
            } else if (apiKeys.moralis) {
                log(`üü¢ Usando Moralis API (veloce)`, 'info');
            } else {
                log(`üîµ Usando Etherscan API`, 'info');
            }
            
            saveSettings();
            
            try {
                await fetchEurUsd();
                await fetchNativePrices();
                log(`üí∞ ETH: $${formatNum(NATIVE_PRICES.ETH)} | BNB: $${formatNum(NATIVE_PRICES.BNB)} | SOL: $${formatNum(NATIVE_PRICES.SOL)}`, 'info');
                
                const results = [];
                
                for (const chainKey of selectedChains) {
                    const chain = CHAINS[chainKey];
                    
                    // Skip incompatible chains
                    if (isSolanaWallet && chainKey !== 'solana') {
                        continue; // Wallet Solana pu√≤ solo scansionare Solana
                    }
                    if (!isSolanaWallet && chainKey === 'solana') {
                        continue; // Wallet EVM non pu√≤ scansionare Solana
                    }
                    
                    log(`üì° ${chain.name}...`);
                    
                    // SOLANA: Use Helius API if available
                    if (chainKey === 'solana' && apiKeys.helius) {
                        log(`  üü£ Helius API...`, 'info');
                        const heliusResults = await fetchWithHelius(addr);
                        if (heliusResults && heliusResults.length > 0) {
                            results.push(...heliusResults);
                            const solToken = heliusResults.find(t => t.symbol === 'SOL');
                            if (solToken) {
                                log(`  SOL: ${formatNum(solToken.balance, 4)} ($${formatNum(solToken.valueUSD)})`, 'success');
                            }
                            const tokenCount = heliusResults.filter(t => t.symbol !== 'SOL').length;
                            if (tokenCount > 0) log(`  ${tokenCount} SPL tokens`, 'info');
                            continue;
                        } else {
                            log(`  ‚ö†Ô∏è Helius: nessun risultato`, 'warning');
                        }
                    }
                    
                    // Try Moralis first for supported chains
                    if (apiKeys.moralis && MORALIS_CHAINS[chainKey]) {
                        log(`  ‚ö° Moralis...`, 'info');
                        const moralisResults = await scanWithMoralis(addr, chainKey);
                        if (moralisResults && moralisResults.length > 0) {
                            results.push(...moralisResults);
                            const nativeToken = moralisResults.find(t => t.contract.startsWith('native-'));
                            if (nativeToken) {
                                log(`  ${nativeToken.symbol}: ${formatNum(nativeToken.balance, 4)} ($${formatNum(nativeToken.valueUSD)})`, 'success');
                            }
                            const tokenCount = moralisResults.filter(t => !t.contract.startsWith('native-')).length;
                            if (tokenCount > 0) log(`  ${tokenCount} tokens`, 'info');
                            await new Promise(r => setTimeout(r, 100));
                            continue;
                        }
                    }
                    
                    // Fallback to Etherscan/PulseScan/Solana RPC
                    if (!etherscanKey && chainKey !== 'pulse' && chainKey !== 'solana') {
                        log(`  ‚ö†Ô∏è Skip - nessuna API key`, 'warning');
                        continue;
                    }
                    
                    // Skip Solana RPC fallback if no Helius (too unreliable)
                    if (chainKey === 'solana' && !apiKeys.helius) {
                        log(`  ‚ö†Ô∏è Configura Helius API per Solana`, 'warning');
                        continue;
                    }
                    
                    // Native balance
                    const nativeWei = await fetchNativeBalance(addr, etherscanKey, chain.id, chainKey);
                    const nativeDecimals = chainKey === 'solana' ? 9 : 18;
                    const nativeBal = Number(nativeWei) / Math.pow(10, nativeDecimals);
                    const nativePrice = NATIVE_PRICES[chain.symbol] || NATIVE_PRICES.ETH;
                    
                    if (nativeBal > 0.0001) {
                        results.push({
                            symbol: chain.symbol,
                            name: `${chain.symbol} (${chain.name})`,
                            balance: nativeBal,
                            price: nativePrice,
                            valueUSD: nativeBal * nativePrice,
                            contract: `native-${chainKey}`,
                            logo: TOKEN_ICONS[chain.symbol],
                            chain: chainKey
                        });
                        log(`  ${chain.symbol}: ${formatNum(nativeBal, 4)} ($${formatNum(nativeBal * nativePrice)})`, 'success');
                    }
                    
                    // Token balances
                    const tokens = await fetchTokenTransfers(addr, etherscanKey, chain.id, chainKey);
                    let tokenCount = 0;
                    
                    for (const [c, t] of Object.entries(tokens)) {
                        if (isBlacklisted(c) || isSpam(t.name, t.symbol) || t.balance <= 0n) continue;
                        
                        const bal = Number(t.balance) / Math.pow(10, t.decimals);
                        let price = 0, logo = TOKEN_ICONS[t.symbol?.toUpperCase()] || null;
                        
                        const pd = await fetchTokenPrice(c, chain.dex);
                        if (pd) { price = pd.price; if (pd.logo) logo = pd.logo; }
                        
                        results.push({
                            symbol: t.symbol,
                            name: t.name,
                            balance: bal,
                            price,
                            valueUSD: bal * price,
                            contract: c,
                            logo,
                            chain: chainKey
                        });
                        
                        tokenCount++;
                        if (price > 0 && bal * price >= 1) {
                            log(`  ${t.symbol}: $${formatNum(bal * price)}`, 'success');
                        }
                        
                        await new Promise(r => setTimeout(r, 150));
                    }
                    
                    if (tokenCount > 0) log(`  ${tokenCount} tokens`, 'info');
                    await new Promise(r => setTimeout(r, 200));
                }
                
                results.sort((a, b) => b.valueUSD - a.valueUSD);
                
                // Trova nome wallet se salvato
                const walletName = savedWallets.find(w => w.address.toLowerCase() === addr.toLowerCase())?.name || 'Wallet';
                
                // Salva risultati per questo wallet
                walletResults[addr.toLowerCase()] = {
                    name: walletName,
                    results: results,
                    scannedAt: Date.now()
                };
                
                // Aggrega tutti i wallet per display
                aggregateAndDisplay();
                
                // Salva risultati su Firebase
                saveToFirebase();
                
                log('‚úÖ Completato!', 'success');
                document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString('it-IT');
                
            } catch(e) {
                log(`‚ùå Errore: ${e.message}`, 'error');
                console.error(e);
            }
        }
        
        // ==================== MULTI-WALLET ====================
        function aggregateAndDisplay() {
            // Combina risultati di tutti i wallet
            const allResults = [];
            
            for (const [addr, data] of Object.entries(walletResults)) {
                for (const token of data.results) {
                    // Aggiungi info wallet al token
                    allResults.push({
                        ...token,
                        walletAddress: addr,
                        walletName: data.name
                    });
                }
            }
            
            // Ordina per valore
            allResults.sort((a, b) => b.valueUSD - a.valueUSD);
            lastScanResults = allResults;
            
            displayResults(allResults);
        }
        
        async function scanAllWallets() {
            const etherscanKey = apiKeys.etherscan;
            if (!etherscanKey && !apiKeys.moralis) { 
                log('‚ùå Configura almeno una API (Moralis o Etherscan) in API Connect', 'error'); 
                return; 
            }
            if (savedWallets.length === 0) { log('‚ùå Nessun wallet salvato. Vai su Wallets per aggiungerli.', 'error'); return; }
            if (selectedChains.length === 0) { log('‚ùå Seleziona almeno una chain', 'error'); return; }
            
            document.getElementById('statusLog').innerHTML = '';
            log(`üöÄ Scan di ${savedWallets.length} wallet...`);
            
            // Mostra quale API sar√† usata
            if (apiKeys.moralis) {
                log(`üü¢ Usando Moralis API (veloce)`, 'info');
            } else {
                log(`üîµ Usando Etherscan API`, 'info');
            }
            
            // Reset risultati
            walletResults = {};
            
            await fetchEurUsd();
            await fetchNativePrices();
            log(`üí∞ ETH: $${formatNum(NATIVE_PRICES.ETH)} | BNB: $${formatNum(NATIVE_PRICES.BNB)} | SOL: $${formatNum(NATIVE_PRICES.SOL)}`, 'info');
            
            for (let i = 0; i < savedWallets.length; i++) {
                const wallet = savedWallets[i];
                log(`\nüìç [${i+1}/${savedWallets.length}] ${wallet.name}`);
                log(`   ${wallet.address.slice(0,8)}...${wallet.address.slice(-6)}`);
                
                // Detect wallet type
                const isSolanaWallet = wallet.type === 'solana' || (!wallet.address.startsWith('0x') && /^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(wallet.address));
                
                const results = [];
                
                for (const chainKey of selectedChains) {
                    const chain = CHAINS[chainKey];
                    
                    // Skip incompatible chains
                    if (isSolanaWallet && chainKey !== 'solana') {
                        continue; // Wallet Solana pu√≤ solo scansionare Solana
                    }
                    if (!isSolanaWallet && chainKey === 'solana') {
                        continue; // Wallet EVM non pu√≤ scansionare Solana
                    }
                    
                    log(`   ‚õìÔ∏è ${chain.name}...`);
                    
                    // SOLANA: Use Helius API if available
                    if (chainKey === 'solana' && apiKeys.helius) {
                        const heliusResults = await fetchWithHelius(wallet.address);
                        if (heliusResults && heliusResults.length > 0) {
                            results.push(...heliusResults);
                            const solToken = heliusResults.find(t => t.symbol === 'SOL');
                            if (solToken) {
                                log(`      SOL: ${formatNum(solToken.balance, 4)} ($${formatNum(solToken.valueUSD)})`, 'success');
                            }
                            for (const t of heliusResults.filter(t => t.symbol !== 'SOL' && t.valueUSD >= 1)) {
                                log(`      ${t.symbol}: $${formatNum(t.valueUSD)}`, 'success');
                            }
                            continue;
                        }
                    }
                    
                    // Skip Solana if no Helius
                    if (chainKey === 'solana' && !apiKeys.helius) {
                        log(`      ‚ö†Ô∏è Configura Helius per Solana`, 'warning');
                        continue;
                    }
                    
                    // Try Moralis first for supported chains
                    if (apiKeys.moralis && MORALIS_CHAINS[chainKey]) {
                        const moralisResults = await scanWithMoralis(wallet.address, chainKey);
                        if (moralisResults && moralisResults.length > 0) {
                            results.push(...moralisResults);
                            const nativeToken = moralisResults.find(t => t.contract.startsWith('native-'));
                            if (nativeToken) {
                                log(`      ${nativeToken.symbol}: ${formatNum(nativeToken.balance, 4)} ($${formatNum(nativeToken.valueUSD)})`, 'success');
                            }
                            const tokenCount = moralisResults.filter(t => !t.contract.startsWith('native-') && t.valueUSD >= 1).length;
                            for (const t of moralisResults.filter(t => !t.contract.startsWith('native-') && t.valueUSD >= 1)) {
                                log(`      ${t.symbol}: $${formatNum(t.valueUSD)}`, 'success');
                            }
                            await new Promise(r => setTimeout(r, 100));
                            continue;
                        }
                    }
                    
                    // Fallback to Etherscan/PulseScan
                    if (!etherscanKey && chainKey !== 'pulse') {
                        continue; // Skip silently
                    }
                    
                    // Native balance
                    const nativeWei = await fetchNativeBalance(wallet.address, etherscanKey, chain.id, chainKey);
                    const nativeDecimals = chainKey === 'solana' ? 9 : 18;
                    const nativeBal = Number(nativeWei) / Math.pow(10, nativeDecimals);
                    const nativePrice = NATIVE_PRICES[chain.symbol] || NATIVE_PRICES.ETH;
                    
                    if (nativeBal > 0.0001) {
                        results.push({
                            symbol: chain.symbol,
                            name: `${chain.symbol} (${chain.name})`,
                            balance: nativeBal,
                            price: nativePrice,
                            valueUSD: nativeBal * nativePrice,
                            contract: `native-${chainKey}`,
                            logo: TOKEN_ICONS[chain.symbol],
                            chain: chainKey
                        });
                        log(`      ${chain.symbol}: ${formatNum(nativeBal, 4)} ($${formatNum(nativeBal * nativePrice)})`, 'success');
                    }
                    
                    // Token balances
                    const tokens = await fetchTokenTransfers(wallet.address, etherscanKey, chain.id, chainKey);
                    
                    for (const [c, t] of Object.entries(tokens)) {
                        if (isBlacklisted(c) || isSpam(t.name, t.symbol) || t.balance <= 0n) continue;
                        
                        const bal = Number(t.balance) / Math.pow(10, t.decimals);
                        let price = 0, logo = TOKEN_ICONS[t.symbol?.toUpperCase()] || null;
                        
                        const pd = await fetchTokenPrice(c, chain.dex);
                        if (pd) { price = pd.price; if (pd.logo) logo = pd.logo; }
                        
                        results.push({
                            symbol: t.symbol,
                            name: t.name,
                            balance: bal,
                            price,
                            valueUSD: bal * price,
                            contract: c,
                            logo,
                            chain: chainKey
                        });
                        
                        if (price > 0 && bal * price >= 1) {
                            log(`      ${t.symbol}: $${formatNum(bal * price)}`, 'success');
                        }
                        
                        await new Promise(r => setTimeout(r, 150));
                    }
                    
                    await new Promise(r => setTimeout(r, 200));
                }
                
                // Salva risultati wallet
                walletResults[wallet.address.toLowerCase()] = {
                    name: wallet.name,
                    results: results,
                    scannedAt: Date.now()
                };
                
                const walletTotal = results.reduce((s, t) => s + t.valueUSD, 0);
                log(`   üí∞ Totale ${wallet.name}: $${formatNum(walletTotal)}`, 'success');
            }
            
            // Aggrega e mostra
            aggregateAndDisplay();
            
            // Salva risultati su Firebase
            saveToFirebase();
            
            const grandTotal = Object.values(walletResults).reduce((sum, w) => 
                sum + w.results.reduce((s, t) => s + t.valueUSD, 0), 0);
            
            log(`\nüéâ TOTALE PORTFOLIO: $${formatNum(grandTotal)} (‚Ç¨${formatNum(grandTotal * EUR_USD)})`, 'success');
            document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString('it-IT');
        }
        
        function clearWalletResults() {
            walletResults = {};
            lastScanResults = [];
            displayResults([]);
            saveToFirebase();
            log('üóëÔ∏è Risultati cancellati', 'info');
        }
        
        // ==================== DISPLAY ====================
        function displayResults(results) {
            const visible = results.filter(t => !isBlacklisted(t.contract));
            const withVal = visible.filter(t => t.valueUSD >= 0.01);
            const walletsUSD = withVal.reduce((s, t) => s + t.valueUSD, 0);
            
            // Calcola totale exchange da CSV (usa anno pi√π recente disponibile)
            let exchangeTotalEUR = 0;
            let exchangeNames = [];
            for (const exchId of Object.keys(exchangeData)) {
                const data = exchangeData[exchId];
                if (data && data.totals) {
                    // Prendi anno pi√π recente con valore > 0
                    const latestYear = [2025, 2024, 2023, 2022, 2021].find(y => data.totals[y] > 0);
                    if (latestYear && data.totals[latestYear] > 0) {
                        exchangeTotalEUR += data.totals[latestYear];
                        const exchInfo = EXCHANGE_LIST.find(e => e.id === exchId);
                        if (exchInfo) exchangeNames.push(exchInfo.name);
                    }
                }
            }
            
            const totalUSD = walletsUSD + (exchangeTotalEUR / EUR_USD);
            const totalEUR = totalUSD * EUR_USD;
            
            document.getElementById('totalEUR').textContent = '‚Ç¨' + formatEUR(totalEUR);
            document.getElementById('totalUSD').textContent = '$' + formatEUR(totalUSD) + ' USD';
            document.getElementById('tokenCount').textContent = withVal.length;
            
            // Aggiorna card Exchanges
            document.getElementById('exchangeTotalEUR').textContent = '‚Ç¨' + formatEUR(exchangeTotalEUR);
            if (exchangeNames.length > 0) {
                document.getElementById('exchangeNames').textContent = exchangeNames.join(', ') + ' ‚úì';
            } else {
                document.getElementById('exchangeNames').textContent = 'Nessuno';
            }
            
            // Conta wallet scansionati
            const scannedCount = Object.keys(walletResults).length;
            document.getElementById('scannedWallets').textContent = scannedCount;
            const walletNames = Object.values(walletResults).map(w => w.name).join(', ') || '-';
            document.getElementById('chainNames').textContent = walletNames.length > 30 ? walletNames.slice(0, 30) + '...' : walletNames;
            
            const container = document.getElementById('holdingsContent');
            if (!withVal.length) {
                container.innerHTML = '<div class="empty-state"><div class="icon">üì≠</div><h3>Nessun token con valore</h3></div>';
                return;
            }
            
            let html = `<table class="holdings-table">
                <thead><tr><th>Token</th><th class="text-right">Balance</th><th class="text-right">Prezzo</th><th class="text-right">Valore</th></tr></thead>
                <tbody>`;
            
            for (const t of withVal) {
                const chain = CHAINS[t.chain];
                const pct = totalUSD > 0 ? ((t.valueUSD / totalUSD) * 100).toFixed(1) : '0';
                const vEUR = t.valueUSD * EUR_USD;
                
                html += `<tr>
                    <td><div class="token-cell">
                        <button class="hide-btn" onclick="hideToken('${t.contract}','${t.symbol}')">‚úï</button>
                        <div class="token-icon">${t.logo ? `<img src="${t.logo}" onerror="this.parentElement.textContent='${t.symbol.slice(0,2)}'">` : t.symbol.slice(0,2)}</div>
                        <div class="token-info">
                            <div class="symbol">${t.symbol}<span class="chain-badge" style="background:${chain?.color || '#666'}20;color:${chain?.color || '#666'}">${t.chain}</span></div>
                            <div class="name">${t.name}${t.walletName ? ` <span style="color:var(--accent-light);font-size:10px;">‚Ä¢ ${t.walletName}</span>` : ''}</div>
                        </div>
                    </div></td>
                    <td class="text-right text-mono">${formatNum(t.balance, 4)}</td>
                    <td class="text-right text-mono text-secondary">$${t.price > 0 ? formatNum(t.price, 6) : '-'}</td>
                    <td class="text-right">
                        <div class="text-mono" style="color:var(--green);">‚Ç¨${formatEUR(vEUR)}</div>
                        <div class="text-secondary" style="font-size:11px;">${pct}%</div>
                    </td>
                </tr>`;
            }
            
            html += '</tbody></table>';
            container.innerHTML = html;
            
            // Chart
            if (withVal.length > 0) renderChart(withVal, totalUSD);
        }
        
        function renderChart(tokens, total) {
            const ctx = document.getElementById('allocationChart').getContext('2d');
            if (allocationChart) allocationChart.destroy();
            
            const top5 = tokens.slice(0, 5);
            const others = tokens.slice(5);
            const othersVal = others.reduce((s, t) => s + t.valueUSD, 0);
            
            const labels = top5.map(t => t.symbol);
            const data = top5.map(t => t.valueUSD);
            if (othersVal > 0) { labels.push('Altri'); data.push(othersVal); }
            
            const colors = ['#6c5ce7', '#00cec9', '#ffeaa7', '#ff7675', '#74b9ff', '#a29bfe'];
            
            allocationChart = new Chart(ctx, {
                type: 'doughnut',
                data: { labels, datasets: [{ data, backgroundColor: colors.slice(0, data.length), borderWidth: 0 }] },
                options: { responsive: true, cutout: '70%', plugins: { legend: { position: 'bottom', labels: { color: '#a0a0a0', padding: 15 } } } }
            });
        }
        
        // ==================== TAX REPORT ====================
        async function calculateTaxReportAll() {
            const etherscanKey = apiKeys.etherscan;
            
            if (!etherscanKey) { 
                alert('Configura Etherscan API in API Connect prima! (necessaria per storico transazioni)'); 
                return; 
            }
            
            if (savedWallets.length === 0) {
                alert('Nessun wallet salvato! Vai su Wallets per aggiungerne.');
                return;
            }
            
            if (selectedChains.length === 0) {
                alert('Seleziona almeno una chain nella Dashboard!');
                return;
            }
            
            const container = document.getElementById('taxReportContent');
            const detailCard = document.getElementById('taxDetailCard');
            const detailContent = document.getElementById('taxDetailContent');
            
            container.innerHTML = `<div class="empty-state"><div class="icon">‚è≥</div><h3>Caricamento ${savedWallets.length} wallet su ${selectedChains.length} chain...</h3></div>`;
            
            const years = [2021, 2022, 2023, 2024, 2025];
            
            // Totali aggregati per anno
            const grandTotals = {};
            for (const y of years) grandTotals[y] = { eur: 0, usd: 0 };
            
            // Dettagli per wallet
            const walletDetails = [];
            
            // Chain native symbols
            const CHAIN_NATIVE = {
                eth: 'ETH', bsc: 'BNB', polygon: 'MATIC', arbitrum: 'ETH', 
                optimism: 'ETH', base: 'ETH', pulse: 'PLS', solana: 'SOL'
            };
            
            try {
                for (let wi = 0; wi < savedWallets.length; wi++) {
                    const wallet = savedWallets[wi];
                    const addr = wallet.address;
                    const walletLower = addr.toLowerCase();
                    
                    const balances = {};
                    const allTokens = {};
                    for (const y of years) balances[y] = {};
                    
                    for (const chainKey of selectedChains) {
                        const chain = CHAINS[chainKey];
                        const nativeSym = CHAIN_NATIVE[chainKey];
                        
                        container.innerHTML = `<div class="empty-state"><div class="icon">‚è≥</div><h3>Wallet ${wi + 1}/${savedWallets.length}: ${wallet.name}<br><small style="color:var(--text-secondary);">${chain.name}...</small></h3></div>`;
                        
                        let nativeTx = [], internalTx = [], tokenTx = [];
                        
                        // Fetch transactions based on chain type
                        if (chainKey === 'pulse') {
                            // PulseChain - use PulseScan
                            const [nRes, tRes] = await Promise.all([
                                fetch(`https://api.scan.pulsechain.com/api?module=account&action=txlist&address=${addr}&startblock=0&endblock=99999999&sort=asc`).then(r => r.json()),
                                fetch(`https://api.scan.pulsechain.com/api?module=account&action=tokentx&address=${addr}&startblock=0&endblock=99999999&sort=asc`).then(r => r.json())
                            ]);
                            nativeTx = nRes.status === '1' ? nRes.result : [];
                            tokenTx = tRes.status === '1' ? tRes.result : [];
                        } else if (chainKey === 'solana') {
                            // Solana - skip for now (no easy historical API)
                            continue;
                        } else {
                            // EVM chains - use Etherscan V2
                            const [nRes, iRes, tRes] = await Promise.all([
                                fetch(`https://api.etherscan.io/v2/api?chainid=${chain.id}&module=account&action=txlist&address=${addr}&startblock=0&endblock=99999999&sort=asc&apikey=${etherscanKey}`).then(r => r.json()),
                                fetch(`https://api.etherscan.io/v2/api?chainid=${chain.id}&module=account&action=txlistinternal&address=${addr}&startblock=0&endblock=99999999&sort=asc&apikey=${etherscanKey}`).then(r => r.json()),
                                fetch(`https://api.etherscan.io/v2/api?chainid=${chain.id}&module=account&action=tokentx&address=${addr}&startblock=0&endblock=99999999&sort=asc&apikey=${etherscanKey}`).then(r => r.json())
                            ]);
                            nativeTx = nRes.status === '1' ? nRes.result : [];
                            internalTx = iRes.status === '1' ? iRes.result : [];
                            tokenTx = tRes.status === '1' ? tRes.result : [];
                        }
                        
                        // Get tokens from this chain
                        for (const tx of tokenTx) {
                            const sym = tx.tokenSymbol?.toUpperCase();
                            const c = tx.contractAddress.toLowerCase();
                            const key = `${chainKey}:${c}`;
                            if (!allTokens[key]) {
                                allTokens[key] = { 
                                    symbol: tx.tokenSymbol, 
                                    decimals: parseInt(tx.tokenDecimal || '18'),
                                    chain: chainKey,
                                    chainName: chain.name
                                };
                            }
                        }
                        
                        // Calculate native balance per year
                        for (const y of years) {
                            const ts = new Date(`${y + 1}-01-01T00:00:00Z`).getTime() / 1000;
                            let bal = 0n;
                            
                            for (const tx of nativeTx) {
                                if (parseInt(tx.timeStamp) >= ts || tx.isError === '1') continue;
                                const v = BigInt(tx.value || '0');
                                const g = BigInt(tx.gasUsed || '0') * BigInt(tx.gasPrice || '0');
                                if (tx.to?.toLowerCase() === walletLower) bal += v;
                                if (tx.from?.toLowerCase() === walletLower) { bal -= v; bal -= g; }
                            }
                            
                            for (const tx of internalTx) {
                                if (parseInt(tx.timeStamp) >= ts || tx.isError === '1') continue;
                                const v = BigInt(tx.value || '0');
                                if (tx.to?.toLowerCase() === walletLower) bal += v;
                                if (tx.from?.toLowerCase() === walletLower) bal -= v;
                            }
                            
                            const nativeKey = `${nativeSym} (${chain.name})`;
                            if (!balances[y][nativeKey]) balances[y][nativeKey] = 0;
                            balances[y][nativeKey] += Number(bal < 0n ? 0n : bal) / 1e18;
                        }
                        
                        // Calculate token balances per year
                        for (const tx of tokenTx) {
                            const c = tx.contractAddress.toLowerCase();
                            const key = `${chainKey}:${c}`;
                            const info = allTokens[key];
                            if (!info) continue;
                            
                            for (const y of years) {
                                const ts = new Date(`${y + 1}-01-01T00:00:00Z`).getTime() / 1000;
                                if (parseInt(tx.timeStamp) >= ts) continue;
                                
                                const tokenKey = `${info.symbol} (${chain.name})`;
                                if (!balances[y][tokenKey]) balances[y][tokenKey] = 0;
                                
                                const v = BigInt(tx.value || '0');
                                const amount = Number(v) / Math.pow(10, info.decimals);
                                
                                if (tx.to?.toLowerCase() === walletLower) {
                                    balances[y][tokenKey] += amount;
                                }
                                if (tx.from?.toLowerCase() === walletLower) {
                                    balances[y][tokenKey] -= amount;
                                }
                            }
                        }
                        
                        // Rate limit
                        await new Promise(r => setTimeout(r, 250));
                    }
                    
                    // Fix negative balances
                    for (const y of years) {
                        for (const key of Object.keys(balances[y])) {
                            if (balances[y][key] < 0) balances[y][key] = 0;
                        }
                    }
                    
                    // Calculate wallet totals per year
                    const walletTotals = {};
                    for (const y of years) {
                        walletTotals[y] = { eur: 0, usd: 0 };
                        
                        for (const [tokenKey, bal] of Object.entries(balances[y])) {
                            if (bal <= 0) continue;
                            
                            // Extract symbol from key like "ETH (Ethereum)"
                            const sym = tokenKey.split(' (')[0].toUpperCase();
                            const cgId = SYMBOL_TO_CG[sym];
                            const price = HISTORICAL_PRICES[cgId]?.[y] || 0;
                            
                            if (price > 0) {
                                walletTotals[y].usd += bal * price;
                                walletTotals[y].eur += bal * price * EUR_USD;
                            }
                        }
                        
                        // Add to grand totals
                        grandTotals[y].usd += walletTotals[y].usd;
                        grandTotals[y].eur += walletTotals[y].eur;
                    }
                    
                    walletDetails.push({ wallet, balances, totals: walletTotals, tokens: allTokens });
                }
                
                // Prepara struttura dati serializzabile per Firebase
                const chainNames = selectedChains.map(c => CHAINS[c].name).join(', ');
                const serializedWalletDetails = walletDetails.map(wd => {
                    // Get all token keys that have value
                    const tokenKeys = new Set();
                    for (const y of years) {
                        for (const key of Object.keys(wd.balances[y])) {
                            if (wd.balances[y][key] > 0) tokenKeys.add(key);
                        }
                    }
                    
                    const rows = [];
                    for (const tokenKey of tokenKeys) {
                        const sym = tokenKey.split(' (')[0].toUpperCase();
                        const cgId = SYMBOL_TO_CG[sym];
                        
                        // Check if has any value
                        const hasValue = years.some(y => {
                            const bal = wd.balances[y][tokenKey] || 0;
                            const price = HISTORICAL_PRICES[cgId]?.[y] || 0;
                            return bal * price * EUR_USD >= 1;
                        });
                        if (!hasValue) continue;
                        
                        const cells = {};
                        for (const y of years) {
                            const bal = wd.balances[y][tokenKey] || 0;
                            const price = HISTORICAL_PRICES[cgId]?.[y] || 0;
                            cells[y] = {
                                balance: bal,
                                eur: bal * price * EUR_USD,
                                hasValue: bal > 0 && price > 0
                            };
                        }
                        rows.push({ tokenKey, cells });
                    }
                    
                    return {
                        walletName: wd.wallet.name,
                        walletAddress: wd.wallet.address.slice(0,8) + '...' + wd.wallet.address.slice(-6),
                        totals: wd.totals,
                        rows
                    };
                });
                
                // Salva in memoria e Firebase
                taxReportData = {
                    grandTotals,
                    walletDetails: serializedWalletDetails,
                    walletCount: savedWallets.length,
                    chainNames,
                    calculatedAt: Date.now()
                };
                saveToFirebase();
                
                // Render usando la funzione condivisa
                renderTaxReport(taxReportData);
                
            } catch(e) {
                container.innerHTML = `<div class="empty-state"><div class="icon">‚ùå</div><h3>Errore: ${e.message}</h3></div>`;
                console.error(e);
            }
        }
        
        // ==================== EXCHANGES CSV ====================
        function initExchangeGrid() {
            const grid = document.getElementById('exchangeGrid');
            if (!grid) return;
            
            let html = '';
            for (const exch of EXCHANGE_LIST) {
                const data = exchangeData[exch.id] || {};
                // Controlla se ci sono transazioni O dati salvati (transactionCount o totali)
                const hasTx = (data.transactions && data.transactions.length > 0);
                const hasData = hasTx || data.transactionCount > 0 || (data.totals && Object.values(data.totals).some(v => v > 0));
                const txCount = data.transactions ? data.transactions.length : (data.transactionCount || 0);
                const total2024 = data.totals ? (data.totals[2024] || 0) : 0;
                
                html += '<div class="card exchange-card" id="exch-' + exch.id + '" style="position:relative;overflow:hidden;">';
                html += '<div class="card-header" style="cursor:pointer;" onclick="toggleExchangeDropzone(\'' + exch.id + '\')">';
                html += '<div class="card-title" style="display:flex;align-items:center;gap:12px;">';
                html += '<span style="width:40px;height:40px;background:' + exch.color + ';border-radius:10px;display:flex;align-items:center;justify-content:center;font-size:14px;font-weight:bold;color:#fff;">' + exch.icon + '</span>';
                html += '<div><div style="font-size:14px;">' + exch.name + '</div>';
                if (hasData) {
                    html += '<div style="font-size:11px;color:var(--green);">‚úì ' + (txCount > 0 ? txCount + ' tx' : 'Dati salvati') + '</div>';
                } else {
                    html += '<div style="font-size:11px;color:var(--text-secondary);">üìÇ Importa CSV</div>';
                }
                html += '</div></div>';
                if (hasData && total2024 > 0) {
                    html += '<div style="text-align:right;"><div style="font-size:11px;color:var(--text-secondary);">2024</div><div style="font-size:16px;font-weight:700;color:var(--green);">‚Ç¨' + formatEUR(total2024) + '</div></div>';
                }
                html += '</div>';
                
                // Dropzone (nascosta inizialmente)
                html += '<div id="dropzone-' + exch.id + '" class="exchange-dropzone" style="display:none;margin-top:16px;border:2px dashed var(--border);border-radius:8px;padding:24px;text-align:center;transition:all 0.3s;"';
                html += ' ondragover="handleDragOver(event, \'' + exch.id + '\')" ondragleave="handleDragLeave(event, \'' + exch.id + '\')" ondrop="handleDrop(event, \'' + exch.id + '\')">';
                html += '<div style="font-size:32px;margin-bottom:8px;">üìÇ</div>';
                html += '<div style="color:var(--text-secondary);font-size:13px;">Trascina ZIP o CSV qui</div>';
                html += '<input type="file" id="file-' + exch.id + '" accept=".csv,.zip" multiple style="display:none;" onchange="handleFileSelect(event, \'' + exch.id + '\')">';
                html += '<button class="btn btn-secondary" onclick="document.getElementById(\'file-' + exch.id + '\').click()" style="margin-top:12px;font-size:12px;">üìÅ Sfoglia</button>';
                if (hasData) {
                    html += '<button class="btn" onclick="clearExchangeData(\'' + exch.id + '\')" style="margin-top:12px;margin-left:8px;font-size:12px;background:var(--red);">üóëÔ∏è Reset</button>';
                }
                html += '</div>';
                
                // Totali per anno (se presenti)
                if (hasData && data.totals) {
                    html += '<div style="margin-top:12px;display:grid;grid-template-columns:repeat(5,1fr);gap:6px;font-size:11px;">';
                    for (const y of [2021, 2022, 2023, 2024, 2025]) {
                        const val = data.totals[y] || 0;
                        html += '<div style="background:var(--bg-primary);padding:6px;border-radius:4px;text-align:center;">';
                        html += '<div style="color:var(--text-secondary);">' + y + '</div>';
                        html += '<div style="color:' + (val > 0 ? 'var(--green)' : 'var(--text-secondary)') + ';font-weight:600;">‚Ç¨' + formatEUR(val) + '</div>';
                        html += '</div>';
                    }
                    html += '</div>';
                }
                
                html += '</div>';
            }
            
            grid.innerHTML = html;
        }
        
        function toggleExchangeDropzone(exchId) {
            const dropzone = document.getElementById('dropzone-' + exchId);
            if (dropzone) {
                dropzone.style.display = dropzone.style.display === 'none' ? 'block' : 'none';
            }
        }
        
        function handleDragOver(e, exchId) {
            e.preventDefault();
            const dropzone = document.getElementById('dropzone-' + exchId);
            if (dropzone) {
                dropzone.style.borderColor = 'var(--green)';
                dropzone.style.background = 'rgba(0,230,118,0.1)';
            }
        }
        
        function handleDragLeave(e, exchId) {
            e.preventDefault();
            const dropzone = document.getElementById('dropzone-' + exchId);
            if (dropzone) {
                dropzone.style.borderColor = 'var(--border)';
                dropzone.style.background = 'transparent';
            }
        }
        
        async function handleDrop(e, exchId) {
            e.preventDefault();
            handleDragLeave(e, exchId);
            const files = e.dataTransfer.files;
            await processExchangeFiles(files, exchId);
        }
        
        async function handleFileSelect(e, exchId) {
            const files = e.target.files;
            await processExchangeFiles(files, exchId);
        }
        
        async function processExchangeFiles(files, exchId) {
            console.log('Processing files for', exchId, files.length, 'files');
            
            // Mostra stato caricamento
            const dropzone = document.getElementById('dropzone-' + exchId);
            if (dropzone) {
                dropzone.innerHTML = '<div style="font-size:32px;margin-bottom:8px;">‚è≥</div><div style="color:var(--accent);font-size:13px;">Elaborazione in corso...</div>';
            }
            
            let allTransactions = [];
            
            try {
                for (const file of files) {
                    console.log('Processing file:', file.name, 'size:', file.size);
                    
                    if (file.name.endsWith('.zip')) {
                        // Estrai ZIP
                        const transactions = await processZipFile(file, exchId);
                        console.log('ZIP parsed:', transactions.length, 'transactions');
                        allTransactions.push(...transactions);
                    } else if (file.name.endsWith('.csv')) {
                        // Parse CSV direttamente
                        const text = await file.text();
                        console.log('CSV loaded, length:', text.length);
                        const transactions = parseExchangeCSV(text, exchId);
                        console.log('CSV parsed:', transactions.length, 'transactions');
                        allTransactions.push(...transactions);
                    }
                }
                
                console.log('Total transactions:', allTransactions.length);
                
                if (allTransactions.length > 0) {
                    // Salva transazioni (solo totali per risparmiare spazio)
                    if (!exchangeData[exchId]) {
                        exchangeData[exchId] = { transactions: [], balances: {}, totals: {} };
                    }
                    exchangeData[exchId].transactions = allTransactions;
                    
                    // Calcola saldi al 31/12
                    calculateExchangeBalances(exchId);
                    
                    // Aggiorna UI
                    initExchangeGrid();
                    updateExchangeTotals();
                    saveExchangeDataToFirebase();
                    
                    alert('‚úÖ ' + exchId.toUpperCase() + ': Importate ' + allTransactions.length + ' transazioni!');
                } else {
                    alert('‚ùå Nessuna transazione trovata nei file. Controlla la console (F12) per i dettagli.');
                    initExchangeGrid(); // Ripristina dropzone
                }
            } catch (err) {
                console.error('Error processing files:', err);
                alert('‚ùå Errore: ' + err.message);
                initExchangeGrid(); // Ripristina dropzone
            }
        }
        
        async function processZipFile(file, exchId) {
            // Usa JSZip (gi√† caricato nell'head)
            try {
                console.log('Processing ZIP file:', file.name);
                const zip = await JSZip.loadAsync(file);
                let allTransactions = [];
                
                for (const [path, zipEntry] of Object.entries(zip.files)) {
                    console.log('ZIP entry:', path);
                    if (path.endsWith('.csv') && !path.includes('__MACOSX') && !path.includes('.DS_Store')) {
                        const text = await zipEntry.async('text');
                        console.log('Parsing CSV:', path, 'length:', text.length);
                        const transactions = parseExchangeCSV(text, exchId);
                        console.log('Parsed', transactions.length, 'transactions from', path);
                        allTransactions.push(...transactions);
                    }
                }
                
                return allTransactions;
            } catch (e) {
                console.error('ZIP processing error:', e);
                alert('Errore lettura ZIP: ' + e.message);
                return [];
            }
        }
        
        function loadScript(src) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = src;
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }
        
        function parseExchangeCSV(text, exchId) {
            // Parser generico che adatta al formato dell'exchange
            // Rimuovi BOM (byte order mark) se presente
            const cleanText = text.replace(/^\uFEFF/, '').trim();
            const lines = cleanText.split('\n');
            console.log('parseExchangeCSV for', exchId, '- lines:', lines.length);
            
            if (lines.length < 2) {
                console.log('Not enough lines in CSV');
                return [];
            }
            
            // Pulisci header da BOM e caratteri speciali
            let header = lines[0].toLowerCase().replace(/^\uFEFF/, '').replace(/[^\x20-\x7E,]/g, '').trim();
            console.log('Header (cleaned):', header.substring(0, 120));
            
            // === BINANCE ===
            if (header.includes('utc_time') && header.includes('coin')) {
                console.log('Detected Binance format');
                return parseBinanceCSV(lines);
            }
            
            // === BITGET ===
            if (header.includes('order') && header.includes('date') && header.includes('coin') && header.includes('amount')) {
                console.log('Detected Bitget format');
                return parseBitgetCSV(lines);
            }
            
            // === CRYPTO.COM APP ===
            if (header.includes('timestamp') && header.includes('transaction description') && header.includes('currency')) {
                console.log('Detected Crypto.com App format');
                return parseCryptoComAppCSV(lines);
            }
            
            // === CRYPTO.COM EXCHANGE ===
            if (header.includes('event_time_display') && header.includes('instrument_name') && header.includes('journal_type')) {
                console.log('Detected Crypto.com Exchange format');
                return parseCryptoComExchangeCSV(lines);
            }
            
            // === COINBASE ===
            if (header.includes('transaction type') && header.includes('asset') && header.includes('quantity')) {
                console.log('Detected Coinbase format');
                return parseCoinbaseCSV(lines);
            }
            // Coinbase - cerca header nelle prime righe
            for (let i = 0; i < Math.min(10, lines.length); i++) {
                const testHeader = lines[i].toLowerCase();
                if (testHeader.includes('transaction type') && testHeader.includes('asset') && testHeader.includes('quantity')) {
                    console.log('Detected Coinbase format at line', i);
                    return parseCoinbaseCSV(lines.slice(i));
                }
            }
            
            // === COSMOS ===
            if (header.includes('tx_type') && header.includes('received_amount') && header.includes('received_currency')) {
                console.log('Detected Cosmos format');
                return parseCosmosCSV(lines);
            }
            
            // === BYBIT AssetChangeDetails ===
            if (header.includes('uid') && header.includes('currency') && header.includes('change') && header.includes('wallet balance')) {
                console.log('Detected Bybit AssetChangeDetails format');
                return parseBybitAssetChangeCSV(lines);
            }
            // Bybit - cerca header nelle prime righe (salta riga UID)
            for (let i = 0; i < Math.min(5, lines.length); i++) {
                const testHeader = lines[i].toLowerCase();
                if (testHeader.includes('uid') && testHeader.includes('currency') && testHeader.includes('change')) {
                    console.log('Detected Bybit AssetChangeDetails at line', i);
                    return parseBybitAssetChangeCSV(lines.slice(i));
                }
            }
            
            // === BYBIT Deposit/Withdraw History ===
            for (let i = 0; i < Math.min(5, lines.length); i++) {
                const testHeader = lines[i].toLowerCase();
                if (testHeader.includes('uid') && testHeader.includes('date') && testHeader.includes('type') && testHeader.includes('asset') && testHeader.includes('amount')) {
                    console.log('Detected Bybit DepositWithdraw at line', i);
                    return parseBybitDepositWithdrawCSV(lines.slice(i));
                }
            }
            
            // === BITPANDA ===
            // Cerca header nelle prime 10 righe (salta disclaimer)
            for (let i = 0; i < Math.min(10, lines.length); i++) {
                const testHeader = lines[i].toLowerCase();
                if (testHeader.includes('transaction id') && testHeader.includes('transaction type') && testHeader.includes('amount asset')) {
                    console.log('Detected Bitpanda format at line', i);
                    return parseBitpandaCSV(lines.slice(i));
                }
            }
            
            console.log('No matching parser found, using generic');
            return parseGenericCSV(lines, exchId);
        }
        
        // === CRYPTO.COM APP PARSER ===
        function parseCryptoComAppCSV(lines) {
            // Timestamp (UTC),Transaction Description,Currency,Amount,To Currency,To Amount,...,Transaction Kind
            const transactions = [];
            console.log('Parsing Crypto.com App CSV, lines:', lines.length);
            
            for (let i = 1; i < lines.length; i++) {
                const cols = parseCSVLine(lines[i]);
                if (cols.length < 10) continue;
                
                const [timestamp, description, currency, amount, toCurrency, toAmount, nativeCurrency, nativeAmount, nativeUsd, txKind] = cols;
                const date = new Date(timestamp);
                if (isNaN(date.getTime())) continue;
                
                // Prima valuta (pu√≤ essere + o -)
                const amountNum = parseFloat(amount) || 0;
                if (amountNum !== 0 && currency && currency !== '-') {
                    transactions.push({
                        date: date,
                        account: 'app',
                        operation: description,
                        coin: currency,
                        change: amountNum,
                        remark: txKind || ''
                    });
                }
                
                // Seconda valuta (To Currency / To Amount) - solo se presente e diversa dalla prima
                const toAmountNum = parseFloat(toAmount) || 0;
                if (toAmountNum !== 0 && toCurrency && toCurrency !== '-' && toCurrency !== currency) {
                    transactions.push({
                        date: date,
                        account: 'app',
                        operation: description,
                        coin: toCurrency,
                        change: toAmountNum, // To Amount √® sempre positivo (ricevuto)
                        remark: txKind || ''
                    });
                }
            }
            console.log('Parsed', transactions.length, 'Crypto.com App transactions');
            return transactions;
        }
        
        // === CRYPTO.COM EXCHANGE PARSER ===
        function parseCryptoComExchangeCSV(lines) {
            // event_time_display,instrument_name,journal_id,journal_type,...,transaction_qty,...
            const transactions = [];
            console.log('Parsing Crypto.com Exchange CSV, lines:', lines.length);
            
            for (let i = 1; i < lines.length; i++) {
                const cols = parseCSVLine(lines[i]);
                if (cols.length < 8) continue;
                
                const [eventTime, instrumentName, journalId, journalType, orderId, side, takerSide, transactionQty] = cols;
                const date = new Date(eventTime);
                if (isNaN(date.getTime())) continue;
                
                const qty = parseFloat(transactionQty) || 0;
                if (qty === 0) continue;
                
                transactions.push({
                    date: date,
                    account: 'exchange',
                    operation: journalType,
                    coin: instrumentName,
                    change: qty,
                    remark: ''
                });
            }
            console.log('Parsed', transactions.length, 'Crypto.com Exchange transactions');
            return transactions;
        }
        
        // === COINBASE PARSER ===
        function parseCoinbaseCSV(lines) {
            // ID,Timestamp,Transaction Type,Asset,Quantity Transacted,...
            const transactions = [];
            console.log('Parsing Coinbase CSV, lines:', lines.length);
            
            for (let i = 1; i < lines.length; i++) {
                const cols = parseCSVLine(lines[i]);
                if (cols.length < 5) continue;
                
                const [id, timestamp, txType, asset, quantity] = cols;
                const date = new Date(timestamp);
                if (isNaN(date.getTime())) continue;
                
                let qty = parseFloat(quantity) || 0;
                if (qty === 0) continue;
                
                // Determina segno basato sul tipo
                const txTypeLower = txType.toLowerCase();
                if (txTypeLower.includes('sell') || txTypeLower.includes('send') || txTypeLower.includes('withdraw')) {
                    qty = -Math.abs(qty);
                } else {
                    qty = Math.abs(qty);
                }
                
                transactions.push({
                    date: date,
                    account: 'coinbase',
                    operation: txType,
                    coin: asset,
                    change: qty,
                    remark: ''
                });
            }
            console.log('Parsed', transactions.length, 'Coinbase transactions');
            return transactions;
        }
        
        // === COSMOS PARSER ===
        function parseCosmosCSV(lines) {
            // timestamp,tx_type,received_amount,received_currency,sent_amount,sent_currency,...
            const transactions = [];
            console.log('Parsing Cosmos CSV, lines:', lines.length);
            
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].replace(/\r/g, '');
                const cols = parseCSVLine(line);
                if (cols.length < 6) continue;
                
                const [timestamp, txType, receivedAmount, receivedCurrency, sentAmount, sentCurrency] = cols;
                const date = new Date(timestamp);
                if (isNaN(date.getTime())) continue;
                
                // Received
                const recvAmt = parseFloat(receivedAmount) || 0;
                if (recvAmt > 0 && receivedCurrency) {
                    transactions.push({
                        date: date,
                        account: 'cosmos',
                        operation: txType,
                        coin: receivedCurrency.toUpperCase(),
                        change: recvAmt,
                        remark: ''
                    });
                }
                
                // Sent
                const sentAmt = parseFloat(sentAmount) || 0;
                if (sentAmt > 0 && sentCurrency) {
                    transactions.push({
                        date: date,
                        account: 'cosmos',
                        operation: txType,
                        coin: sentCurrency.toUpperCase(),
                        change: -sentAmt,
                        remark: ''
                    });
                }
            }
            console.log('Parsed', transactions.length, 'Cosmos transactions');
            return transactions;
        }
        
        // === BYBIT ASSET CHANGE DETAILS PARSER ===
        function parseBybitAssetChangeCSV(lines) {
            // Uid,Currency,Contract,Type,Direction,...,Change,...,Time(UTC)
            const transactions = [];
            console.log('Parsing Bybit AssetChange CSV, lines:', lines.length);
            
            // Trova indice colonne
            const header = lines[0].toLowerCase();
            const cols = header.split(',');
            const currencyIdx = cols.findIndex(c => c.includes('currency'));
            const changeIdx = cols.findIndex(c => c === 'change');
            const timeIdx = cols.findIndex(c => c.includes('time'));
            const typeIdx = cols.findIndex(c => c === 'type');
            
            if (currencyIdx === -1 || changeIdx === -1 || timeIdx === -1) {
                console.log('Cannot find required columns in Bybit CSV');
                return [];
            }
            
            for (let i = 1; i < lines.length; i++) {
                const parts = lines[i].split(',');
                if (parts.length <= Math.max(currencyIdx, changeIdx, timeIdx)) continue;
                
                const currency = parts[currencyIdx];
                const change = parseFloat(parts[changeIdx]) || 0;
                const timeStr = parts[timeIdx];
                const txType = typeIdx >= 0 ? parts[typeIdx] : '';
                
                const date = new Date(timeStr);
                if (isNaN(date.getTime()) || change === 0) continue;
                
                transactions.push({
                    date: date,
                    account: 'bybit',
                    operation: txType,
                    coin: currency,
                    change: change,
                    remark: ''
                });
            }
            console.log('Parsed', transactions.length, 'Bybit AssetChange transactions');
            return transactions;
        }
        
        // === BYBIT DEPOSIT/WITHDRAW PARSER ===
        function parseBybitDepositWithdrawCSV(lines) {
            // Uid,Date,Type,Asset,Chain,Amount,...
            const transactions = [];
            console.log('Parsing Bybit DepositWithdraw CSV, lines:', lines.length);
            
            for (let i = 1; i < lines.length; i++) {
                const cols = lines[i].split(',');
                if (cols.length < 6) continue;
                
                const [uid, dateStr, txType, asset, chain, amount] = cols;
                const date = new Date(dateStr);
                if (isNaN(date.getTime())) continue;
                
                let qty = parseFloat(amount) || 0;
                if (qty === 0) continue;
                
                // Withdraw = negativo
                if (txType.toLowerCase().includes('withdraw')) {
                    qty = -Math.abs(qty);
                }
                
                transactions.push({
                    date: date,
                    account: 'bybit',
                    operation: txType,
                    coin: asset,
                    change: qty,
                    remark: chain
                });
            }
            console.log('Parsed', transactions.length, 'Bybit DepositWithdraw transactions');
            return transactions;
        }
        
        // === BITPANDA PARSER ===
        function parseBitpandaCSV(lines) {
            // "Transaction ID",Timestamp,"Transaction Type",In/Out,"Amount Fiat",Fiat,"Amount Asset",Asset,...
            const transactions = [];
            console.log('Parsing Bitpanda CSV, lines:', lines.length);
            
            for (let i = 1; i < lines.length; i++) {
                const cols = parseCSVLine(lines[i]);
                if (cols.length < 8) continue;
                
                const [txId, timestamp, txType, inOut, amountFiat, fiat, amountAsset, asset] = cols;
                const date = new Date(timestamp);
                if (isNaN(date.getTime())) continue;
                
                let qty = parseFloat(amountAsset) || 0;
                if (qty === 0 || !asset || asset === '-') continue;
                
                // In/Out determina segno
                if (inOut.toLowerCase() === 'outgoing') {
                    qty = -Math.abs(qty);
                }
                
                transactions.push({
                    date: date,
                    account: 'bitpanda',
                    operation: txType,
                    coin: asset,
                    change: qty,
                    remark: ''
                });
            }
            console.log('Parsed', transactions.length, 'Bitpanda transactions');
            return transactions;
        }
        
        function parseBitgetCSV(lines) {
            // Formato: order,Date,Coin,Type,Amount,Fee,Available
            const transactions = [];
            console.log('Parsing Bitget CSV, lines:', lines.length);
            console.log('Header:', lines[0]);
            console.log('First data line:', lines[1]);
            
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i];
                if (!line.trim()) continue;
                
                // Parse CSV (pu√≤ avere tab iniziale)
                const cleanLine = line.replace(/^\t/, '').trim();
                const cols = cleanLine.split(',');
                
                if (cols.length < 5) {
                    console.log('Skipping line (not enough cols):', cols.length);
                    continue;
                }
                
                const [order, dateStr, coin, type, amount, fee, available] = cols;
                
                // Parse date (formato: YYYY-MM-DD HH:MM:SS)
                const date = new Date(dateStr);
                if (isNaN(date.getTime())) {
                    console.log('Invalid date:', dateStr);
                    continue;
                }
                
                const amountNum = parseFloat(amount) || 0;
                
                transactions.push({
                    date: date,
                    account: 'spot',
                    operation: type,
                    coin: coin,
                    change: amountNum, // Gi√† con segno corretto
                    remark: ''
                });
            }
            
            console.log('Parsed', transactions.length, 'Bitget transactions');
            if (transactions.length > 0) {
                console.log('First tx:', transactions[0]);
                console.log('Last tx:', transactions[transactions.length - 1]);
            }
            
            return transactions;
        }
        
        function parseBinanceCSV(lines) {
            // Formato: "User_ID","UTC_Time","Account","Operation","Coin","Change","Remark"
            const transactions = [];
            console.log('Parsing Binance CSV, lines:', lines.length);
            console.log('Header:', lines[0]);
            console.log('First data line:', lines[1]);
            
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i];
                if (!line.trim()) continue;
                
                // Parse CSV con virgolette
                const cols = parseCSVLine(line);
                if (cols.length < 6) {
                    console.log('Skipping line (not enough cols):', cols.length, line.substring(0, 50));
                    continue;
                }
                
                const [userId, utcTime, account, operation, coin, change, remark] = cols;
                
                // Parse date
                const date = new Date(utcTime);
                if (isNaN(date.getTime())) {
                    console.log('Invalid date:', utcTime);
                    continue;
                }
                
                const changeNum = parseFloat(change) || 0;
                
                transactions.push({
                    date: date,
                    account: account,
                    operation: operation,
                    coin: coin,
                    change: changeNum,
                    remark: remark || ''
                });
            }
            
            console.log('Parsed', transactions.length, 'transactions');
            if (transactions.length > 0) {
                console.log('First tx:', transactions[0]);
                console.log('Last tx:', transactions[transactions.length - 1]);
            }
            
            return transactions;
        }
        
        function parseGenericCSV(lines, exchId) {
            // Parser generico - cerca colonne comuni
            console.log('Using generic parser for', exchId);
            return [];
        }
        
        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            result.push(current.trim());
            
            return result;
        }
        
        function calculateExchangeBalances(exchId) {
            const data = exchangeData[exchId];
            if (!data || !data.transactions) {
                console.log('No transactions for', exchId);
                return;
            }
            
            console.log('Calculating balances for', exchId, 'with', data.transactions.length, 'transactions');
            
            // Ordina transazioni per data
            data.transactions.sort((a, b) => a.date - b.date);
            
            // Calcola saldi cumulativi
            const balances = {}; // { coin: amount }
            const yearEndBalances = {}; // { 2021: { BTC: 0.5, ... }, ... }
            const yearEndTotals = {}; // { 2021: 12345, ... }
            
            const years = [2021, 2022, 2023, 2024, 2025];
            let currentYearIndex = 0;
            
            // Prima trova la data pi√π vecchia
            const firstDate = data.transactions[0]?.date;
            const lastDate = data.transactions[data.transactions.length - 1]?.date;
            console.log('Date range:', firstDate, 'to', lastDate);
            
            for (const tx of data.transactions) {
                // Aggiorna saldo
                if (!balances[tx.coin]) balances[tx.coin] = 0;
                balances[tx.coin] += tx.change;
                
                // Controlla se abbiamo superato la fine dell'anno
                while (currentYearIndex < years.length && tx.date > new Date(years[currentYearIndex], 11, 31, 23, 59, 59)) {
                    // Salva snapshot al 31/12
                    yearEndBalances[years[currentYearIndex]] = { ...balances };
                    console.log('Snapshot for', years[currentYearIndex], '- coins:', Object.keys(balances).length);
                    currentYearIndex++;
                }
            }
            
            // Salva ultimi anni rimasti
            for (let i = currentYearIndex; i < years.length; i++) {
                yearEndBalances[years[i]] = { ...balances };
            }
            
            // Log dei saldi finali
            console.log('Final balances (coins with value):', 
                Object.entries(balances).filter(([c, a]) => a > 0.0001).map(([c, a]) => c + ': ' + a.toFixed(4)).join(', ').substring(0, 200));
            
            // Calcola totali EUR per ogni anno
            for (const year of years) {
                const yb = yearEndBalances[year] || {};
                let totalEur = 0;
                let coinsWithValue = [];
                
                for (const [coin, amount] of Object.entries(yb)) {
                    if (amount <= 0) continue;
                    const price = getHistoricalPrice(coin, year);
                    if (price > 0) {
                        const valueUsd = amount * price;
                        const valueEur = valueUsd * EUR_USD;
                        totalEur += valueEur;
                        if (valueEur > 10) { // Solo coin > ‚Ç¨10
                            coinsWithValue.push(coin + ': ‚Ç¨' + valueEur.toFixed(0));
                        }
                    }
                }
                
                yearEndTotals[year] = Math.round(totalEur * 100) / 100; // Arrotonda a 2 decimali
                if (coinsWithValue.length > 0) {
                    console.log('Year', year, '- Top coins:', coinsWithValue.slice(0, 10).join(', '));
                }
            }
            
            data.balances = yearEndBalances;
            data.totals = yearEndTotals;
            
            console.log('Year-end totals (EUR):', yearEndTotals);
        }
        
        function getHistoricalPrice(coin, year) {
            const coinUpper = coin.toUpperCase();
            
            // Usa i prezzi storici dalla YEAR_END_PRICES se disponibili
            const cgId = SYMBOL_TO_CG[coinUpper];
            if (cgId && YEAR_END_PRICES[cgId] && YEAR_END_PRICES[cgId][year]) {
                return YEAR_END_PRICES[cgId][year];
            }
            
            // Stablecoins - sempre $1
            if (['USDT', 'USDC', 'BUSD', 'FDUSD', 'DAI', 'UST', 'USTC', 'TUSD', 'USDP', 'GUSD', 'PAX', 'FRAX'].includes(coinUpper)) {
                return 1.0;
            }
            
            // EUR token
            if (coinUpper === 'EUR' || coinUpper === 'EUROC' || coinUpper === 'EURT') {
                return 1 / EUR_USD;
            }
            
            // BTC variations
            if (['BTC', 'WBTC', 'BTCB'].includes(coinUpper)) {
                return YEAR_END_PRICES['bitcoin']?.[year] || 50000;
            }
            
            // ETH variations
            if (['ETH', 'WETH', 'BETH', 'STETH'].includes(coinUpper)) {
                return YEAR_END_PRICES['ethereum']?.[year] || 2000;
            }
            
            // BNB variations  
            if (['BNB', 'WBNB'].includes(coinUpper)) {
                return YEAR_END_PRICES['binancecoin']?.[year] || 300;
            }
            
            // Monete molto piccole o sconosciute - log per debug
            // console.log('Unknown coin price:', coinUpper, 'year:', year);
            
            return 0;
        }
        
        function updateExchangeTotals() {
            const years = [2021, 2022, 2023, 2024, 2025];
            const totals = { 2021: 0, 2022: 0, 2023: 0, 2024: 0, 2025: 0 };
            
            for (const exchId of Object.keys(exchangeData)) {
                const data = exchangeData[exchId];
                if (data && data.totals) {
                    for (const y of years) {
                        totals[y] += data.totals[y] || 0;
                    }
                }
            }
            
            // Arrotonda a 2 decimali PRIMA di visualizzare
            for (const y of years) {
                totals[y] = Math.round(totals[y] * 100) / 100;
            }
            
            // Aggiorna UI
            for (const y of years) {
                const el = document.getElementById('exchTotal' + y);
                if (el) {
                    el.textContent = '‚Ç¨' + formatEUR(totals[y]);
                }
            }
            
            // Aggiorna exchangeValues per Tax Report
            exchangeValues = totals;
            
            // Aggiorna anche gli input nel Tax Report se visibili
            loadExchangeValuesUI();
        }
        
        function clearExchangeData(exchId) {
            if (!confirm('Cancellare i dati di ' + exchId.toUpperCase() + '?')) return;
            delete exchangeData[exchId];
            initExchangeGrid();
            updateExchangeTotals();
            saveExchangeDataToFirebase();
        }
        
        async function clearAllExchangeData() {
            if (!confirm('Cancellare TUTTI i dati degli exchange (inclusi dati API vecchi)?')) return;
            exchangeData = {};
            await resetAllBinanceLegacyData();
            initExchangeGrid();
            updateExchangeTotals();
            updateExchangeCount();
            saveExchangeDataToFirebase();
            alert('‚úÖ Tutti i dati exchange cancellati!');
        }
        
        function recalculateAllExchanges() {
            for (const exchId of Object.keys(exchangeData)) {
                calculateExchangeBalances(exchId);
            }
            initExchangeGrid();
            updateExchangeTotals();
            saveExchangeDataToFirebase();
            alert('‚úÖ Ricalcolo completato!');
        }
        
        async function saveExchangeDataToFirebase() {
            try {
                // Salva solo totali e balances, NON le transazioni (troppo grandi per Firebase)
                const dataToSave = {};
                for (const exchId of Object.keys(exchangeData)) {
                    const data = exchangeData[exchId];
                    dataToSave[exchId] = {
                        totals: data.totals || {},
                        balances: data.balances || {},
                        transactionCount: data.transactions ? data.transactions.length : 0,
                        lastImport: new Date().toISOString()
                    };
                }
                
                await db.collection('cryptofolio').doc('exchanges').set({
                    data: dataToSave,
                    lastUpdate: new Date().toISOString()
                });
                console.log('‚úÖ Exchange data saved to Firebase');
            } catch (e) {
                console.error('Exchange Firebase save error:', e);
            }
        }
        
        async function loadExchangeDataFromFirebase() {
            try {
                const doc = await db.collection('cryptofolio').doc('exchanges').get();
                if (doc.exists) {
                    const data = doc.data();
                    const savedData = data.data || {};
                    
                    // Carica solo totali e balances (le transazioni non sono salvate)
                    for (const exchId of Object.keys(savedData)) {
                        exchangeData[exchId] = {
                            transactions: [], // Vuoto - dovr√† reimportare
                            totals: savedData[exchId].totals || {},
                            balances: savedData[exchId].balances || {},
                            transactionCount: savedData[exchId].transactionCount || 0
                        };
                    }
                    
                    console.log('‚úÖ Exchange data loaded from Firebase:', Object.keys(exchangeData).length, 'exchanges');
                }
            } catch (e) {
                console.error('Exchange Firebase load error:', e);
            }
        }
        
        // ==================== LEGACY CLEANUP ====================
        async function cleanupLegacyBinanceData() {
            // Pulisce i vecchi dati API Binance da Firebase
            try {
                const doc = await db.collection('fiscal').doc('binance_live').get();
                if (doc.exists) {
                    await db.collection('fiscal').doc('binance_live').delete();
                    console.log('üßπ Cleaned up legacy Binance API data from Firebase');
                }
                // Reset local data
                binanceData = { balances: { spot: [], earn: [], staking: [] }, totals: { spot: 0, earn: 0, staking: 0 }, lastUpdate: null };
            } catch (e) {
                console.log('No legacy Binance data to clean');
            }
        }
        
        // Funzioni API Binance rimosse - usiamo solo CSV
        
        function updateExchangeCount() {
            // Conta exchange con dati CSV importati
            let count = 0;
            for (const exchId of Object.keys(exchangeData)) {
                if (exchangeData[exchId].transactions && exchangeData[exchId].transactions.length > 0) {
                    count++;
                }
            }
            document.getElementById('exchangeCount').textContent = count;
        }
        
        async function resetAllBinanceLegacyData() {
            // Resetta i vecchi dati API Binance in Firebase
            binanceData = { balances: { spot: [], earn: [], staking: [] }, totals: { spot: 0, earn: 0, staking: 0 }, lastUpdate: null };
            try {
                await db.collection('fiscal').doc('binance_live').delete();
                console.log('‚úÖ Binance legacy API data deleted');
            } catch(e) {
                console.log('No legacy binance data to delete');
            }
            updateExchangeCount();
        }
        
        // ==================== INIT ====================
        async function init() {
            loadSettings();
            await loadFromFirebase();
            await cleanupLegacyBinanceData(); // Pulisce vecchi dati API
            await loadExchangeDataFromFirebase();
            initChainSelector();
            initExchangeGrid();
            updateBlacklist();
            updateWalletsList();
            updateWalletSelect();
            updateApiCount();
            updateExchangeCount();
            updateExchangeTotals();
            
            // Mostra API key se configurata
            if (apiKeys.moralis && apiKeys.etherscan) {
                document.getElementById('apiKey').value = '‚úì Moralis + Etherscan';
            } else if (apiKeys.moralis) {
                document.getElementById('apiKey').value = '‚úì Moralis configurato';
            } else if (apiKeys.etherscan) {
                document.getElementById('apiKey').value = '‚úì Etherscan configurato';
            } else {
                document.getElementById('apiKey').value = '';
                document.getElementById('apiKey').placeholder = '‚ö†Ô∏è Configura API...';
            }
            
            // Mostra risultati salvati se presenti
            if (Object.keys(walletResults).length > 0) {
                aggregateAndDisplay();
                const lastScan = Object.values(walletResults).reduce((latest, w) => 
                    w.scannedAt > latest ? w.scannedAt : latest, 0);
                if (lastScan) {
                    document.getElementById('lastUpdate').textContent = 'Ultimo: ' + new Date(lastScan).toLocaleString('it-IT');
                }
                console.log('üìä Loaded', Object.keys(walletResults).length, 'wallet results from Firebase');
            }
            
            // Check Exchange CSV e aggiorna dashboard
            let exchangeTotalEUR = 0;
            let exchangeNames = [];
            for (const exchId of Object.keys(exchangeData)) {
                const data = exchangeData[exchId];
                if (data && data.totals) {
                    const latestYear = [2025, 2024, 2023, 2022, 2021].find(y => data.totals[y] > 0);
                    if (latestYear && data.totals[latestYear] > 0) {
                        exchangeTotalEUR += data.totals[latestYear];
                        const exchInfo = EXCHANGE_LIST.find(e => e.id === exchId);
                        if (exchInfo) exchangeNames.push(exchInfo.name);
                    }
                }
            }
            
            if (exchangeTotalEUR > 0) {
                document.getElementById('exchangeTotalEUR').textContent = '‚Ç¨' + exchangeTotalEUR.toLocaleString('it-IT', {maximumFractionDigits: 2});
                document.getElementById('exchangeNames').textContent = exchangeNames.join(', ') + ' ‚úì';
                console.log('üí∞ Exchanges loaded: ‚Ç¨' + exchangeTotalEUR.toFixed(2));
                
                // Se non ci sono wallet results, mostra comunque il totale Exchange nel portfolio
                if (Object.keys(walletResults).length === 0) {
                    document.getElementById('totalEUR').textContent = '‚Ç¨' + exchangeTotalEUR.toLocaleString('it-IT', {maximumFractionDigits: 2});
                    document.getElementById('totalUSD').textContent = '$' + (exchangeTotalEUR / EUR_USD).toLocaleString('it-IT', {maximumFractionDigits: 2}) + ' USD';
                }
            }
        }
        init();
    </script>
</body>
</html>
