<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CryptoFolio v4.0 - Full Persistent</title>
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <script>
        const firebaseConfig = {
            apiKey: "AIzaSyDAmtceQc0m-KQC7xGmu0IH1cR4tnI8oCQ",
            authDomain: "moreno-crypto-tools.firebaseapp.com",
            projectId: "moreno-crypto-tools",
            storageBucket: "moreno-crypto-tools.firebasestorage.app",
            messagingSenderId: "875997322481",
            appId: "1:875997322481:web:1a012bec2aff2cb5205d50"
        };
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();
    </script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --bg-primary: #0f0f1a;
            --bg-secondary: #1a1a2e;
            --bg-card: #16213e;
            --text-primary: #ffffff;
            --text-secondary: #a0a0a0;
            --accent: #6c5ce7;
            --accent-light: #a29bfe;
            --green: #00cec9;
            --red: #ff6b6b;
            --border: #2d2d44;
        }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: var(--bg-primary); color: var(--text-primary); min-height: 100vh; }
        .app-container { display: flex; min-height: 100vh; }
        .sidebar { width: 240px; background: var(--bg-secondary); padding: 20px; display: flex; flex-direction: column; border-right: 1px solid var(--border); }
        .logo { display: flex; align-items: center; gap: 12px; margin-bottom: 40px; }
        .logo-icon { width: 40px; height: 40px; background: linear-gradient(135deg, var(--accent), var(--accent-light)); border-radius: 10px; display: flex; align-items: center; justify-content: center; font-size: 20px; }
        .logo-text { font-size: 20px; font-weight: 700; }
        .nav-section { margin-bottom: 30px; }
        .nav-label { font-size: 11px; color: var(--text-secondary); margin-bottom: 12px; text-transform: uppercase; letter-spacing: 1px; }
        .nav-item { display: flex; align-items: center; gap: 12px; padding: 12px 16px; border-radius: 8px; cursor: pointer; transition: all 0.2s; margin-bottom: 4px; }
        .nav-item:hover { background: var(--bg-card); }
        .nav-item.active { background: var(--accent); }
        .nav-item .icon { font-size: 18px; }
        .nav-item .badge { margin-left: auto; background: var(--accent); padding: 2px 8px; border-radius: 10px; font-size: 11px; }
        .nav-item.active .badge { background: rgba(255,255,255,0.2); }
        .sidebar-footer { margin-top: auto; padding-top: 20px; border-top: 1px solid var(--border); }
        .version { font-size: 12px; color: var(--text-secondary); }
        .main-content { flex: 1; padding: 30px; overflow-y: auto; }
        .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 30px; }
        .header h1 { font-size: 28px; font-weight: 600; }
        .header-actions { display: flex; gap: 12px; align-items: center; }
        .btn { padding: 10px 20px; border-radius: 8px; border: none; cursor: pointer; font-size: 14px; font-weight: 500; transition: all 0.2s; }
        .btn-primary { background: var(--accent); color: white; }
        .btn-primary:hover { background: var(--accent-light); }
        .btn-secondary { background: var(--bg-card); color: var(--text-primary); border: 1px solid var(--border); }
        .stats-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px; margin-bottom: 30px; }
        .stat-card { background: var(--bg-card); padding: 24px; border-radius: 16px; border: 1px solid var(--border); }
        .stat-label { font-size: 13px; color: var(--text-secondary); margin-bottom: 8px; }
        .stat-value { font-size: 28px; font-weight: 700; color: var(--green); }
        .stat-change { font-size: 13px; margin-top: 4px; }
        .content-grid { display: grid; grid-template-columns: 2fr 1fr; gap: 20px; }
        .card { background: var(--bg-card); border-radius: 16px; padding: 24px; border: 1px solid var(--border); }
        .card-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
        .card-title { font-size: 18px; font-weight: 600; }
        .holdings-table { width: 100%; border-collapse: collapse; }
        .holdings-table th { text-align: left; padding: 12px 8px; color: var(--text-secondary); font-size: 12px; text-transform: uppercase; border-bottom: 1px solid var(--border); }
        .holdings-table td { padding: 16px 8px; border-bottom: 1px solid var(--border); }
        .holdings-table tr:hover { background: rgba(255,255,255,0.02); }
        .token-cell { display: flex; align-items: center; gap: 12px; }
        .token-icon { width: 36px; height: 36px; border-radius: 50%; background: var(--bg-secondary); display: flex; align-items: center; justify-content: center; font-weight: 600; font-size: 12px; overflow: hidden; }
        .token-icon img { width: 100%; height: 100%; object-fit: cover; }
        .token-info .symbol { font-weight: 600; }
        .token-info .name { font-size: 12px; color: var(--text-secondary); }
        .text-right { text-align: right; }
        .text-mono { font-family: 'SF Mono', Monaco, monospace; }
        .text-secondary { color: var(--text-secondary); }
        .wallet-input-section { background: var(--bg-card); padding: 20px; border-radius: 16px; margin-bottom: 20px; border: 1px solid var(--border); }
        .input-row { display: flex; gap: 16px; margin-bottom: 16px; }
        .input-group { flex: 1; }
        .input-group label { display: block; font-size: 12px; color: var(--text-secondary); margin-bottom: 8px; }
        .input-group input { width: 100%; padding: 12px; background: var(--bg-primary); border: 1px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 14px; }
        .input-group input:focus { outline: none; border-color: var(--accent); }
        .chain-selector { display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 16px; }
        .chain-btn { padding: 8px 14px; border-radius: 8px; border: 1px solid var(--border); background: var(--bg-primary); color: var(--text-secondary); cursor: pointer; font-size: 13px; transition: all 0.2s; display: flex; align-items: center; gap: 6px; }
        .chain-btn:hover { border-color: var(--accent); }
        .chain-btn.active { background: var(--accent); color: white; border-color: var(--accent); }
        .chain-dot { width: 8px; height: 8px; border-radius: 50%; }
        .status-log { background: var(--bg-primary); border-radius: 8px; padding: 12px; max-height: 150px; overflow-y: auto; font-family: 'SF Mono', Monaco, monospace; font-size: 12px; }
        .log-line { padding: 4px 0; }
        .log-line.success { color: var(--green); }
        .log-line.error { color: var(--red); }
        .log-line.info { color: var(--text-secondary); }
        .empty-state { text-align: center; padding: 40px; color: var(--text-secondary); }
        .empty-state .icon { font-size: 48px; margin-bottom: 16px; }
        .verify-link { display: inline-flex; align-items: center; gap: 6px; color: var(--accent-light); font-size: 13px; text-decoration: none; }
        .chain-badge { display: inline-block; font-size: 9px; padding: 2px 6px; border-radius: 4px; margin-left: 6px; font-weight: 600; text-transform: uppercase; }
        .blacklist-item { display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg-primary); border-radius: 8px; margin-bottom: 8px; }
        .btn-restore { background: var(--green); color: white; border: none; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 12px; }
        .hide-btn { background: transparent; border: none; color: var(--text-secondary); cursor: pointer; font-size: 10px; padding: 2px 6px; border-radius: 4px; margin-right: 8px; opacity: 0.5; }
        .hide-btn:hover { background: var(--red); color: white; opacity: 1; }
        .api-status { padding: 6px 12px; border-radius: 6px; font-size: 11px; font-weight: 600; }
        .api-status[id$="Status"] { background: var(--red); color: white; }
        .api-on { background: var(--green) !important; color: #000 !important; }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="sidebar">
            <div class="logo"><div class="logo-icon">üìä</div><span class="logo-text">CryptoFolio</span></div>
            <div class="nav-section">
                <div class="nav-label">Menu</div>
                <div class="nav-item active" onclick="showView('dashboard')"><span class="icon">üìà</span><span>Dashboard</span></div>
                <div class="nav-item" onclick="showView('wallets')"><span class="icon">üëõ</span><span>Wallets</span><span class="badge" id="walletCount">0</span></div>
                <div class="nav-item" onclick="showView('tax')"><span class="icon">üìã</span><span>Tax Report</span></div>
                <div class="nav-item" onclick="showView('api')"><span class="icon">üîå</span><span>API Connect</span><span class="badge" id="apiCount">0</span></div>
            </div>
            <div class="nav-section">
                <div class="nav-label">Settings</div>
                <div class="nav-item" onclick="toggleBlacklist()"><span class="icon">üö´</span><span>Token Nascosti</span><span class="badge" id="blacklistCount">0</span></div>
                <div class="nav-item" onclick="forceSyncFirebase()"><span class="icon">‚òÅÔ∏è</span><span>Force Sync</span></div>
                <div class="nav-item" onclick="clearWalletResults()"><span class="icon">üóëÔ∏è</span><span>Reset Scan</span></div>
            </div>
            <div class="sidebar-footer">
                <div style="display:flex;align-items:center;gap:8px;margin-bottom:8px;">
                    <span class="sync-dot" id="syncDot" style="width:8px;height:8px;border-radius:50%;background:var(--green);"></span>
                    <span id="syncStatus" style="font-size:11px;color:var(--text-secondary);">Connesso</span>
                </div>
                <div class="version">v4.0 - Full Persistent</div>
            </div>
        </div>
        
        <!-- DASHBOARD -->
        <div class="main-content" id="dashboardView">
            <div class="header"><h1>Dashboard</h1><div class="header-actions"><span id="lastUpdate" style="font-size:13px;color:var(--text-secondary);"></span><button class="btn btn-secondary" onclick="scanAllWallets()" style="margin-right:8px;">üìä Scan All</button><button class="btn btn-primary" onclick="scanWallet()">üîç Scan</button></div></div>
            
            <div class="wallet-input-section">
                <div class="input-row">
                    <div class="input-group" style="flex:2;">
                        <label>Wallet</label>
                        <div style="display:flex;gap:8px;">
                            <select id="walletSelect" onchange="onWalletSelect()" style="flex:1;padding:12px;background:var(--bg-primary);border:1px solid var(--border);border-radius:8px;color:var(--text-primary);font-size:14px;">
                                <option value="">-- Seleziona o inserisci --</option>
                            </select>
                            <input type="text" id="walletAddress" placeholder="0x... o seleziona sopra" autocomplete="off" style="flex:2;">
                        </div>
                    </div>
                    <div class="input-group"><label>API Key <a href="#" onclick="showView('api');return false;" style="color:var(--accent-light);font-size:11px;margin-left:8px;">‚Üí Configura in API Connect</a></label><input type="text" id="apiKey" placeholder="Configura in API Connect..." autocomplete="off" readonly onclick="showView('api')" style="cursor:pointer;"></div>
                </div>
                <label style="display:block;font-size:12px;color:var(--text-secondary);margin-bottom:8px;">Chains</label>
                <div class="chain-selector" id="chainSelector"></div>
                <div class="status-log" id="statusLog"><div class="log-line info">üëã Configura le API in <strong>API Connect</strong>, seleziona un wallet e clicca "Scan"</div></div>
            </div>
            
            <div class="stats-grid">
                <div class="stat-card"><div class="stat-label">üí∞ Portfolio Value</div><div class="stat-value" id="totalEUR">‚Ç¨0,00</div><div class="stat-change text-secondary" id="totalUSD">$0,00 USD</div></div>
                <div class="stat-card"><div class="stat-label">ü™ô Assets</div><div class="stat-value" id="tokenCount">0</div><div class="stat-change text-secondary">tokens</div></div>
                <div class="stat-card"><div class="stat-label">üëõ Wallets</div><div class="stat-value" id="scannedWallets">0</div><div class="stat-change text-secondary" id="chainNames">-</div></div>
                <div class="stat-card"><div class="stat-label">üí± EUR/USD</div><div class="stat-value" id="eurUsdRate">0.849</div><div class="stat-change text-secondary">rate</div></div>
            </div>
            
            <div class="content-grid">
                <div class="card"><div class="card-header"><div class="card-title">Holdings</div></div><div id="holdingsContent"><div class="empty-state"><div class="icon">üëõ</div><h3>Nessun dato</h3></div></div></div>
                <div class="card"><div class="card-header"><div class="card-title">Allocation</div></div><canvas id="allocationChart"></canvas></div>
            </div>
            
            <div class="card" id="blacklistPanel" style="display:none;margin-top:20px;"><div class="card-header"><div class="card-title">üö´ Token Nascosti</div><button class="btn btn-secondary" onclick="clearBlacklist()" style="font-size:12px;padding:6px 12px;">üóëÔ∏è Svuota</button></div><div id="blacklistContent"></div></div>
        </div>
        
        <!-- WALLETS -->
        <div class="main-content" id="walletsView" style="display:none;">
            <div class="header"><h1>üëõ Gestione Wallets</h1></div>
            
            <div class="card" style="margin-bottom:20px;">
                <div class="card-header"><div class="card-title">‚ûï Aggiungi Wallet</div></div>
                <div class="input-row">
                    <div class="input-group"><label>Nome (es. "Main", "Trading", "Cold")</label><input type="text" id="newWalletName" placeholder="Nome wallet..." autocomplete="off"></div>
                    <div class="input-group" style="flex:2;"><label>Indirizzo</label><input type="text" id="newWalletAddress" placeholder="0x..." autocomplete="off"></div>
                </div>
                <button class="btn btn-primary" onclick="addWallet()" style="margin-top:12px;">üíæ Salva Wallet</button>
            </div>
            
            <div class="card">
                <div class="card-header"><div class="card-title">üìã Wallets Salvati</div></div>
                <div id="walletsList"></div>
            </div>
        </div>
        
        <!-- WALLET DETAIL -->
        <div class="main-content" id="walletDetailView" style="display:none;">
            <div class="header">
                <div style="display:flex;align-items:center;gap:16px;">
                    <button class="btn btn-secondary" onclick="showView('wallets')" style="padding:8px 12px;">‚Üê Indietro</button>
                    <h1 id="detailWalletName">Wallet</h1>
                </div>
                <div class="header-actions">
                    <button class="btn btn-primary" onclick="scanDetailWallet()">üîç Scan</button>
                </div>
            </div>
            
            <div class="card" style="margin-bottom:20px;">
                <div style="display:flex;align-items:center;gap:16px;">
                    <div style="width:64px;height:64px;border-radius:16px;background:linear-gradient(135deg,var(--accent),var(--accent-light));display:flex;align-items:center;justify-content:center;font-size:28px;">üëõ</div>
                    <div>
                        <div style="font-size:13px;color:var(--text-secondary);">Indirizzo</div>
                        <div id="detailWalletAddress" style="font-family:monospace;font-size:14px;word-break:break-all;"></div>
                    </div>
                    <button class="btn btn-secondary" onclick="copyDetailAddress()" style="margin-left:auto;padding:8px 12px;">üìã Copia</button>
                </div>
            </div>
            
            <div class="stats-grid" style="grid-template-columns:repeat(3,1fr);">
                <div class="stat-card"><div class="stat-label">üí∞ Totale</div><div class="stat-value" id="detailTotal">‚Ç¨0,00</div></div>
                <div class="stat-card"><div class="stat-label">‚õìÔ∏è Chains</div><div class="stat-value" id="detailChainCount">0</div></div>
                <div class="stat-card"><div class="stat-label">ü™ô Token</div><div class="stat-value" id="detailTokenCount">0</div></div>
            </div>
            
            <div id="detailChainsContent"></div>
        </div>
        
        <!-- TAX REPORT -->
        <div class="main-content" id="taxView" style="display:none;">
            <div class="header"><h1>üìã Tax Report - Quadro RW</h1><div class="header-actions"><button class="btn btn-primary" onclick="calculateTaxReportAll()">üßÆ Calcola Tutti</button></div></div>
            
            <div class="card" style="margin-bottom:20px;">
                <p style="color:var(--text-secondary);font-size:14px;line-height:1.6;">
                    Il <strong>Quadro RW</strong> richiede il valore al <strong>31 dicembre</strong> di ogni anno fiscale. Soglia: <strong>‚Ç¨15.000</strong>.<br>
                    Calcola il valore aggregato di <strong>tutti i wallet salvati</strong>.
                </p>
                <div id="taxWalletsList" style="margin-top:12px;"></div>
            </div>
            
            <div class="card"><div class="card-header"><div class="card-title">üìä Totale Portfolio per Anno (31/12)</div></div><div id="taxReportContent"><div class="empty-state"><div class="icon">üëÜ</div><h3>Clicca "Calcola Tutti" per iniziare</h3></div></div></div>
            <div class="card" id="taxDetailCard" style="display:none;margin-top:20px;"><div class="card-header"><div class="card-title">üìù Dettaglio Token per Wallet</div></div><div id="taxDetailContent"></div></div>
        </div>
        
        <!-- API CONNECT -->
        <div class="main-content" id="apiView" style="display:none;">
            <div class="header"><h1>üîå API Connect</h1></div>
            
            <div class="card" style="margin-bottom:20px;">
                <p style="color:var(--text-secondary);font-size:14px;line-height:1.6;">
                    Configura le API per accedere ai dati blockchain. <strong>Moralis</strong> √® consigliato per scan veloci, <strong>Etherscan</strong> per il Tax Report storico.
                </p>
            </div>
            
            <!-- MORALIS -->
            <div class="card" style="margin-bottom:20px;">
                <div class="card-header">
                    <div class="card-title" style="display:flex;align-items:center;gap:12px;">
                        <span style="width:40px;height:40px;background:#21BF96;border-radius:10px;display:flex;align-items:center;justify-content:center;font-size:20px;">üü¢</span>
                        <div>
                            <div>Moralis</div>
                            <div style="font-size:12px;color:var(--text-secondary);font-weight:normal;">Scan veloce ‚Ä¢ Balance diretti ‚Ä¢ Multi-chain</div>
                        </div>
                    </div>
                    <span class="api-status" id="moralisStatus">OFF</span>
                </div>
                <div class="input-row" style="margin-top:16px;">
                    <div class="input-group" style="flex:3;">
                        <label>API Key <a href="https://admin.moralis.io/api-keys" target="_blank" style="color:var(--accent);font-size:11px;margin-left:8px;">‚Üí Ottieni gratis</a></label>
                        <input type="password" id="moralisKey" placeholder="eyJhbGci..." autocomplete="off">
                    </div>
                    <div class="input-group" style="flex:0;align-self:flex-end;">
                        <button class="btn btn-primary" onclick="saveMoralisKey()">üíæ Salva</button>
                    </div>
                </div>
                <div style="margin-top:12px;padding:12px;background:var(--bg-primary);border-radius:8px;font-size:12px;">
                    <strong>Chains supportate:</strong> Ethereum, BSC, Polygon, Arbitrum, Optimism, Base<br>
                    <strong>Limite free:</strong> 25 req/sec, 10.000/giorno
                </div>
            </div>
            
            <!-- ETHERSCAN -->
            <div class="card" style="margin-bottom:20px;">
                <div class="card-header">
                    <div class="card-title" style="display:flex;align-items:center;gap:12px;">
                        <span style="width:40px;height:40px;background:#21325B;border-radius:10px;display:flex;align-items:center;justify-content:center;font-size:20px;">üîµ</span>
                        <div>
                            <div>Etherscan</div>
                            <div style="font-size:12px;color:var(--text-secondary);font-weight:normal;">Tax Report ‚Ä¢ Storico transazioni ‚Ä¢ Multi-chain V2</div>
                        </div>
                    </div>
                    <span class="api-status" id="etherscanStatus">OFF</span>
                </div>
                <div class="input-row" style="margin-top:16px;">
                    <div class="input-group" style="flex:3;">
                        <label>API Key <a href="https://etherscan.io/myapikey" target="_blank" style="color:var(--accent);font-size:11px;margin-left:8px;">‚Üí Ottieni gratis</a></label>
                        <input type="password" id="etherscanKey" placeholder="ABCDEF..." autocomplete="off">
                    </div>
                    <div class="input-group" style="flex:0;align-self:flex-end;">
                        <button class="btn btn-primary" onclick="saveEtherscanKey()">üíæ Salva</button>
                    </div>
                </div>
                <div style="margin-top:12px;padding:12px;background:var(--bg-primary);border-radius:8px;font-size:12px;">
                    <strong>Chains supportate:</strong> Ethereum, BSC, Polygon, Arbitrum, Optimism, Base (API V2)<br>
                    <strong>Limite free:</strong> 5 req/sec, 100.000/giorno
                </div>
            </div>
            
            <!-- PULSESCAN -->
            <div class="card" style="margin-bottom:20px;">
                <div class="card-header">
                    <div class="card-title" style="display:flex;align-items:center;gap:12px;">
                        <span style="width:40px;height:40px;background:#00ff00;border-radius:10px;display:flex;align-items:center;justify-content:center;font-size:20px;">üíö</span>
                        <div>
                            <div>PulseChain</div>
                            <div style="font-size:12px;color:var(--text-secondary);font-weight:normal;">PulseScan API ‚Ä¢ Gratuito ‚Ä¢ No API key richiesta</div>
                        </div>
                    </div>
                    <span class="api-status" style="background:var(--green);color:#000;">AUTO</span>
                </div>
                <div style="margin-top:12px;padding:12px;background:var(--bg-primary);border-radius:8px;font-size:12px;">
                    <strong>Endpoint:</strong> api.scan.pulsechain.com<br>
                    <strong>Note:</strong> Nessuna configurazione necessaria, funziona automaticamente
                </div>
            </div>
            
            <!-- SOLANA -->
            <div class="card" style="margin-bottom:20px;">
                <div class="card-header">
                    <div class="card-title" style="display:flex;align-items:center;gap:12px;">
                        <span style="width:40px;height:40px;background:#9945ff;border-radius:10px;display:flex;align-items:center;justify-content:center;font-size:20px;">üü£</span>
                        <div>
                            <div>Solana</div>
                            <div style="font-size:12px;color:var(--text-secondary);font-weight:normal;">RPC Pubblico ‚Ä¢ Gratuito ‚Ä¢ Token SPL</div>
                        </div>
                    </div>
                    <span class="api-status" style="background:var(--green);color:#000;">AUTO</span>
                </div>
                <div style="margin-top:12px;padding:12px;background:var(--bg-primary);border-radius:8px;font-size:12px;">
                    <strong>Endpoint:</strong> api.mainnet-beta.solana.com<br>
                    <strong>Note:</strong> Usa RPC pubblico, potrebbe essere lento. Per performance migliori considera Helius o QuickNode.
                </div>
            </div>
            
            <!-- API STATUS SUMMARY -->
            <div class="card">
                <div class="card-header"><div class="card-title">üìä Riepilogo API</div></div>
                <div id="apiSummary" style="display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:12px;"></div>
            </div>
        </div>
    </div>

    <script>
        // ==================== CONFIG ====================
        let EUR_USD = 0.849;
        let allocationChart = null;
        let lastScanResults = [];
        let walletResults = {}; // { walletAddress: { name: 'Main', results: [...], scannedAt: timestamp } }
        
        const CHAINS = {
            eth: { id: 1, name: 'Ethereum', symbol: 'ETH', explorer: 'etherscan.io', color: '#627eea', dex: 'ethereum', api: 'etherscan' },
            bsc: { id: 56, name: 'BSC', symbol: 'BNB', explorer: 'bscscan.com', color: '#f3ba2f', dex: 'bsc', api: 'etherscan' },
            polygon: { id: 137, name: 'Polygon', symbol: 'MATIC', explorer: 'polygonscan.com', color: '#8247e5', dex: 'polygon', api: 'etherscan' },
            arbitrum: { id: 42161, name: 'Arbitrum', symbol: 'ETH', explorer: 'arbiscan.io', color: '#28a0f0', dex: 'arbitrum', api: 'etherscan' },
            optimism: { id: 10, name: 'Optimism', symbol: 'ETH', explorer: 'optimistic.etherscan.io', color: '#ff0420', dex: 'optimism', api: 'etherscan' },
            base: { id: 8453, name: 'Base', symbol: 'ETH', explorer: 'basescan.org', color: '#0052ff', dex: 'base', api: 'etherscan' },
            pulse: { id: 369, name: 'PulseChain', symbol: 'PLS', explorer: 'scan.pulsechain.com', color: '#00ff00', dex: 'pulsechain', api: 'pulsescan' },
            solana: { id: 0, name: 'Solana', symbol: 'SOL', explorer: 'solscan.io', color: '#9945ff', dex: 'solana', api: 'solana' },
        };
        
        const NATIVE_PRICES = { ETH: 0, BNB: 0, MATIC: 0, PLS: 0, SOL: 0 };
        
        const TOKEN_ICONS = {
            'ETH': 'https://assets.coingecko.com/coins/images/279/small/ethereum.png',
            'BNB': 'https://assets.coingecko.com/coins/images/825/small/bnb-icon2_2x.png',
            'MATIC': 'https://assets.coingecko.com/coins/images/4713/small/matic-token-icon.png',
            'SHIB': 'https://assets.coingecko.com/coins/images/11939/small/shiba.png',
            'BONE': 'https://assets.coingecko.com/coins/images/16916/small/bone_icon.png',
            'USDT': 'https://assets.coingecko.com/coins/images/325/small/tether.png',
            'USDC': 'https://assets.coingecko.com/coins/images/6319/small/usdc.png',
            'PLS': 'https://tokens.app.pulsex.com/images/tokens/0xA1077a294dDE1B09bB078844df40758a5D0f9a27.png',
            'SOL': 'https://assets.coingecko.com/coins/images/4128/small/solana.png',
            'HEX': 'https://tokens.app.pulsex.com/images/tokens/0x2b591e99afE9f32eAA6214f7B7629768c40Eeb39.png',
            'PLSX': 'https://tokens.app.pulsex.com/images/tokens/0x95B303987A60C71504D99Aa1b13B4DA07b0790ab.png',
            'INC': 'https://tokens.app.pulsex.com/images/tokens/0x2fa878Ab3F87CC1C9737Fc071108F904c0B0C95d.png',
            'DAI': 'https://assets.coingecko.com/coins/images/9956/small/dai-multi-collateral-mcd.png',
            'WETH': 'https://assets.coingecko.com/coins/images/2518/small/weth.png',
        };
        
        const HISTORICAL_PRICES = {
            'ethereum': { 2020: 737, 2021: 3769, 2022: 1196, 2023: 2282, 2024: 3337, 2025: 2950 },
            'shiba-inu': { 2020: 0, 2021: 0.0000338, 2022: 0.0000081, 2023: 0.0000091, 2024: 0.0000218, 2025: 0.000008 },
            'bone-shibaswap': { 2020: 0, 2021: 1.71, 2022: 0.93, 2023: 0.47, 2024: 0.42, 2025: 0.08 },
            'binancecoin': { 2020: 37, 2021: 526, 2022: 244, 2023: 311, 2024: 707, 2025: 680 },
            'matic-network': { 2020: 0.02, 2021: 2.47, 2022: 0.75, 2023: 0.99, 2024: 0.46, 2025: 0.35 },
            'pulsechain': { 2020: 0, 2021: 0, 2022: 0, 2023: 0.00005, 2024: 0.00003, 2025: 0.000014 },
            'hex': { 2020: 0.001, 2021: 0.15, 2022: 0.04, 2023: 0.006, 2024: 0.004, 2025: 0.003 },
            'pulsex': { 2020: 0, 2021: 0, 2022: 0, 2023: 0.0001, 2024: 0.00005, 2025: 0.00001 },
            'tether': { 2020: 1, 2021: 1, 2022: 1, 2023: 1, 2024: 1, 2025: 1 },
            'usd-coin': { 2020: 1, 2021: 1, 2022: 1, 2023: 1, 2024: 1, 2025: 1 },
            'solana': { 2020: 1.5, 2021: 170, 2022: 9.5, 2023: 100, 2024: 190, 2025: 150 },
        };
        
        const SYMBOL_TO_CG = { 
            'ETH': 'ethereum', 'BNB': 'binancecoin', 'MATIC': 'matic-network', 
            'SHIB': 'shiba-inu', 'BONE': 'bone-shibaswap', 
            'USDT': 'tether', 'USDC': 'usd-coin',
            'PLS': 'pulsechain', 'HEX': 'hex', 'PLSX': 'pulsex',
            'SOL': 'solana'
        };
        
        let tokenBlacklist = JSON.parse(localStorage.getItem('cryptofolio_blacklist') || '[]');
        let blacklistNames = JSON.parse(localStorage.getItem('cryptofolio_blacklist_names') || '{}');
        let selectedChains = JSON.parse(localStorage.getItem('cryptofolio_chains') || '["eth","bsc"]');
        let savedWallets = JSON.parse(localStorage.getItem('cryptofolio_wallets') || '[]');
        let apiKeys = JSON.parse(localStorage.getItem('cryptofolio_apikeys') || '{}');
        let taxReportData = null; // Cached tax report results
        let saveTimeout = null;
        
        // Moralis chain mapping
        const MORALIS_CHAINS = {
            eth: '0x1',
            bsc: '0x38',
            polygon: '0x89',
            arbitrum: '0xa4b1',
            optimism: '0xa',
            base: '0x2105'
        };
        
        // ==================== FIREBASE ====================
        function updateSyncStatus(status, color) {
            document.getElementById('syncStatus').textContent = status;
            document.getElementById('syncDot').style.background = color || 'var(--green)';
        }
        
        function saveToFirebase() {
            if (saveTimeout) clearTimeout(saveTimeout);
            saveTimeout = setTimeout(async () => {
                try {
                    updateSyncStatus('Salvataggio...', 'var(--accent)');
                    await db.collection('cryptofolio').doc('settings').set({
                        wallets: savedWallets,
                        blacklist: tokenBlacklist,
                        blacklistNames: blacklistNames,
                        selectedChains: selectedChains,
                        apiKeys: apiKeys,
                        walletResults: walletResults,
                        taxReportData: taxReportData,
                        lastUpdate: new Date().toISOString()
                    });
                    updateSyncStatus('Salvato ‚úì', 'var(--green)');
                    console.log('‚úÖ Firebase saved');
                } catch (e) {
                    updateSyncStatus('Errore sync', 'var(--red)');
                    console.error('Firebase save error:', e);
                }
            }, 1500);
        }
        
        async function loadFromFirebase() {
            try {
                updateSyncStatus('Caricamento...', 'var(--accent)');
                const doc = await db.collection('cryptofolio').doc('settings').get();
                
                if (doc.exists) {
                    const data = doc.data();
                    savedWallets = data.wallets || [];
                    tokenBlacklist = data.blacklist || [];
                    blacklistNames = data.blacklistNames || {};
                    selectedChains = data.selectedChains || ['eth', 'bsc'];
                    apiKeys = data.apiKeys || {};
                    walletResults = data.walletResults || {};
                    taxReportData = data.taxReportData || null;
                    
                    // Sync to localStorage
                    localStorage.setItem('cryptofolio_wallets', JSON.stringify(savedWallets));
                    localStorage.setItem('cryptofolio_blacklist', JSON.stringify(tokenBlacklist));
                    localStorage.setItem('cryptofolio_blacklist_names', JSON.stringify(blacklistNames));
                    localStorage.setItem('cryptofolio_chains', JSON.stringify(selectedChains));
                    localStorage.setItem('cryptofolio_apikeys', JSON.stringify(apiKeys));
                    
                    // Backward compatibility: load old apiKey into new structure
                    if (data.apiKey && !apiKeys.etherscan) {
                        apiKeys.etherscan = data.apiKey;
                        localStorage.setItem('cryptofolio_apikeys', JSON.stringify(apiKeys));
                    }
                    
                    // Update UI fields
                    if (apiKeys.etherscan) {
                        document.getElementById('apiKey').value = apiKeys.etherscan;
                    }
                    
                    console.log('‚úÖ Firebase loaded:', savedWallets.length, 'wallets,', Object.keys(walletResults).length, 'scan results', taxReportData ? ', tax report cached' : '');
                }
                
                updateSyncStatus('Connesso ‚úì', 'var(--green)');
            } catch (e) {
                updateSyncStatus('Offline', 'var(--red)');
                console.error('Firebase load error:', e);
            }
        }
        
        async function forceSyncFirebase() {
            if (saveTimeout) clearTimeout(saveTimeout);
            try {
                updateSyncStatus('Sync...', 'var(--accent)');
                await db.collection('cryptofolio').doc('settings').set({
                    wallets: savedWallets,
                    blacklist: tokenBlacklist,
                    blacklistNames: blacklistNames,
                    selectedChains: selectedChains,
                    apiKeys: apiKeys,
                    walletResults: walletResults,
                    taxReportData: taxReportData,
                    lastUpdate: new Date().toISOString()
                });
                updateSyncStatus('Salvato ‚úì', 'var(--green)');
                alert('‚úÖ Dati sincronizzati con Firebase!');
            } catch (e) {
                updateSyncStatus('Errore', 'var(--red)');
                alert('‚ùå Errore sync: ' + e.message);
            }
        }
        
        // ==================== UTILS ====================
        function log(msg, type = '') { 
            const el = document.getElementById('statusLog'); 
            el.innerHTML += `<div class="log-line ${type}">[${new Date().toLocaleTimeString('it-IT')}] ${msg}</div>`; 
            el.scrollTop = el.scrollHeight; 
        }
        function formatNum(n, d = 2) { 
            if (n >= 1e9) return (n/1e9).toFixed(2)+'B'; 
            if (n >= 1e6) return (n/1e6).toFixed(2)+'M'; 
            if (n < 0.0001 && n > 0) return n.toExponential(2); 
            return n.toLocaleString('en-US', {minimumFractionDigits: d, maximumFractionDigits: d}); 
        }
        function formatEUR(n) { return n.toLocaleString('it-IT', {minimumFractionDigits: 2, maximumFractionDigits: 2}); }
        function isSpam(name, sym) { 
            const n = (name||'').toLowerCase(), s = (sym||'').toLowerCase(); 
            const spam = ['visit', 'claim', 'reward', '.com', '.org', '.io', '.xyz', 'airdrop', 'bonus', 'free', 'gift', 'http', '$', '#']; 
            for (const p of spam) if (n.includes(p) || s.includes(p)) return true; 
            return (name||'').length > 40; 
        }
        function isBlacklisted(c) { return tokenBlacklist.includes(c.toLowerCase()); }
        function hideToken(c, s) { 
            const lc = c.toLowerCase(); 
            if (!tokenBlacklist.includes(lc)) { 
                tokenBlacklist.push(lc); 
                blacklistNames[lc] = s; 
                localStorage.setItem('cryptofolio_blacklist', JSON.stringify(tokenBlacklist)); 
                localStorage.setItem('cryptofolio_blacklist_names', JSON.stringify(blacklistNames)); 
            }
            updateBlacklist(); 
            displayResults(lastScanResults);
            saveToFirebase();
        }
        function restoreToken(c) { 
            tokenBlacklist = tokenBlacklist.filter(x => x !== c.toLowerCase()); 
            delete blacklistNames[c.toLowerCase()]; 
            localStorage.setItem('cryptofolio_blacklist', JSON.stringify(tokenBlacklist)); 
            localStorage.setItem('cryptofolio_blacklist_names', JSON.stringify(blacklistNames)); 
            updateBlacklist(); 
            displayResults(lastScanResults);
            saveToFirebase();
        }
        function clearBlacklist() { 
            tokenBlacklist = []; blacklistNames = {}; 
            localStorage.removeItem('cryptofolio_blacklist'); 
            localStorage.removeItem('cryptofolio_blacklist_names'); 
            updateBlacklist(); 
            displayResults(lastScanResults);
            saveToFirebase();
        }
        function toggleBlacklist() { 
            const p = document.getElementById('blacklistPanel'); 
            p.style.display = p.style.display === 'none' ? 'block' : 'none'; 
        }
        function updateBlacklist() { 
            document.getElementById('blacklistCount').textContent = tokenBlacklist.length; 
            const c = document.getElementById('blacklistContent'); 
            if (tokenBlacklist.length === 0) { c.innerHTML = '<p style="color:var(--text-secondary);">Nessun token nascosto</p>'; return; } 
            let h = ''; 
            for (const x of tokenBlacklist) { 
                h += `<div class="blacklist-item"><span>${blacklistNames[x]||x.slice(0,10)}</span><button class="btn-restore" onclick="restoreToken('${x}')">‚Ü©Ô∏è</button></div>`; 
            } 
            c.innerHTML = h; 
        }
        
        // ==================== UI ====================
        let currentDetailWallet = null;
        
        function showView(view) {
            document.getElementById('dashboardView').style.display = view === 'dashboard' ? 'block' : 'none';
            document.getElementById('walletsView').style.display = view === 'wallets' ? 'block' : 'none';
            document.getElementById('walletDetailView').style.display = view === 'walletDetail' ? 'block' : 'none';
            document.getElementById('taxView').style.display = view === 'tax' ? 'block' : 'none';
            document.getElementById('apiView').style.display = view === 'api' ? 'block' : 'none';
            document.querySelectorAll('.nav-item').forEach((e, i) => {
                e.classList.toggle('active', 
                    (view === 'dashboard' && i === 0) || 
                    (view === 'wallets' && i === 1) || 
                    (view === 'walletDetail' && i === 1) || 
                    (view === 'tax' && i === 2) ||
                    (view === 'api' && i === 3)
                );
            });
            
            // Aggiorna dropdown tax e mostra dati salvati
            if (view === 'tax') {
                updateTaxWalletsList();
                if (taxReportData) {
                    renderTaxReport(taxReportData);
                }
            }
            
            // Aggiorna status API quando si apre
            if (view === 'api') {
                updateApiStatus();
            }
        }
        
        function renderTaxReport(data) {
            const container = document.getElementById('taxReportContent');
            const detailCard = document.getElementById('taxDetailCard');
            const detailContent = document.getElementById('taxDetailContent');
            const years = [2021, 2022, 2023, 2024, 2025];
            
            // Render summary table
            let html = '<table class="holdings-table"><thead><tr><th>Anno</th><th class="text-right">Valore 31/12 (EUR)</th><th class="text-right">USD</th><th class="text-right">Quadro RW?</th></tr></thead><tbody>';
            for (const y of years) {
                const t = data.grandTotals[y];
                const above = t.eur >= 15000;
                html += `<tr>
                    <td><strong>${y}</strong></td>
                    <td class="text-right text-mono" style="color:var(--green);font-size:18px;font-weight:600;">‚Ç¨${formatEUR(t.eur)}</td>
                    <td class="text-right text-mono text-secondary">$${formatEUR(t.usd)}</td>
                    <td class="text-right">${above ? '<span style="color:var(--red);font-weight:600;">‚ö†Ô∏è S√å - Obbligo</span>' : '<span style="color:var(--green);">‚úì NO</span>'}</td>
                </tr>`;
            }
            html += '</tbody></table>';
            html += `<p style="margin-top:16px;font-size:12px;color:var(--text-secondary);">üìä Aggregato da ${data.walletCount} wallet | ‚õìÔ∏è ${data.chainNames} | ‚ö†Ô∏è Soglia RW: ‚Ç¨15.000</p>`;
            html += `<p style="font-size:11px;color:var(--text-secondary);">üìÖ Calcolato il ${new Date(data.calculatedAt).toLocaleString('it-IT')}</p>`;
            container.innerHTML = html;
            
            // Render detail per wallet
            let dh = '';
            for (const wd of data.walletDetails) {
                dh += `<div style="margin-bottom:24px;padding:16px;background:var(--bg-primary);border-radius:12px;">`;
                dh += `<h3 style="margin-bottom:12px;display:flex;align-items:center;gap:10px;">üëõ ${wd.walletName} <span style="font-size:12px;color:var(--text-secondary);font-weight:normal;">${wd.walletAddress}</span></h3>`;
                dh += `<table style="width:100%;border-collapse:collapse;font-size:13px;"><thead><tr style="border-bottom:1px solid var(--border);"><th style="text-align:left;padding:8px;">Token</th>`;
                for (const y of years) dh += `<th style="text-align:center;padding:8px;">${y}</th>`;
                dh += '</tr></thead><tbody>';
                
                // Token rows
                for (const row of wd.rows) {
                    dh += `<tr style="border-bottom:1px solid var(--border);"><td style="padding:8px;"><strong>${row.tokenKey}</strong></td>`;
                    for (const y of years) {
                        const cell = row.cells[y];
                        if (cell && cell.hasValue) {
                            dh += `<td style="text-align:center;padding:8px;"><span style="color:var(--green);">‚Ç¨${formatEUR(cell.eur)}</span><br><span style="font-size:10px;color:var(--text-secondary);">${formatNum(cell.balance, 2)}</span></td>`;
                        } else if (cell && cell.balance > 0) {
                            dh += `<td style="text-align:center;padding:8px;"><span style="color:var(--text-secondary);">${formatNum(cell.balance, 2)}</span><br><span style="font-size:10px;color:var(--red);">no price</span></td>`;
                        } else {
                            dh += '<td style="text-align:center;padding:8px;color:var(--text-secondary);">-</td>';
                        }
                    }
                    dh += '</tr>';
                }
                
                // Wallet total row
                dh += '<tr style="background:var(--bg-secondary);"><td style="padding:10px;font-weight:600;">TOTALE</td>';
                for (const y of years) {
                    dh += `<td style="text-align:center;padding:10px;font-weight:600;color:var(--green);">‚Ç¨${formatEUR(wd.totals[y].eur)}</td>`;
                }
                dh += '</tr>';
                
                dh += '</tbody></table></div>';
            }
            
            detailContent.innerHTML = dh;
            detailCard.style.display = 'block';
        }
        
        function updateTaxWalletsList() {
            const container = document.getElementById('taxWalletsList');
            if (!container) return;
            
            if (savedWallets.length === 0) {
                container.innerHTML = '<p style="color:var(--red);">‚ö†Ô∏è Nessun wallet salvato. Vai su <strong>Wallets</strong> per aggiungerne.</p>';
                document.getElementById('taxReportContent').innerHTML = '<div class="empty-state"><div class="icon">üëõ</div><h3>Aggiungi wallet prima</h3></div>';
                return;
            }
            
            let html = '<div style="display:flex;flex-wrap:wrap;gap:8px;">';
            savedWallets.forEach(w => {
                const shortAddr = w.address.slice(0, 6) + '...' + w.address.slice(-4);
                html += `<span style="background:var(--bg-primary);padding:6px 12px;border-radius:8px;font-size:13px;">üëõ ${w.name} <span style="color:var(--text-secondary);">(${shortAddr})</span></span>`;
            });
            html += '</div>';
            container.innerHTML = html;
        }
        
        // ==================== API MANAGEMENT ====================
        function saveMoralisKey() {
            const key = document.getElementById('moralisKey').value.trim();
            if (!key) {
                alert('Inserisci una API key valida');
                return;
            }
            apiKeys.moralis = key;
            localStorage.setItem('cryptofolio_apikeys', JSON.stringify(apiKeys));
            saveToFirebase();
            updateApiStatus();
            alert('‚úÖ Moralis API key salvata!');
        }
        
        function saveEtherscanKey() {
            const key = document.getElementById('etherscanKey').value.trim();
            if (!key) {
                alert('Inserisci una API key valida');
                return;
            }
            apiKeys.etherscan = key;
            // Also update the old apiKey field for backward compatibility
            document.getElementById('apiKey').value = key;
            localStorage.setItem('cryptofolio_apikeys', JSON.stringify(apiKeys));
            saveToFirebase();
            updateApiStatus();
            alert('‚úÖ Etherscan API key salvata!');
        }
        
        function updateApiStatus() {
            // Update status badges
            const moralisStatus = document.getElementById('moralisStatus');
            const etherscanStatus = document.getElementById('etherscanStatus');
            
            if (moralisStatus) {
                if (apiKeys.moralis) {
                    moralisStatus.textContent = 'ON';
                    moralisStatus.classList.add('api-on');
                } else {
                    moralisStatus.textContent = 'OFF';
                    moralisStatus.classList.remove('api-on');
                }
            }
            
            if (etherscanStatus) {
                if (apiKeys.etherscan) {
                    etherscanStatus.textContent = 'ON';
                    etherscanStatus.classList.add('api-on');
                } else {
                    etherscanStatus.textContent = 'OFF';
                    etherscanStatus.classList.remove('api-on');
                }
            }
            
            // Fill input fields
            if (document.getElementById('moralisKey') && apiKeys.moralis) {
                document.getElementById('moralisKey').value = apiKeys.moralis;
            }
            if (document.getElementById('etherscanKey') && apiKeys.etherscan) {
                document.getElementById('etherscanKey').value = apiKeys.etherscan;
            }
            
            // Update API count badge
            updateApiCount();
            
            // Update summary
            const summary = document.getElementById('apiSummary');
            if (summary) {
                let html = '';
                
                // Moralis
                html += `<div style="padding:16px;background:var(--bg-primary);border-radius:10px;text-align:center;">
                    <div style="font-size:24px;margin-bottom:8px;">üü¢</div>
                    <div style="font-weight:600;">Moralis</div>
                    <div style="font-size:12px;color:${apiKeys.moralis ? 'var(--green)' : 'var(--red)'};">${apiKeys.moralis ? '‚úì Configurato' : '‚úó Non configurato'}</div>
                </div>`;
                
                // Etherscan
                html += `<div style="padding:16px;background:var(--bg-primary);border-radius:10px;text-align:center;">
                    <div style="font-size:24px;margin-bottom:8px;">üîµ</div>
                    <div style="font-weight:600;">Etherscan</div>
                    <div style="font-size:12px;color:${apiKeys.etherscan ? 'var(--green)' : 'var(--red)'};">${apiKeys.etherscan ? '‚úì Configurato' : '‚úó Non configurato'}</div>
                </div>`;
                
                // PulseChain
                html += `<div style="padding:16px;background:var(--bg-primary);border-radius:10px;text-align:center;">
                    <div style="font-size:24px;margin-bottom:8px;">üíö</div>
                    <div style="font-weight:600;">PulseChain</div>
                    <div style="font-size:12px;color:var(--green);">‚úì Auto</div>
                </div>`;
                
                // Solana
                html += `<div style="padding:16px;background:var(--bg-primary);border-radius:10px;text-align:center;">
                    <div style="font-size:24px;margin-bottom:8px;">üü£</div>
                    <div style="font-weight:600;">Solana</div>
                    <div style="font-size:12px;color:var(--green);">‚úì Auto</div>
                </div>`;
                
                summary.innerHTML = html;
            }
        }
        
        function updateApiCount() {
            let count = 2; // PulseChain + Solana sempre attive
            if (apiKeys.moralis) count++;
            if (apiKeys.etherscan) count++;
            document.getElementById('apiCount').textContent = count;
        }
        
        // ==================== MORALIS API ====================
        async function fetchWithMoralis(addr, chainKey) {
            if (!apiKeys.moralis || !MORALIS_CHAINS[chainKey]) return null;
            
            try {
                const chain = MORALIS_CHAINS[chainKey];
                
                // Get native balance
                const nativeRes = await fetch(`https://deep-index.moralis.io/api/v2.2/${addr}/balance?chain=${chain}`, {
                    headers: { 'X-API-Key': apiKeys.moralis }
                });
                const nativeData = await nativeRes.json();
                
                // Get token balances
                const tokenRes = await fetch(`https://deep-index.moralis.io/api/v2.2/${addr}/erc20?chain=${chain}`, {
                    headers: { 'X-API-Key': apiKeys.moralis }
                });
                const tokenData = await tokenRes.json();
                
                return {
                    nativeBalance: nativeData.balance || '0',
                    tokens: tokenData || []
                };
            } catch (e) {
                console.error('Moralis error:', e);
                return null;
            }
        }
        
        async function scanWithMoralis(addr, chainKey) {
            const chainInfo = CHAINS[chainKey];
            const moralisData = await fetchWithMoralis(addr, chainKey);
            
            if (!moralisData) return [];
            
            const results = [];
            
            // Native balance
            const nativeBal = Number(BigInt(moralisData.nativeBalance)) / 1e18;
            const nativePrice = NATIVE_PRICES[chainInfo.symbol] || NATIVE_PRICES.ETH;
            
            if (nativeBal > 0.0001) {
                results.push({
                    symbol: chainInfo.symbol,
                    name: `${chainInfo.symbol} (${chainInfo.name})`,
                    balance: nativeBal,
                    price: nativePrice,
                    valueUSD: nativeBal * nativePrice,
                    contract: `native-${chainKey}`,
                    logo: TOKEN_ICONS[chainInfo.symbol],
                    chain: chainKey
                });
            }
            
            // Token balances
            for (const token of moralisData.tokens) {
                if (isBlacklisted(token.token_address) || isSpam(token.name, token.symbol)) continue;
                
                const bal = Number(BigInt(token.balance)) / Math.pow(10, token.decimals || 18);
                if (bal <= 0) continue;
                
                let price = 0, logo = TOKEN_ICONS[token.symbol?.toUpperCase()] || token.logo || null;
                
                // Get price from DexScreener
                const pd = await fetchTokenPrice(token.token_address, chainInfo.dex);
                if (pd) { price = pd.price; if (pd.logo) logo = pd.logo; }
                
                results.push({
                    symbol: token.symbol,
                    name: token.name,
                    balance: bal,
                    price,
                    valueUSD: bal * price,
                    contract: token.token_address.toLowerCase(),
                    logo,
                    chain: chainKey
                });
            }
            
            return results;
        }
        
        // ==================== WALLET MANAGEMENT ====================
        function addWallet() {
            const name = document.getElementById('newWalletName').value.trim();
            const address = document.getElementById('newWalletAddress').value.trim();
            
            if (!name) { alert('Inserisci un nome per il wallet'); return; }
            if (!address || !address.startsWith('0x') || address.length !== 42) { 
                alert('Indirizzo wallet non valido (deve iniziare con 0x e avere 42 caratteri)'); 
                return; 
            }
            
            // Check duplicate
            if (savedWallets.some(w => w.address.toLowerCase() === address.toLowerCase())) {
                alert('Questo wallet √® gi√† salvato');
                return;
            }
            
            savedWallets.push({ name, address, addedAt: Date.now() });
            localStorage.setItem('cryptofolio_wallets', JSON.stringify(savedWallets));
            
            document.getElementById('newWalletName').value = '';
            document.getElementById('newWalletAddress').value = '';
            
            updateWalletsList();
            updateWalletSelect();
            saveToFirebase();
            log(`‚úÖ Wallet "${name}" aggiunto`, 'success');
        }
        
        function removeWallet(index) {
            if (confirm(`Rimuovere wallet "${savedWallets[index].name}"?`)) {
                savedWallets.splice(index, 1);
                localStorage.setItem('cryptofolio_wallets', JSON.stringify(savedWallets));
                updateWalletsList();
                updateWalletSelect();
                saveToFirebase();
            }
        }
        
        function selectWallet(index) {
            const wallet = savedWallets[index];
            document.getElementById('walletAddress').value = wallet.address;
            document.getElementById('walletSelect').value = index;
            showView('dashboard');
            log(`üëõ Wallet "${wallet.name}" selezionato`, 'info');
        }
        
        function onWalletSelect() {
            const select = document.getElementById('walletSelect');
            const idx = select.value;
            if (idx !== '' && savedWallets[idx]) {
                document.getElementById('walletAddress').value = savedWallets[idx].address;
            }
        }
        
        function updateWalletsList() {
            const container = document.getElementById('walletsList');
            document.getElementById('walletCount').textContent = savedWallets.length;
            
            if (savedWallets.length === 0) {
                container.innerHTML = '<p style="color:var(--text-secondary);padding:20px;text-align:center;">Nessun wallet salvato.<br>Aggiungi il tuo primo wallet sopra!</p>';
                return;
            }
            
            let html = '';
            savedWallets.forEach((w, i) => {
                const shortAddr = w.address.slice(0, 8) + '...' + w.address.slice(-6);
                // Calcola totale se scannerizzato
                const walletData = walletResults[w.address.toLowerCase()];
                const total = walletData ? walletData.results.reduce((s, t) => s + t.valueUSD, 0) * EUR_USD : 0;
                const totalStr = walletData ? `‚Ç¨${formatEUR(total)}` : '<span style="color:var(--text-secondary);">Non scansionato</span>';
                
                html += `
                    <div style="display:flex;align-items:center;justify-content:space-between;padding:16px;background:var(--bg-primary);border-radius:12px;margin-bottom:12px;">
                        <div style="display:flex;align-items:center;gap:16px;cursor:pointer;flex:1;" onclick="openWalletDetail(${i})">
                            <div style="width:48px;height:48px;border-radius:12px;background:linear-gradient(135deg,var(--accent),var(--accent-light));display:flex;align-items:center;justify-content:center;font-size:20px;">üëõ</div>
                            <div>
                                <div style="font-weight:600;font-size:16px;">${w.name}</div>
                                <div style="font-size:13px;color:var(--text-secondary);font-family:monospace;">${shortAddr}</div>
                            </div>
                            <div style="margin-left:auto;text-align:right;">
                                <div style="font-weight:600;color:var(--green);">${totalStr}</div>
                            </div>
                        </div>
                        <div style="display:flex;gap:8px;margin-left:16px;">
                            <button class="btn btn-primary" onclick="selectWallet(${i})" style="padding:8px 16px;">üìä Scan</button>
                            <button class="btn btn-secondary" onclick="navigator.clipboard.writeText('${w.address}')" style="padding:8px 12px;">üìã</button>
                            <button class="btn btn-secondary" onclick="removeWallet(${i})" style="padding:8px 12px;color:var(--red);">üóëÔ∏è</button>
                        </div>
                    </div>
                `;
            });
            container.innerHTML = html;
        }
        
        function updateWalletSelect() {
            const select = document.getElementById('walletSelect');
            let html = '<option value="">-- Seleziona wallet salvato --</option>';
            savedWallets.forEach((w, i) => {
                const shortAddr = w.address.slice(0, 6) + '...' + w.address.slice(-4);
                html += `<option value="${i}">${w.name} (${shortAddr})</option>`;
            });
            select.innerHTML = html;
        }
        
        // ==================== WALLET DETAIL ====================
        function openWalletDetail(index) {
            const wallet = savedWallets[index];
            if (!wallet) return;
            
            currentDetailWallet = wallet;
            document.getElementById('detailWalletName').textContent = wallet.name;
            document.getElementById('detailWalletAddress').textContent = wallet.address;
            
            displayWalletDetail();
            showView('walletDetail');
        }
        
        function copyDetailAddress() {
            if (currentDetailWallet) {
                navigator.clipboard.writeText(currentDetailWallet.address);
                alert('Indirizzo copiato!');
            }
        }
        
        function displayWalletDetail() {
            if (!currentDetailWallet) return;
            
            const walletData = walletResults[currentDetailWallet.address.toLowerCase()];
            const container = document.getElementById('detailChainsContent');
            
            if (!walletData || walletData.results.length === 0) {
                document.getElementById('detailTotal').textContent = '‚Ç¨0,00';
                document.getElementById('detailChainCount').textContent = '0';
                document.getElementById('detailTokenCount').textContent = '0';
                container.innerHTML = '<div class="card"><div class="empty-state"><div class="icon">üì≠</div><h3>Nessun dato</h3><p style="color:var(--text-secondary);">Clicca "Scan" per scansionare questo wallet</p></div></div>';
                return;
            }
            
            // Raggruppa token per chain
            const byChain = {};
            for (const token of walletData.results) {
                if (!byChain[token.chain]) byChain[token.chain] = [];
                byChain[token.chain].push(token);
            }
            
            // Calcola totali
            const totalUSD = walletData.results.reduce((s, t) => s + t.valueUSD, 0);
            const totalEUR = totalUSD * EUR_USD;
            const chainCount = Object.keys(byChain).length;
            const tokenCount = walletData.results.length;
            
            document.getElementById('detailTotal').textContent = '‚Ç¨' + formatEUR(totalEUR);
            document.getElementById('detailChainCount').textContent = chainCount;
            document.getElementById('detailTokenCount').textContent = tokenCount;
            
            // Genera HTML per ogni chain
            let html = '';
            for (const [chainKey, tokens] of Object.entries(byChain)) {
                const chain = CHAINS[chainKey];
                const chainTotal = tokens.reduce((s, t) => s + t.valueUSD, 0) * EUR_USD;
                
                html += `
                    <div class="card" style="margin-bottom:16px;">
                        <div class="card-header">
                            <div class="card-title" style="display:flex;align-items:center;gap:10px;">
                                <span style="width:12px;height:12px;border-radius:50%;background:${chain?.color || '#666'};"></span>
                                ${chain?.name || chainKey}
                            </div>
                            <div style="font-weight:600;color:var(--green);">‚Ç¨${formatEUR(chainTotal)}</div>
                        </div>
                        <table class="holdings-table">
                            <thead><tr><th>Token</th><th class="text-right">Balance</th><th class="text-right">Prezzo</th><th class="text-right">Valore</th></tr></thead>
                            <tbody>
                `;
                
                // Ordina token per valore
                tokens.sort((a, b) => b.valueUSD - a.valueUSD);
                
                for (const t of tokens) {
                    if (t.valueUSD < 0.01) continue;
                    const vEUR = t.valueUSD * EUR_USD;
                    html += `
                        <tr>
                            <td><div class="token-cell">
                                <div class="token-icon">${t.logo ? `<img src="${t.logo}" onerror="this.parentElement.textContent='${t.symbol?.slice(0,2) || '??'}'">` : (t.symbol?.slice(0,2) || '??')}</div>
                                <div class="token-info">
                                    <div class="symbol">${t.symbol || '???'}</div>
                                    <div class="name">${t.name || ''}</div>
                                </div>
                            </div></td>
                            <td class="text-right text-mono">${formatNum(t.balance, 4)}</td>
                            <td class="text-right text-mono text-secondary">$${t.price > 0 ? formatNum(t.price, 6) : '-'}</td>
                            <td class="text-right text-mono" style="color:var(--green);">‚Ç¨${formatEUR(vEUR)}</td>
                        </tr>
                    `;
                }
                
                html += '</tbody></table></div>';
            }
            
            container.innerHTML = html;
        }
        
        async function scanDetailWallet() {
            if (!currentDetailWallet) return;
            
            const etherscanKey = apiKeys.etherscan;
            if (!etherscanKey && !apiKeys.moralis) { 
                alert('Configura almeno una API in API Connect'); 
                return; 
            }
            if (selectedChains.length === 0) { alert('Seleziona almeno una chain nella Dashboard'); return; }
            
            // Scan del wallet
            const addr = currentDetailWallet.address;
            const results = [];
            
            await fetchEurUsd();
            await fetchNativePrices();
            
            for (const chainKey of selectedChains) {
                const chain = CHAINS[chainKey];
                
                // Try Moralis first for supported chains
                if (apiKeys.moralis && MORALIS_CHAINS[chainKey]) {
                    const moralisResults = await scanWithMoralis(addr, chainKey);
                    if (moralisResults && moralisResults.length > 0) {
                        results.push(...moralisResults);
                        await new Promise(r => setTimeout(r, 100));
                        continue;
                    }
                }
                
                // Fallback to Etherscan/PulseScan/Solana RPC
                if (!etherscanKey && chainKey !== 'pulse' && chainKey !== 'solana') {
                    continue;
                }
                
                // Native balance
                const nativeWei = await fetchNativeBalance(addr, etherscanKey, chain.id, chainKey);
                const nativeDecimals = chainKey === 'solana' ? 9 : 18;
                const nativeBal = Number(nativeWei) / Math.pow(10, nativeDecimals);
                const nativePrice = NATIVE_PRICES[chain.symbol] || NATIVE_PRICES.ETH;
                
                if (nativeBal > 0.0001) {
                    results.push({
                        symbol: chain.symbol,
                        name: `${chain.symbol} (${chain.name})`,
                        balance: nativeBal,
                        price: nativePrice,
                        valueUSD: nativeBal * nativePrice,
                        contract: `native-${chainKey}`,
                        logo: TOKEN_ICONS[chain.symbol],
                        chain: chainKey
                    });
                }
                
                // Token balances
                const tokens = await fetchTokenTransfers(addr, etherscanKey, chain.id, chainKey);
                
                for (const [c, t] of Object.entries(tokens)) {
                    if (isBlacklisted(c) || isSpam(t.name, t.symbol) || t.balance <= 0n) continue;
                    
                    const bal = Number(t.balance) / Math.pow(10, t.decimals);
                    let price = 0, logo = TOKEN_ICONS[t.symbol?.toUpperCase()] || null;
                    
                    const pd = await fetchTokenPrice(c, chain.dex);
                    if (pd) { price = pd.price; if (pd.logo) logo = pd.logo; }
                    
                    results.push({
                        symbol: t.symbol,
                        name: t.name,
                        balance: bal,
                        price,
                        valueUSD: bal * price,
                        contract: c,
                        logo,
                        chain: chainKey
                    });
                    
                    await new Promise(r => setTimeout(r, 150));
                }
                
                await new Promise(r => setTimeout(r, 200));
            }
            
            // Salva risultati
            walletResults[addr.toLowerCase()] = {
                name: currentDetailWallet.name,
                results: results,
                scannedAt: Date.now()
            };
            
            // Aggiorna display
            displayWalletDetail();
            updateWalletsList();
            aggregateAndDisplay();
            saveToFirebase();
        }
        
        function initChainSelector() {
            const container = document.getElementById('chainSelector');
            let html = '';
            for (const [key, chain] of Object.entries(CHAINS)) {
                const active = selectedChains.includes(key) ? 'active' : '';
                html += `<button class="chain-btn ${active}" data-chain="${key}" onclick="toggleChain('${key}')">
                    <span class="chain-dot" style="background:${chain.color}"></span>${chain.name}
                </button>`;
            }
            container.innerHTML = html;
        }
        
        function toggleChain(key) {
            const idx = selectedChains.indexOf(key);
            if (idx >= 0) selectedChains.splice(idx, 1);
            else selectedChains.push(key);
            localStorage.setItem('cryptofolio_chains', JSON.stringify(selectedChains));
            initChainSelector();
            saveToFirebase();
        }
        
        function loadSettings() {
            const w = localStorage.getItem('cryptofolio_wallet');
            const oldKey = localStorage.getItem('etherscan_api_key');
            
            if (w) document.getElementById('walletAddress').value = w;
            
            // Backward compatibility: migra vecchia API key a nuovo sistema
            if (oldKey && !apiKeys.etherscan) {
                apiKeys.etherscan = oldKey;
                localStorage.setItem('cryptofolio_apikeys', JSON.stringify(apiKeys));
                localStorage.removeItem('etherscan_api_key'); // Rimuovi vecchia chiave
            }
        }
        
        function saveSettings() {
            const w = document.getElementById('walletAddress').value.trim();
            if (w) localStorage.setItem('cryptofolio_wallet', w);
            saveToFirebase();
        }
        
        // ==================== API ====================
        async function fetchEurUsd() { 
            try { 
                const r = await fetch('https://api.exchangerate-api.com/v4/latest/USD'); 
                const d = await r.json(); 
                EUR_USD = d.rates.EUR; 
                document.getElementById('eurUsdRate').textContent = EUR_USD.toFixed(4); 
            } catch(e) { EUR_USD = 0.849; } 
        }
        
        async function fetchNativePrices() {
            try {
                const r = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=ethereum,binancecoin,matic-network,pulsechain,solana&vs_currencies=usd');
                const d = await r.json();
                NATIVE_PRICES.ETH = d.ethereum?.usd || 3000;
                NATIVE_PRICES.BNB = d.binancecoin?.usd || 600;
                NATIVE_PRICES.MATIC = d['matic-network']?.usd || 0.4;
                NATIVE_PRICES.PLS = d.pulsechain?.usd || 0.00003;
                NATIVE_PRICES.SOL = d.solana?.usd || 150;
            } catch(e) {
                NATIVE_PRICES.ETH = 3000; NATIVE_PRICES.BNB = 600; NATIVE_PRICES.MATIC = 0.4;
                NATIVE_PRICES.PLS = 0.00003; NATIVE_PRICES.SOL = 150;
            }
        }
        
        async function fetchNativeBalance(addr, apiKey, chainId, chainKey) {
            try {
                // Solana - usa RPC
                if (chainKey === 'solana') {
                    const r = await fetch('https://api.mainnet-beta.solana.com', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            jsonrpc: '2.0', id: 1, method: 'getBalance', params: [addr]
                        })
                    });
                    const d = await r.json();
                    if (d.result?.value) return BigInt(d.result.value);
                    return 0n;
                }
                
                // PulseChain - usa PulseScan API
                if (chainKey === 'pulse') {
                    const r = await fetch(`https://api.scan.pulsechain.com/api?module=account&action=balance&address=${addr}`);
                    const d = await r.json();
                    if (d.status === '1') return BigInt(d.result);
                    return 0n;
                }
                
                // EVM chains - usa Etherscan V2
                const r = await fetch(`https://api.etherscan.io/v2/api?chainid=${chainId}&module=account&action=balance&address=${addr}&tag=latest&apikey=${apiKey}`);
                const d = await r.json();
                if (d.status === '1') return BigInt(d.result);
            } catch(e) { console.error(`Balance error ${chainKey}:`, e); }
            return 0n;
        }
        
        async function fetchTokenTransfers(addr, apiKey, chainId, chainKey) {
            try {
                // Solana - usa RPC per token SPL
                if (chainKey === 'solana') {
                    const r = await fetch('https://api.mainnet-beta.solana.com', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            jsonrpc: '2.0', id: 1, 
                            method: 'getTokenAccountsByOwner',
                            params: [addr, { programId: 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' }, { encoding: 'jsonParsed' }]
                        })
                    });
                    const d = await r.json();
                    const bal = {};
                    if (d.result?.value) {
                        for (const acc of d.result.value) {
                            const info = acc.account?.data?.parsed?.info;
                            if (info && info.tokenAmount?.uiAmount > 0) {
                                const mint = info.mint;
                                bal[mint] = {
                                    symbol: 'SPL', // Will try to get from DexScreener
                                    name: 'Solana Token',
                                    decimals: info.tokenAmount.decimals,
                                    balance: BigInt(info.tokenAmount.amount)
                                };
                            }
                        }
                    }
                    return bal;
                }
                
                // PulseChain - usa PulseScan API
                if (chainKey === 'pulse') {
                    const r = await fetch(`https://api.scan.pulsechain.com/api?module=account&action=tokentx&address=${addr}&startblock=0&endblock=99999999&sort=asc`);
                    const d = await r.json();
                    if (d.status === '1' && d.result) {
                        const bal = {}, w = addr.toLowerCase();
                        for (const tx of d.result) {
                            const c = tx.contractAddress.toLowerCase();
                            if (!bal[c]) bal[c] = { symbol: tx.tokenSymbol, name: tx.tokenName, decimals: parseInt(tx.tokenDecimal||'18'), balance: 0n };
                            const v = BigInt(tx.value||'0');
                            if (tx.to.toLowerCase() === w) bal[c].balance += v;
                            if (tx.from.toLowerCase() === w) bal[c].balance -= v;
                        }
                        return bal;
                    }
                    return {};
                }
                
                // EVM chains - usa Etherscan V2
                const r = await fetch(`https://api.etherscan.io/v2/api?chainid=${chainId}&module=account&action=tokentx&address=${addr}&startblock=0&endblock=99999999&sort=asc&apikey=${apiKey}`);
                const d = await r.json();
                if (d.status === '1' && d.result) {
                    const bal = {}, w = addr.toLowerCase();
                    for (const tx of d.result) {
                        const c = tx.contractAddress.toLowerCase();
                        if (!bal[c]) bal[c] = { symbol: tx.tokenSymbol, name: tx.tokenName, decimals: parseInt(tx.tokenDecimal||'18'), balance: 0n };
                        const v = BigInt(tx.value||'0');
                        if (tx.to.toLowerCase() === w) bal[c].balance += v;
                        if (tx.from.toLowerCase() === w) bal[c].balance -= v;
                    }
                    return bal;
                }
            } catch(e) { console.error(`Token error ${chainKey}:`, e); }
            return {};
        }
        
        async function fetchTokenPrice(contract, dexChain) {
            try {
                const r = await fetch(`https://api.dexscreener.com/latest/dex/tokens/${contract}`);
                const d = await r.json();
                if (d.pairs?.length) {
                    const p = d.pairs.filter(x => x.chainId === dexChain).sort((a,b) => (b.liquidity?.usd||0) - (a.liquidity?.usd||0))[0];
                    if (p) return { price: parseFloat(p.priceUsd), logo: p.info?.imageUrl };
                }
            } catch(e) {}
            return null;
        }
        
        // ==================== SCAN ====================
        async function scanWallet() {
            const addr = document.getElementById('walletAddress').value.trim();
            const etherscanKey = apiKeys.etherscan || document.getElementById('apiKey').value.trim();
            
            if (!addr) { log('‚ùå Inserisci wallet address', 'error'); return; }
            if (!etherscanKey && !apiKeys.moralis) { 
                log('‚ùå Configura almeno una API (Moralis o Etherscan) in API Connect', 'error'); 
                return; 
            }
            if (selectedChains.length === 0) { log('‚ùå Seleziona almeno una chain', 'error'); return; }
            
            document.getElementById('statusLog').innerHTML = '';
            log(`üöÄ Scan Multi-Chain...`);
            log(`üìç ${addr.slice(0,8)}...${addr.slice(-6)}`);
            log(`‚õìÔ∏è ${selectedChains.map(c => CHAINS[c].name).join(', ')}`);
            
            // Mostra quale API sar√† usata
            if (apiKeys.moralis) {
                log(`üü¢ Usando Moralis API (veloce)`, 'info');
            } else {
                log(`üîµ Usando Etherscan API`, 'info');
            }
            
            saveSettings();
            
            try {
                await fetchEurUsd();
                await fetchNativePrices();
                log(`üí∞ ETH: $${formatNum(NATIVE_PRICES.ETH)} | BNB: $${formatNum(NATIVE_PRICES.BNB)} | SOL: $${formatNum(NATIVE_PRICES.SOL)}`, 'info');
                
                const results = [];
                
                for (const chainKey of selectedChains) {
                    const chain = CHAINS[chainKey];
                    log(`üì° ${chain.name}...`);
                    
                    // Try Moralis first for supported chains
                    if (apiKeys.moralis && MORALIS_CHAINS[chainKey]) {
                        log(`  ‚ö° Moralis...`, 'info');
                        const moralisResults = await scanWithMoralis(addr, chainKey);
                        if (moralisResults && moralisResults.length > 0) {
                            results.push(...moralisResults);
                            const nativeToken = moralisResults.find(t => t.contract.startsWith('native-'));
                            if (nativeToken) {
                                log(`  ${nativeToken.symbol}: ${formatNum(nativeToken.balance, 4)} ($${formatNum(nativeToken.valueUSD)})`, 'success');
                            }
                            const tokenCount = moralisResults.filter(t => !t.contract.startsWith('native-')).length;
                            if (tokenCount > 0) log(`  ${tokenCount} tokens`, 'info');
                            await new Promise(r => setTimeout(r, 100));
                            continue;
                        }
                    }
                    
                    // Fallback to Etherscan/PulseScan/Solana RPC
                    if (!etherscanKey && chainKey !== 'pulse' && chainKey !== 'solana') {
                        log(`  ‚ö†Ô∏è Skip - nessuna API key`, 'warning');
                        continue;
                    }
                    
                    // Native balance
                    const nativeWei = await fetchNativeBalance(addr, etherscanKey, chain.id, chainKey);
                    const nativeDecimals = chainKey === 'solana' ? 9 : 18;
                    const nativeBal = Number(nativeWei) / Math.pow(10, nativeDecimals);
                    const nativePrice = NATIVE_PRICES[chain.symbol] || NATIVE_PRICES.ETH;
                    
                    if (nativeBal > 0.0001) {
                        results.push({
                            symbol: chain.symbol,
                            name: `${chain.symbol} (${chain.name})`,
                            balance: nativeBal,
                            price: nativePrice,
                            valueUSD: nativeBal * nativePrice,
                            contract: `native-${chainKey}`,
                            logo: TOKEN_ICONS[chain.symbol],
                            chain: chainKey
                        });
                        log(`  ${chain.symbol}: ${formatNum(nativeBal, 4)} ($${formatNum(nativeBal * nativePrice)})`, 'success');
                    }
                    
                    // Token balances
                    const tokens = await fetchTokenTransfers(addr, etherscanKey, chain.id, chainKey);
                    let tokenCount = 0;
                    
                    for (const [c, t] of Object.entries(tokens)) {
                        if (isBlacklisted(c) || isSpam(t.name, t.symbol) || t.balance <= 0n) continue;
                        
                        const bal = Number(t.balance) / Math.pow(10, t.decimals);
                        let price = 0, logo = TOKEN_ICONS[t.symbol?.toUpperCase()] || null;
                        
                        const pd = await fetchTokenPrice(c, chain.dex);
                        if (pd) { price = pd.price; if (pd.logo) logo = pd.logo; }
                        
                        results.push({
                            symbol: t.symbol,
                            name: t.name,
                            balance: bal,
                            price,
                            valueUSD: bal * price,
                            contract: c,
                            logo,
                            chain: chainKey
                        });
                        
                        tokenCount++;
                        if (price > 0 && bal * price >= 1) {
                            log(`  ${t.symbol}: $${formatNum(bal * price)}`, 'success');
                        }
                        
                        await new Promise(r => setTimeout(r, 150));
                    }
                    
                    if (tokenCount > 0) log(`  ${tokenCount} tokens`, 'info');
                    await new Promise(r => setTimeout(r, 200));
                }
                
                results.sort((a, b) => b.valueUSD - a.valueUSD);
                
                // Trova nome wallet se salvato
                const walletName = savedWallets.find(w => w.address.toLowerCase() === addr.toLowerCase())?.name || 'Wallet';
                
                // Salva risultati per questo wallet
                walletResults[addr.toLowerCase()] = {
                    name: walletName,
                    results: results,
                    scannedAt: Date.now()
                };
                
                // Aggrega tutti i wallet per display
                aggregateAndDisplay();
                
                // Salva risultati su Firebase
                saveToFirebase();
                
                log('‚úÖ Completato!', 'success');
                document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString('it-IT');
                
            } catch(e) {
                log(`‚ùå Errore: ${e.message}`, 'error');
                console.error(e);
            }
        }
        
        // ==================== MULTI-WALLET ====================
        function aggregateAndDisplay() {
            // Combina risultati di tutti i wallet
            const allResults = [];
            
            for (const [addr, data] of Object.entries(walletResults)) {
                for (const token of data.results) {
                    // Aggiungi info wallet al token
                    allResults.push({
                        ...token,
                        walletAddress: addr,
                        walletName: data.name
                    });
                }
            }
            
            // Ordina per valore
            allResults.sort((a, b) => b.valueUSD - a.valueUSD);
            lastScanResults = allResults;
            
            displayResults(allResults);
        }
        
        async function scanAllWallets() {
            const etherscanKey = apiKeys.etherscan;
            if (!etherscanKey && !apiKeys.moralis) { 
                log('‚ùå Configura almeno una API (Moralis o Etherscan) in API Connect', 'error'); 
                return; 
            }
            if (savedWallets.length === 0) { log('‚ùå Nessun wallet salvato. Vai su Wallets per aggiungerli.', 'error'); return; }
            if (selectedChains.length === 0) { log('‚ùå Seleziona almeno una chain', 'error'); return; }
            
            document.getElementById('statusLog').innerHTML = '';
            log(`üöÄ Scan di ${savedWallets.length} wallet...`);
            
            // Mostra quale API sar√† usata
            if (apiKeys.moralis) {
                log(`üü¢ Usando Moralis API (veloce)`, 'info');
            } else {
                log(`üîµ Usando Etherscan API`, 'info');
            }
            
            // Reset risultati
            walletResults = {};
            
            await fetchEurUsd();
            await fetchNativePrices();
            log(`üí∞ ETH: $${formatNum(NATIVE_PRICES.ETH)} | BNB: $${formatNum(NATIVE_PRICES.BNB)} | SOL: $${formatNum(NATIVE_PRICES.SOL)}`, 'info');
            
            for (let i = 0; i < savedWallets.length; i++) {
                const wallet = savedWallets[i];
                log(`\nüìç [${i+1}/${savedWallets.length}] ${wallet.name}`);
                log(`   ${wallet.address.slice(0,8)}...${wallet.address.slice(-6)}`);
                
                const results = [];
                
                for (const chainKey of selectedChains) {
                    const chain = CHAINS[chainKey];
                    log(`   ‚õìÔ∏è ${chain.name}...`);
                    
                    // Try Moralis first for supported chains
                    if (apiKeys.moralis && MORALIS_CHAINS[chainKey]) {
                        const moralisResults = await scanWithMoralis(wallet.address, chainKey);
                        if (moralisResults && moralisResults.length > 0) {
                            results.push(...moralisResults);
                            const nativeToken = moralisResults.find(t => t.contract.startsWith('native-'));
                            if (nativeToken) {
                                log(`      ${nativeToken.symbol}: ${formatNum(nativeToken.balance, 4)} ($${formatNum(nativeToken.valueUSD)})`, 'success');
                            }
                            const tokenCount = moralisResults.filter(t => !t.contract.startsWith('native-') && t.valueUSD >= 1).length;
                            for (const t of moralisResults.filter(t => !t.contract.startsWith('native-') && t.valueUSD >= 1)) {
                                log(`      ${t.symbol}: $${formatNum(t.valueUSD)}`, 'success');
                            }
                            await new Promise(r => setTimeout(r, 100));
                            continue;
                        }
                    }
                    
                    // Fallback to Etherscan/PulseScan/Solana RPC
                    if (!etherscanKey && chainKey !== 'pulse' && chainKey !== 'solana') {
                        continue; // Skip silently
                    }
                    
                    // Native balance
                    const nativeWei = await fetchNativeBalance(wallet.address, etherscanKey, chain.id, chainKey);
                    const nativeDecimals = chainKey === 'solana' ? 9 : 18;
                    const nativeBal = Number(nativeWei) / Math.pow(10, nativeDecimals);
                    const nativePrice = NATIVE_PRICES[chain.symbol] || NATIVE_PRICES.ETH;
                    
                    if (nativeBal > 0.0001) {
                        results.push({
                            symbol: chain.symbol,
                            name: `${chain.symbol} (${chain.name})`,
                            balance: nativeBal,
                            price: nativePrice,
                            valueUSD: nativeBal * nativePrice,
                            contract: `native-${chainKey}`,
                            logo: TOKEN_ICONS[chain.symbol],
                            chain: chainKey
                        });
                        log(`      ${chain.symbol}: ${formatNum(nativeBal, 4)} ($${formatNum(nativeBal * nativePrice)})`, 'success');
                    }
                    
                    // Token balances
                    const tokens = await fetchTokenTransfers(wallet.address, etherscanKey, chain.id, chainKey);
                    
                    for (const [c, t] of Object.entries(tokens)) {
                        if (isBlacklisted(c) || isSpam(t.name, t.symbol) || t.balance <= 0n) continue;
                        
                        const bal = Number(t.balance) / Math.pow(10, t.decimals);
                        let price = 0, logo = TOKEN_ICONS[t.symbol?.toUpperCase()] || null;
                        
                        const pd = await fetchTokenPrice(c, chain.dex);
                        if (pd) { price = pd.price; if (pd.logo) logo = pd.logo; }
                        
                        results.push({
                            symbol: t.symbol,
                            name: t.name,
                            balance: bal,
                            price,
                            valueUSD: bal * price,
                            contract: c,
                            logo,
                            chain: chainKey
                        });
                        
                        if (price > 0 && bal * price >= 1) {
                            log(`      ${t.symbol}: $${formatNum(bal * price)}`, 'success');
                        }
                        
                        await new Promise(r => setTimeout(r, 150));
                    }
                    
                    await new Promise(r => setTimeout(r, 200));
                }
                
                // Salva risultati wallet
                walletResults[wallet.address.toLowerCase()] = {
                    name: wallet.name,
                    results: results,
                    scannedAt: Date.now()
                };
                
                const walletTotal = results.reduce((s, t) => s + t.valueUSD, 0);
                log(`   üí∞ Totale ${wallet.name}: $${formatNum(walletTotal)}`, 'success');
            }
            
            // Aggrega e mostra
            aggregateAndDisplay();
            
            // Salva risultati su Firebase
            saveToFirebase();
            
            const grandTotal = Object.values(walletResults).reduce((sum, w) => 
                sum + w.results.reduce((s, t) => s + t.valueUSD, 0), 0);
            
            log(`\nüéâ TOTALE PORTFOLIO: $${formatNum(grandTotal)} (‚Ç¨${formatNum(grandTotal * EUR_USD)})`, 'success');
            document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString('it-IT');
        }
        
        function clearWalletResults() {
            walletResults = {};
            lastScanResults = [];
            displayResults([]);
            saveToFirebase();
            log('üóëÔ∏è Risultati cancellati', 'info');
        }
        
        // ==================== DISPLAY ====================
        function displayResults(results) {
            const visible = results.filter(t => !isBlacklisted(t.contract));
            const withVal = visible.filter(t => t.valueUSD >= 0.01);
            const totalUSD = withVal.reduce((s, t) => s + t.valueUSD, 0);
            const totalEUR = totalUSD * EUR_USD;
            
            document.getElementById('totalEUR').textContent = '‚Ç¨' + formatEUR(totalEUR);
            document.getElementById('totalUSD').textContent = '$' + formatEUR(totalUSD) + ' USD';
            document.getElementById('tokenCount').textContent = withVal.length;
            
            // Conta wallet scansionati
            const scannedCount = Object.keys(walletResults).length;
            document.getElementById('scannedWallets').textContent = scannedCount;
            const walletNames = Object.values(walletResults).map(w => w.name).join(', ') || '-';
            document.getElementById('chainNames').textContent = walletNames.length > 30 ? walletNames.slice(0, 30) + '...' : walletNames;
            
            const container = document.getElementById('holdingsContent');
            if (!withVal.length) {
                container.innerHTML = '<div class="empty-state"><div class="icon">üì≠</div><h3>Nessun token con valore</h3></div>';
                return;
            }
            
            let html = `<table class="holdings-table">
                <thead><tr><th>Token</th><th class="text-right">Balance</th><th class="text-right">Prezzo</th><th class="text-right">Valore</th></tr></thead>
                <tbody>`;
            
            for (const t of withVal) {
                const chain = CHAINS[t.chain];
                const pct = totalUSD > 0 ? ((t.valueUSD / totalUSD) * 100).toFixed(1) : '0';
                const vEUR = t.valueUSD * EUR_USD;
                
                html += `<tr>
                    <td><div class="token-cell">
                        <button class="hide-btn" onclick="hideToken('${t.contract}','${t.symbol}')">‚úï</button>
                        <div class="token-icon">${t.logo ? `<img src="${t.logo}" onerror="this.parentElement.textContent='${t.symbol.slice(0,2)}'">` : t.symbol.slice(0,2)}</div>
                        <div class="token-info">
                            <div class="symbol">${t.symbol}<span class="chain-badge" style="background:${chain?.color || '#666'}20;color:${chain?.color || '#666'}">${t.chain}</span></div>
                            <div class="name">${t.name}${t.walletName ? ` <span style="color:var(--accent-light);font-size:10px;">‚Ä¢ ${t.walletName}</span>` : ''}</div>
                        </div>
                    </div></td>
                    <td class="text-right text-mono">${formatNum(t.balance, 4)}</td>
                    <td class="text-right text-mono text-secondary">$${t.price > 0 ? formatNum(t.price, 6) : '-'}</td>
                    <td class="text-right">
                        <div class="text-mono" style="color:var(--green);">‚Ç¨${formatEUR(vEUR)}</div>
                        <div class="text-secondary" style="font-size:11px;">${pct}%</div>
                    </td>
                </tr>`;
            }
            
            html += '</tbody></table>';
            container.innerHTML = html;
            
            // Chart
            if (withVal.length > 0) renderChart(withVal, totalUSD);
        }
        
        function renderChart(tokens, total) {
            const ctx = document.getElementById('allocationChart').getContext('2d');
            if (allocationChart) allocationChart.destroy();
            
            const top5 = tokens.slice(0, 5);
            const others = tokens.slice(5);
            const othersVal = others.reduce((s, t) => s + t.valueUSD, 0);
            
            const labels = top5.map(t => t.symbol);
            const data = top5.map(t => t.valueUSD);
            if (othersVal > 0) { labels.push('Altri'); data.push(othersVal); }
            
            const colors = ['#6c5ce7', '#00cec9', '#ffeaa7', '#ff7675', '#74b9ff', '#a29bfe'];
            
            allocationChart = new Chart(ctx, {
                type: 'doughnut',
                data: { labels, datasets: [{ data, backgroundColor: colors.slice(0, data.length), borderWidth: 0 }] },
                options: { responsive: true, cutout: '70%', plugins: { legend: { position: 'bottom', labels: { color: '#a0a0a0', padding: 15 } } } }
            });
        }
        
        // ==================== TAX REPORT ====================
        async function calculateTaxReportAll() {
            const etherscanKey = apiKeys.etherscan;
            
            if (!etherscanKey) { 
                alert('Configura Etherscan API in API Connect prima! (necessaria per storico transazioni)'); 
                return; 
            }
            
            if (savedWallets.length === 0) {
                alert('Nessun wallet salvato! Vai su Wallets per aggiungerne.');
                return;
            }
            
            if (selectedChains.length === 0) {
                alert('Seleziona almeno una chain nella Dashboard!');
                return;
            }
            
            const container = document.getElementById('taxReportContent');
            const detailCard = document.getElementById('taxDetailCard');
            const detailContent = document.getElementById('taxDetailContent');
            
            container.innerHTML = `<div class="empty-state"><div class="icon">‚è≥</div><h3>Caricamento ${savedWallets.length} wallet su ${selectedChains.length} chain...</h3></div>`;
            
            const years = [2021, 2022, 2023, 2024, 2025];
            
            // Totali aggregati per anno
            const grandTotals = {};
            for (const y of years) grandTotals[y] = { eur: 0, usd: 0 };
            
            // Dettagli per wallet
            const walletDetails = [];
            
            // Chain native symbols
            const CHAIN_NATIVE = {
                eth: 'ETH', bsc: 'BNB', polygon: 'MATIC', arbitrum: 'ETH', 
                optimism: 'ETH', base: 'ETH', pulse: 'PLS', solana: 'SOL'
            };
            
            try {
                for (let wi = 0; wi < savedWallets.length; wi++) {
                    const wallet = savedWallets[wi];
                    const addr = wallet.address;
                    const walletLower = addr.toLowerCase();
                    
                    const balances = {};
                    const allTokens = {};
                    for (const y of years) balances[y] = {};
                    
                    for (const chainKey of selectedChains) {
                        const chain = CHAINS[chainKey];
                        const nativeSym = CHAIN_NATIVE[chainKey];
                        
                        container.innerHTML = `<div class="empty-state"><div class="icon">‚è≥</div><h3>Wallet ${wi + 1}/${savedWallets.length}: ${wallet.name}<br><small style="color:var(--text-secondary);">${chain.name}...</small></h3></div>`;
                        
                        let nativeTx = [], internalTx = [], tokenTx = [];
                        
                        // Fetch transactions based on chain type
                        if (chainKey === 'pulse') {
                            // PulseChain - use PulseScan
                            const [nRes, tRes] = await Promise.all([
                                fetch(`https://api.scan.pulsechain.com/api?module=account&action=txlist&address=${addr}&startblock=0&endblock=99999999&sort=asc`).then(r => r.json()),
                                fetch(`https://api.scan.pulsechain.com/api?module=account&action=tokentx&address=${addr}&startblock=0&endblock=99999999&sort=asc`).then(r => r.json())
                            ]);
                            nativeTx = nRes.status === '1' ? nRes.result : [];
                            tokenTx = tRes.status === '1' ? tRes.result : [];
                        } else if (chainKey === 'solana') {
                            // Solana - skip for now (no easy historical API)
                            continue;
                        } else {
                            // EVM chains - use Etherscan V2
                            const [nRes, iRes, tRes] = await Promise.all([
                                fetch(`https://api.etherscan.io/v2/api?chainid=${chain.id}&module=account&action=txlist&address=${addr}&startblock=0&endblock=99999999&sort=asc&apikey=${etherscanKey}`).then(r => r.json()),
                                fetch(`https://api.etherscan.io/v2/api?chainid=${chain.id}&module=account&action=txlistinternal&address=${addr}&startblock=0&endblock=99999999&sort=asc&apikey=${etherscanKey}`).then(r => r.json()),
                                fetch(`https://api.etherscan.io/v2/api?chainid=${chain.id}&module=account&action=tokentx&address=${addr}&startblock=0&endblock=99999999&sort=asc&apikey=${etherscanKey}`).then(r => r.json())
                            ]);
                            nativeTx = nRes.status === '1' ? nRes.result : [];
                            internalTx = iRes.status === '1' ? iRes.result : [];
                            tokenTx = tRes.status === '1' ? tRes.result : [];
                        }
                        
                        // Get tokens from this chain
                        for (const tx of tokenTx) {
                            const sym = tx.tokenSymbol?.toUpperCase();
                            const c = tx.contractAddress.toLowerCase();
                            const key = `${chainKey}:${c}`;
                            if (!allTokens[key]) {
                                allTokens[key] = { 
                                    symbol: tx.tokenSymbol, 
                                    decimals: parseInt(tx.tokenDecimal || '18'),
                                    chain: chainKey,
                                    chainName: chain.name
                                };
                            }
                        }
                        
                        // Calculate native balance per year
                        for (const y of years) {
                            const ts = new Date(`${y + 1}-01-01T00:00:00Z`).getTime() / 1000;
                            let bal = 0n;
                            
                            for (const tx of nativeTx) {
                                if (parseInt(tx.timeStamp) >= ts || tx.isError === '1') continue;
                                const v = BigInt(tx.value || '0');
                                const g = BigInt(tx.gasUsed || '0') * BigInt(tx.gasPrice || '0');
                                if (tx.to?.toLowerCase() === walletLower) bal += v;
                                if (tx.from?.toLowerCase() === walletLower) { bal -= v; bal -= g; }
                            }
                            
                            for (const tx of internalTx) {
                                if (parseInt(tx.timeStamp) >= ts || tx.isError === '1') continue;
                                const v = BigInt(tx.value || '0');
                                if (tx.to?.toLowerCase() === walletLower) bal += v;
                                if (tx.from?.toLowerCase() === walletLower) bal -= v;
                            }
                            
                            const nativeKey = `${nativeSym} (${chain.name})`;
                            if (!balances[y][nativeKey]) balances[y][nativeKey] = 0;
                            balances[y][nativeKey] += Number(bal < 0n ? 0n : bal) / 1e18;
                        }
                        
                        // Calculate token balances per year
                        for (const tx of tokenTx) {
                            const c = tx.contractAddress.toLowerCase();
                            const key = `${chainKey}:${c}`;
                            const info = allTokens[key];
                            if (!info) continue;
                            
                            for (const y of years) {
                                const ts = new Date(`${y + 1}-01-01T00:00:00Z`).getTime() / 1000;
                                if (parseInt(tx.timeStamp) >= ts) continue;
                                
                                const tokenKey = `${info.symbol} (${chain.name})`;
                                if (!balances[y][tokenKey]) balances[y][tokenKey] = 0;
                                
                                const v = BigInt(tx.value || '0');
                                const amount = Number(v) / Math.pow(10, info.decimals);
                                
                                if (tx.to?.toLowerCase() === walletLower) {
                                    balances[y][tokenKey] += amount;
                                }
                                if (tx.from?.toLowerCase() === walletLower) {
                                    balances[y][tokenKey] -= amount;
                                }
                            }
                        }
                        
                        // Rate limit
                        await new Promise(r => setTimeout(r, 250));
                    }
                    
                    // Fix negative balances
                    for (const y of years) {
                        for (const key of Object.keys(balances[y])) {
                            if (balances[y][key] < 0) balances[y][key] = 0;
                        }
                    }
                    
                    // Calculate wallet totals per year
                    const walletTotals = {};
                    for (const y of years) {
                        walletTotals[y] = { eur: 0, usd: 0 };
                        
                        for (const [tokenKey, bal] of Object.entries(balances[y])) {
                            if (bal <= 0) continue;
                            
                            // Extract symbol from key like "ETH (Ethereum)"
                            const sym = tokenKey.split(' (')[0].toUpperCase();
                            const cgId = SYMBOL_TO_CG[sym];
                            const price = HISTORICAL_PRICES[cgId]?.[y] || 0;
                            
                            if (price > 0) {
                                walletTotals[y].usd += bal * price;
                                walletTotals[y].eur += bal * price * EUR_USD;
                            }
                        }
                        
                        // Add to grand totals
                        grandTotals[y].usd += walletTotals[y].usd;
                        grandTotals[y].eur += walletTotals[y].eur;
                    }
                    
                    walletDetails.push({ wallet, balances, totals: walletTotals, tokens: allTokens });
                }
                
                // Prepara struttura dati serializzabile per Firebase
                const chainNames = selectedChains.map(c => CHAINS[c].name).join(', ');
                const serializedWalletDetails = walletDetails.map(wd => {
                    // Get all token keys that have value
                    const tokenKeys = new Set();
                    for (const y of years) {
                        for (const key of Object.keys(wd.balances[y])) {
                            if (wd.balances[y][key] > 0) tokenKeys.add(key);
                        }
                    }
                    
                    const rows = [];
                    for (const tokenKey of tokenKeys) {
                        const sym = tokenKey.split(' (')[0].toUpperCase();
                        const cgId = SYMBOL_TO_CG[sym];
                        
                        // Check if has any value
                        const hasValue = years.some(y => {
                            const bal = wd.balances[y][tokenKey] || 0;
                            const price = HISTORICAL_PRICES[cgId]?.[y] || 0;
                            return bal * price * EUR_USD >= 1;
                        });
                        if (!hasValue) continue;
                        
                        const cells = {};
                        for (const y of years) {
                            const bal = wd.balances[y][tokenKey] || 0;
                            const price = HISTORICAL_PRICES[cgId]?.[y] || 0;
                            cells[y] = {
                                balance: bal,
                                eur: bal * price * EUR_USD,
                                hasValue: bal > 0 && price > 0
                            };
                        }
                        rows.push({ tokenKey, cells });
                    }
                    
                    return {
                        walletName: wd.wallet.name,
                        walletAddress: wd.wallet.address.slice(0,8) + '...' + wd.wallet.address.slice(-6),
                        totals: wd.totals,
                        rows
                    };
                });
                
                // Salva in memoria e Firebase
                taxReportData = {
                    grandTotals,
                    walletDetails: serializedWalletDetails,
                    walletCount: savedWallets.length,
                    chainNames,
                    calculatedAt: Date.now()
                };
                saveToFirebase();
                
                // Render usando la funzione condivisa
                renderTaxReport(taxReportData);
                
            } catch(e) {
                container.innerHTML = `<div class="empty-state"><div class="icon">‚ùå</div><h3>Errore: ${e.message}</h3></div>`;
                console.error(e);
            }
        }
        
        // ==================== INIT ====================
        async function init() {
            loadSettings();
            await loadFromFirebase();
            initChainSelector();
            updateBlacklist();
            updateWalletsList();
            updateWalletSelect();
            updateApiCount();
            
            // Mostra API key se configurata
            if (apiKeys.moralis && apiKeys.etherscan) {
                document.getElementById('apiKey').value = '‚úì Moralis + Etherscan';
            } else if (apiKeys.moralis) {
                document.getElementById('apiKey').value = '‚úì Moralis configurato';
            } else if (apiKeys.etherscan) {
                document.getElementById('apiKey').value = '‚úì Etherscan configurato';
            } else {
                document.getElementById('apiKey').value = '';
                document.getElementById('apiKey').placeholder = '‚ö†Ô∏è Configura API...';
            }
            
            // Mostra risultati salvati se presenti
            if (Object.keys(walletResults).length > 0) {
                aggregateAndDisplay();
                const lastScan = Object.values(walletResults).reduce((latest, w) => 
                    w.scannedAt > latest ? w.scannedAt : latest, 0);
                if (lastScan) {
                    document.getElementById('lastUpdate').textContent = 'Ultimo: ' + new Date(lastScan).toLocaleString('it-IT');
                }
                console.log('üìä Loaded', Object.keys(walletResults).length, 'wallet results from Firebase');
            }
        }
        init();
    </script>
</body>
</html>
